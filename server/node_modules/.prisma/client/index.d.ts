
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model InternalAudit
 * 
 */
export type InternalAudit = $Result.DefaultSelection<Prisma.$InternalAuditPayload>
/**
 * Model ExternalAudit
 * 
 */
export type ExternalAudit = $Result.DefaultSelection<Prisma.$ExternalAuditPayload>
/**
 * Model AuditProgram
 * 
 */
export type AuditProgram = $Result.DefaultSelection<Prisma.$AuditProgramPayload>
/**
 * Model AuditChecklist
 * 
 */
export type AuditChecklist = $Result.DefaultSelection<Prisma.$AuditChecklistPayload>
/**
 * Model ActionItem
 * 
 */
export type ActionItem = $Result.DefaultSelection<Prisma.$ActionItemPayload>
/**
 * Model RootCauseAnalysis
 * 
 */
export type RootCauseAnalysis = $Result.DefaultSelection<Prisma.$RootCauseAnalysisPayload>
/**
 * Model Occurrence
 * 
 */
export type Occurrence = $Result.DefaultSelection<Prisma.$OccurrencePayload>
/**
 * Model Sector
 * 
 */
export type Sector = $Result.DefaultSelection<Prisma.$SectorPayload>
/**
 * Model ImportLog
 * 
 */
export type ImportLog = $Result.DefaultSelection<Prisma.$ImportLogPayload>
/**
 * Model AuditTrail
 * 
 */
export type AuditTrail = $Result.DefaultSelection<Prisma.$AuditTrailPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Approval
 * 
 */
export type Approval = $Result.DefaultSelection<Prisma.$ApprovalPayload>
/**
 * Model WorkflowDefinition
 * 
 */
export type WorkflowDefinition = $Result.DefaultSelection<Prisma.$WorkflowDefinitionPayload>
/**
 * Model WorkflowStep
 * 
 */
export type WorkflowStep = $Result.DefaultSelection<Prisma.$WorkflowStepPayload>
/**
 * Model WorkflowInstance
 * 
 */
export type WorkflowInstance = $Result.DefaultSelection<Prisma.$WorkflowInstancePayload>
/**
 * Model WorkflowStepExecution
 * 
 */
export type WorkflowStepExecution = $Result.DefaultSelection<Prisma.$WorkflowStepExecutionPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentVersion
 * 
 */
export type DocumentVersion = $Result.DefaultSelection<Prisma.$DocumentVersionPayload>
/**
 * Model DocumentTag
 * 
 */
export type DocumentTag = $Result.DefaultSelection<Prisma.$DocumentTagPayload>
/**
 * Model DocumentReadConfirmation
 * 
 */
export type DocumentReadConfirmation = $Result.DefaultSelection<Prisma.$DocumentReadConfirmationPayload>
/**
 * Model ReportTemplate
 * 
 */
export type ReportTemplate = $Result.DefaultSelection<Prisma.$ReportTemplatePayload>
/**
 * Model ReportComponent
 * 
 */
export type ReportComponent = $Result.DefaultSelection<Prisma.$ReportComponentPayload>
/**
 * Model ScheduledReport
 * 
 */
export type ScheduledReport = $Result.DefaultSelection<Prisma.$ScheduledReportPayload>
/**
 * Model ReportExecution
 * 
 */
export type ReportExecution = $Result.DefaultSelection<Prisma.$ReportExecutionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  GESTOR: 'GESTOR',
  AUDITOR: 'AUDITOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ActionOrigin: {
  INTERNA: 'INTERNA',
  EXTERNA: 'EXTERNA',
  OCORRENCIA: 'OCORRENCIA'
};

export type ActionOrigin = (typeof ActionOrigin)[keyof typeof ActionOrigin]


export const Conformidade: {
  CONFORMIDADE: 'CONFORMIDADE',
  NAO_CONFORMIDADE: 'NAO_CONFORMIDADE'
};

export type Conformidade = (typeof Conformidade)[keyof typeof Conformidade]


export const ActionStatus: {
  EXECUTADA: 'EXECUTADA',
  EXECUTADA_ATRASO: 'EXECUTADA_ATRASO',
  ATRASADA: 'ATRASADA',
  ANDAMENTO: 'ANDAMENTO'
};

export type ActionStatus = (typeof ActionStatus)[keyof typeof ActionStatus]


export const Impact: {
  BAIXO: 'BAIXO',
  MEDIO: 'MEDIO',
  ALTO: 'ALTO'
};

export type Impact = (typeof Impact)[keyof typeof Impact]


export const RootCauseAnalysisType: {
  ISHIKAWA: 'ISHIKAWA',
  FTA: 'FTA',
  FIVE_WHYS: 'FIVE_WHYS'
};

export type RootCauseAnalysisType = (typeof RootCauseAnalysisType)[keyof typeof RootCauseAnalysisType]


export const OccurrenceType: {
  AMBIENTAL: 'AMBIENTAL',
  SEGURANCA_TRABALHADORES: 'SEGURANCA_TRABALHADORES',
  SEGURANCA_ALIMENTAR: 'SEGURANCA_ALIMENTAR',
  RECLAMACAO: 'RECLAMACAO',
  SUGESTAO: 'SUGESTAO'
};

export type OccurrenceType = (typeof OccurrenceType)[keyof typeof OccurrenceType]


export const OccurrenceSeverity: {
  BAIXA: 'BAIXA',
  MEDIA: 'MEDIA',
  ALTA: 'ALTA',
  CRITICA: 'CRITICA'
};

export type OccurrenceSeverity = (typeof OccurrenceSeverity)[keyof typeof OccurrenceSeverity]


export const OccurrenceStatus: {
  ABERTA: 'ABERTA',
  EM_MITIGACAO: 'EM_MITIGACAO',
  RESOLVIDA: 'RESOLVIDA'
};

export type OccurrenceStatus = (typeof OccurrenceStatus)[keyof typeof OccurrenceStatus]


export const ImportStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  IMPORT: 'IMPORT'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const WorkflowStepType: {
  APPROVAL: 'APPROVAL',
  NOTIFICATION: 'NOTIFICATION',
  CONDITION: 'CONDITION'
};

export type WorkflowStepType = (typeof WorkflowStepType)[keyof typeof WorkflowStepType]


export const WorkflowStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]


export const SessionStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const DocumentStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ARCHIVED: 'ARCHIVED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const DocumentAccessLevel: {
  PRIVATE: 'PRIVATE',
  INTERNAL: 'INTERNAL',
  PUBLIC: 'PUBLIC'
};

export type DocumentAccessLevel = (typeof DocumentAccessLevel)[keyof typeof DocumentAccessLevel]


export const ReportType: {
  AUDIT_INTERNAL: 'AUDIT_INTERNAL',
  AUDIT_EXTERNAL: 'AUDIT_EXTERNAL',
  ACTIONS: 'ACTIONS',
  OCCURRENCES: 'OCCURRENCES',
  CONSOLIDATED: 'CONSOLIDATED',
  CUSTOM: 'CUSTOM'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  ARCHIVED: 'ARCHIVED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const ReportComponentType: {
  KPI: 'KPI',
  TABLE: 'TABLE',
  CHART_BAR: 'CHART_BAR',
  CHART_LINE: 'CHART_LINE',
  CHART_PIE: 'CHART_PIE',
  CHART_AREA: 'CHART_AREA',
  TEXT: 'TEXT',
  IMAGE: 'IMAGE'
};

export type ReportComponentType = (typeof ReportComponentType)[keyof typeof ReportComponentType]


export const ReportFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  YEARLY: 'YEARLY',
  ON_DEMAND: 'ON_DEMAND'
};

export type ReportFrequency = (typeof ReportFrequency)[keyof typeof ReportFrequency]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ActionOrigin = $Enums.ActionOrigin

export const ActionOrigin: typeof $Enums.ActionOrigin

export type Conformidade = $Enums.Conformidade

export const Conformidade: typeof $Enums.Conformidade

export type ActionStatus = $Enums.ActionStatus

export const ActionStatus: typeof $Enums.ActionStatus

export type Impact = $Enums.Impact

export const Impact: typeof $Enums.Impact

export type RootCauseAnalysisType = $Enums.RootCauseAnalysisType

export const RootCauseAnalysisType: typeof $Enums.RootCauseAnalysisType

export type OccurrenceType = $Enums.OccurrenceType

export const OccurrenceType: typeof $Enums.OccurrenceType

export type OccurrenceSeverity = $Enums.OccurrenceSeverity

export const OccurrenceSeverity: typeof $Enums.OccurrenceSeverity

export type OccurrenceStatus = $Enums.OccurrenceStatus

export const OccurrenceStatus: typeof $Enums.OccurrenceStatus

export type ImportStatus = $Enums.ImportStatus

export const ImportStatus: typeof $Enums.ImportStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type WorkflowStepType = $Enums.WorkflowStepType

export const WorkflowStepType: typeof $Enums.WorkflowStepType

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type DocumentAccessLevel = $Enums.DocumentAccessLevel

export const DocumentAccessLevel: typeof $Enums.DocumentAccessLevel

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type ReportComponentType = $Enums.ReportComponentType

export const ReportComponentType: typeof $Enums.ReportComponentType

export type ReportFrequency = $Enums.ReportFrequency

export const ReportFrequency: typeof $Enums.ReportFrequency

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.internalAudit`: Exposes CRUD operations for the **InternalAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternalAudits
    * const internalAudits = await prisma.internalAudit.findMany()
    * ```
    */
  get internalAudit(): Prisma.InternalAuditDelegate<ExtArgs>;

  /**
   * `prisma.externalAudit`: Exposes CRUD operations for the **ExternalAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalAudits
    * const externalAudits = await prisma.externalAudit.findMany()
    * ```
    */
  get externalAudit(): Prisma.ExternalAuditDelegate<ExtArgs>;

  /**
   * `prisma.auditProgram`: Exposes CRUD operations for the **AuditProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditPrograms
    * const auditPrograms = await prisma.auditProgram.findMany()
    * ```
    */
  get auditProgram(): Prisma.AuditProgramDelegate<ExtArgs>;

  /**
   * `prisma.auditChecklist`: Exposes CRUD operations for the **AuditChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditChecklists
    * const auditChecklists = await prisma.auditChecklist.findMany()
    * ```
    */
  get auditChecklist(): Prisma.AuditChecklistDelegate<ExtArgs>;

  /**
   * `prisma.actionItem`: Exposes CRUD operations for the **ActionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionItems
    * const actionItems = await prisma.actionItem.findMany()
    * ```
    */
  get actionItem(): Prisma.ActionItemDelegate<ExtArgs>;

  /**
   * `prisma.rootCauseAnalysis`: Exposes CRUD operations for the **RootCauseAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RootCauseAnalyses
    * const rootCauseAnalyses = await prisma.rootCauseAnalysis.findMany()
    * ```
    */
  get rootCauseAnalysis(): Prisma.RootCauseAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.occurrence`: Exposes CRUD operations for the **Occurrence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Occurrences
    * const occurrences = await prisma.occurrence.findMany()
    * ```
    */
  get occurrence(): Prisma.OccurrenceDelegate<ExtArgs>;

  /**
   * `prisma.sector`: Exposes CRUD operations for the **Sector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sectors
    * const sectors = await prisma.sector.findMany()
    * ```
    */
  get sector(): Prisma.SectorDelegate<ExtArgs>;

  /**
   * `prisma.importLog`: Exposes CRUD operations for the **ImportLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportLogs
    * const importLogs = await prisma.importLog.findMany()
    * ```
    */
  get importLog(): Prisma.ImportLogDelegate<ExtArgs>;

  /**
   * `prisma.auditTrail`: Exposes CRUD operations for the **AuditTrail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditTrails
    * const auditTrails = await prisma.auditTrail.findMany()
    * ```
    */
  get auditTrail(): Prisma.AuditTrailDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<ExtArgs>;

  /**
   * `prisma.workflowDefinition`: Exposes CRUD operations for the **WorkflowDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowDefinitions
    * const workflowDefinitions = await prisma.workflowDefinition.findMany()
    * ```
    */
  get workflowDefinition(): Prisma.WorkflowDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.workflowStep`: Exposes CRUD operations for the **WorkflowStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowSteps
    * const workflowSteps = await prisma.workflowStep.findMany()
    * ```
    */
  get workflowStep(): Prisma.WorkflowStepDelegate<ExtArgs>;

  /**
   * `prisma.workflowInstance`: Exposes CRUD operations for the **WorkflowInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowInstances
    * const workflowInstances = await prisma.workflowInstance.findMany()
    * ```
    */
  get workflowInstance(): Prisma.WorkflowInstanceDelegate<ExtArgs>;

  /**
   * `prisma.workflowStepExecution`: Exposes CRUD operations for the **WorkflowStepExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowStepExecutions
    * const workflowStepExecutions = await prisma.workflowStepExecution.findMany()
    * ```
    */
  get workflowStepExecution(): Prisma.WorkflowStepExecutionDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.documentVersion`: Exposes CRUD operations for the **DocumentVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentVersions
    * const documentVersions = await prisma.documentVersion.findMany()
    * ```
    */
  get documentVersion(): Prisma.DocumentVersionDelegate<ExtArgs>;

  /**
   * `prisma.documentTag`: Exposes CRUD operations for the **DocumentTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTags
    * const documentTags = await prisma.documentTag.findMany()
    * ```
    */
  get documentTag(): Prisma.DocumentTagDelegate<ExtArgs>;

  /**
   * `prisma.documentReadConfirmation`: Exposes CRUD operations for the **DocumentReadConfirmation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentReadConfirmations
    * const documentReadConfirmations = await prisma.documentReadConfirmation.findMany()
    * ```
    */
  get documentReadConfirmation(): Prisma.DocumentReadConfirmationDelegate<ExtArgs>;

  /**
   * `prisma.reportTemplate`: Exposes CRUD operations for the **ReportTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportTemplates
    * const reportTemplates = await prisma.reportTemplate.findMany()
    * ```
    */
  get reportTemplate(): Prisma.ReportTemplateDelegate<ExtArgs>;

  /**
   * `prisma.reportComponent`: Exposes CRUD operations for the **ReportComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportComponents
    * const reportComponents = await prisma.reportComponent.findMany()
    * ```
    */
  get reportComponent(): Prisma.ReportComponentDelegate<ExtArgs>;

  /**
   * `prisma.scheduledReport`: Exposes CRUD operations for the **ScheduledReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledReports
    * const scheduledReports = await prisma.scheduledReport.findMany()
    * ```
    */
  get scheduledReport(): Prisma.ScheduledReportDelegate<ExtArgs>;

  /**
   * `prisma.reportExecution`: Exposes CRUD operations for the **ReportExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportExecutions
    * const reportExecutions = await prisma.reportExecution.findMany()
    * ```
    */
  get reportExecution(): Prisma.ReportExecutionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Notification: 'Notification',
    InternalAudit: 'InternalAudit',
    ExternalAudit: 'ExternalAudit',
    AuditProgram: 'AuditProgram',
    AuditChecklist: 'AuditChecklist',
    ActionItem: 'ActionItem',
    RootCauseAnalysis: 'RootCauseAnalysis',
    Occurrence: 'Occurrence',
    Sector: 'Sector',
    ImportLog: 'ImportLog',
    AuditTrail: 'AuditTrail',
    Attachment: 'Attachment',
    Comment: 'Comment',
    Approval: 'Approval',
    WorkflowDefinition: 'WorkflowDefinition',
    WorkflowStep: 'WorkflowStep',
    WorkflowInstance: 'WorkflowInstance',
    WorkflowStepExecution: 'WorkflowStepExecution',
    Session: 'Session',
    Document: 'Document',
    DocumentVersion: 'DocumentVersion',
    DocumentTag: 'DocumentTag',
    DocumentReadConfirmation: 'DocumentReadConfirmation',
    ReportTemplate: 'ReportTemplate',
    ReportComponent: 'ReportComponent',
    ScheduledReport: 'ScheduledReport',
    ReportExecution: 'ReportExecution'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "notification" | "internalAudit" | "externalAudit" | "auditProgram" | "auditChecklist" | "actionItem" | "rootCauseAnalysis" | "occurrence" | "sector" | "importLog" | "auditTrail" | "attachment" | "comment" | "approval" | "workflowDefinition" | "workflowStep" | "workflowInstance" | "workflowStepExecution" | "session" | "document" | "documentVersion" | "documentTag" | "documentReadConfirmation" | "reportTemplate" | "reportComponent" | "scheduledReport" | "reportExecution"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      InternalAudit: {
        payload: Prisma.$InternalAuditPayload<ExtArgs>
        fields: Prisma.InternalAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternalAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternalAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>
          }
          findFirst: {
            args: Prisma.InternalAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternalAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>
          }
          findMany: {
            args: Prisma.InternalAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>[]
          }
          create: {
            args: Prisma.InternalAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>
          }
          createMany: {
            args: Prisma.InternalAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InternalAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>[]
          }
          delete: {
            args: Prisma.InternalAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>
          }
          update: {
            args: Prisma.InternalAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>
          }
          deleteMany: {
            args: Prisma.InternalAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternalAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InternalAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalAuditPayload>
          }
          aggregate: {
            args: Prisma.InternalAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternalAudit>
          }
          groupBy: {
            args: Prisma.InternalAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternalAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternalAuditCountArgs<ExtArgs>
            result: $Utils.Optional<InternalAuditCountAggregateOutputType> | number
          }
        }
      }
      ExternalAudit: {
        payload: Prisma.$ExternalAuditPayload<ExtArgs>
        fields: Prisma.ExternalAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>
          }
          findFirst: {
            args: Prisma.ExternalAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>
          }
          findMany: {
            args: Prisma.ExternalAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>[]
          }
          create: {
            args: Prisma.ExternalAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>
          }
          createMany: {
            args: Prisma.ExternalAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>[]
          }
          delete: {
            args: Prisma.ExternalAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>
          }
          update: {
            args: Prisma.ExternalAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>
          }
          deleteMany: {
            args: Prisma.ExternalAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExternalAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAuditPayload>
          }
          aggregate: {
            args: Prisma.ExternalAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalAudit>
          }
          groupBy: {
            args: Prisma.ExternalAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalAuditCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalAuditCountAggregateOutputType> | number
          }
        }
      }
      AuditProgram: {
        payload: Prisma.$AuditProgramPayload<ExtArgs>
        fields: Prisma.AuditProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>
          }
          findFirst: {
            args: Prisma.AuditProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>
          }
          findMany: {
            args: Prisma.AuditProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>[]
          }
          create: {
            args: Prisma.AuditProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>
          }
          createMany: {
            args: Prisma.AuditProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>[]
          }
          delete: {
            args: Prisma.AuditProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>
          }
          update: {
            args: Prisma.AuditProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>
          }
          deleteMany: {
            args: Prisma.AuditProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditProgramPayload>
          }
          aggregate: {
            args: Prisma.AuditProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditProgram>
          }
          groupBy: {
            args: Prisma.AuditProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditProgramCountArgs<ExtArgs>
            result: $Utils.Optional<AuditProgramCountAggregateOutputType> | number
          }
        }
      }
      AuditChecklist: {
        payload: Prisma.$AuditChecklistPayload<ExtArgs>
        fields: Prisma.AuditChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>
          }
          findFirst: {
            args: Prisma.AuditChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>
          }
          findMany: {
            args: Prisma.AuditChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>[]
          }
          create: {
            args: Prisma.AuditChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>
          }
          createMany: {
            args: Prisma.AuditChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>[]
          }
          delete: {
            args: Prisma.AuditChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>
          }
          update: {
            args: Prisma.AuditChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>
          }
          deleteMany: {
            args: Prisma.AuditChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditChecklistPayload>
          }
          aggregate: {
            args: Prisma.AuditChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditChecklist>
          }
          groupBy: {
            args: Prisma.AuditChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<AuditChecklistCountAggregateOutputType> | number
          }
        }
      }
      ActionItem: {
        payload: Prisma.$ActionItemPayload<ExtArgs>
        fields: Prisma.ActionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          findFirst: {
            args: Prisma.ActionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          findMany: {
            args: Prisma.ActionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          create: {
            args: Prisma.ActionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          createMany: {
            args: Prisma.ActionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          delete: {
            args: Prisma.ActionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          update: {
            args: Prisma.ActionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          deleteMany: {
            args: Prisma.ActionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          aggregate: {
            args: Prisma.ActionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionItem>
          }
          groupBy: {
            args: Prisma.ActionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionItemCountArgs<ExtArgs>
            result: $Utils.Optional<ActionItemCountAggregateOutputType> | number
          }
        }
      }
      RootCauseAnalysis: {
        payload: Prisma.$RootCauseAnalysisPayload<ExtArgs>
        fields: Prisma.RootCauseAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RootCauseAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RootCauseAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>
          }
          findFirst: {
            args: Prisma.RootCauseAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RootCauseAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>
          }
          findMany: {
            args: Prisma.RootCauseAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>[]
          }
          create: {
            args: Prisma.RootCauseAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>
          }
          createMany: {
            args: Prisma.RootCauseAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RootCauseAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>[]
          }
          delete: {
            args: Prisma.RootCauseAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>
          }
          update: {
            args: Prisma.RootCauseAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.RootCauseAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RootCauseAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RootCauseAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RootCauseAnalysisPayload>
          }
          aggregate: {
            args: Prisma.RootCauseAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRootCauseAnalysis>
          }
          groupBy: {
            args: Prisma.RootCauseAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<RootCauseAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.RootCauseAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<RootCauseAnalysisCountAggregateOutputType> | number
          }
        }
      }
      Occurrence: {
        payload: Prisma.$OccurrencePayload<ExtArgs>
        fields: Prisma.OccurrenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OccurrenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OccurrenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          findFirst: {
            args: Prisma.OccurrenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OccurrenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          findMany: {
            args: Prisma.OccurrenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>[]
          }
          create: {
            args: Prisma.OccurrenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          createMany: {
            args: Prisma.OccurrenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OccurrenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>[]
          }
          delete: {
            args: Prisma.OccurrenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          update: {
            args: Prisma.OccurrenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          deleteMany: {
            args: Prisma.OccurrenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OccurrenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OccurrenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          aggregate: {
            args: Prisma.OccurrenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOccurrence>
          }
          groupBy: {
            args: Prisma.OccurrenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OccurrenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OccurrenceCountArgs<ExtArgs>
            result: $Utils.Optional<OccurrenceCountAggregateOutputType> | number
          }
        }
      }
      Sector: {
        payload: Prisma.$SectorPayload<ExtArgs>
        fields: Prisma.SectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          findFirst: {
            args: Prisma.SectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          findMany: {
            args: Prisma.SectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>[]
          }
          create: {
            args: Prisma.SectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          createMany: {
            args: Prisma.SectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>[]
          }
          delete: {
            args: Prisma.SectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          update: {
            args: Prisma.SectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          deleteMany: {
            args: Prisma.SectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectorPayload>
          }
          aggregate: {
            args: Prisma.SectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSector>
          }
          groupBy: {
            args: Prisma.SectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectorCountArgs<ExtArgs>
            result: $Utils.Optional<SectorCountAggregateOutputType> | number
          }
        }
      }
      ImportLog: {
        payload: Prisma.$ImportLogPayload<ExtArgs>
        fields: Prisma.ImportLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          findFirst: {
            args: Prisma.ImportLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          findMany: {
            args: Prisma.ImportLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>[]
          }
          create: {
            args: Prisma.ImportLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          createMany: {
            args: Prisma.ImportLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>[]
          }
          delete: {
            args: Prisma.ImportLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          update: {
            args: Prisma.ImportLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          deleteMany: {
            args: Prisma.ImportLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportLogPayload>
          }
          aggregate: {
            args: Prisma.ImportLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportLog>
          }
          groupBy: {
            args: Prisma.ImportLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportLogCountArgs<ExtArgs>
            result: $Utils.Optional<ImportLogCountAggregateOutputType> | number
          }
        }
      }
      AuditTrail: {
        payload: Prisma.$AuditTrailPayload<ExtArgs>
        fields: Prisma.AuditTrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditTrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditTrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findFirst: {
            args: Prisma.AuditTrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditTrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findMany: {
            args: Prisma.AuditTrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          create: {
            args: Prisma.AuditTrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          createMany: {
            args: Prisma.AuditTrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditTrailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          delete: {
            args: Prisma.AuditTrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          update: {
            args: Prisma.AuditTrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          deleteMany: {
            args: Prisma.AuditTrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditTrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditTrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          aggregate: {
            args: Prisma.AuditTrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditTrail>
          }
          groupBy: {
            args: Prisma.AuditTrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditTrailCountArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Approval: {
        payload: Prisma.$ApprovalPayload<ExtArgs>
        fields: Prisma.ApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findFirst: {
            args: Prisma.ApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findMany: {
            args: Prisma.ApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          create: {
            args: Prisma.ApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          createMany: {
            args: Prisma.ApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          delete: {
            args: Prisma.ApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          update: {
            args: Prisma.ApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          aggregate: {
            args: Prisma.ApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApproval>
          }
          groupBy: {
            args: Prisma.ApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalCountAggregateOutputType> | number
          }
        }
      }
      WorkflowDefinition: {
        payload: Prisma.$WorkflowDefinitionPayload<ExtArgs>
        fields: Prisma.WorkflowDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          findFirst: {
            args: Prisma.WorkflowDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          findMany: {
            args: Prisma.WorkflowDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>[]
          }
          create: {
            args: Prisma.WorkflowDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          createMany: {
            args: Prisma.WorkflowDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          update: {
            args: Prisma.WorkflowDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowDefinitionPayload>
          }
          aggregate: {
            args: Prisma.WorkflowDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowDefinition>
          }
          groupBy: {
            args: Prisma.WorkflowDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowDefinitionCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStep: {
        payload: Prisma.$WorkflowStepPayload<ExtArgs>
        fields: Prisma.WorkflowStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          delete: {
            args: Prisma.WorkflowStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          update: {
            args: Prisma.WorkflowStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStep>
          }
          groupBy: {
            args: Prisma.WorkflowStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepCountAggregateOutputType> | number
          }
        }
      }
      WorkflowInstance: {
        payload: Prisma.$WorkflowInstancePayload<ExtArgs>
        fields: Prisma.WorkflowInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          findFirst: {
            args: Prisma.WorkflowInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          findMany: {
            args: Prisma.WorkflowInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>[]
          }
          create: {
            args: Prisma.WorkflowInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          createMany: {
            args: Prisma.WorkflowInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>[]
          }
          delete: {
            args: Prisma.WorkflowInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          update: {
            args: Prisma.WorkflowInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowInstancePayload>
          }
          aggregate: {
            args: Prisma.WorkflowInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowInstance>
          }
          groupBy: {
            args: Prisma.WorkflowInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowInstanceCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStepExecution: {
        payload: Prisma.$WorkflowStepExecutionPayload<ExtArgs>
        fields: Prisma.WorkflowStepExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowStepExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>[]
          }
          delete: {
            args: Prisma.WorkflowStepExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          update: {
            args: Prisma.WorkflowStepExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowStepExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepExecutionPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStepExecution>
          }
          groupBy: {
            args: Prisma.WorkflowStepExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepExecutionCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentVersion: {
        payload: Prisma.$DocumentVersionPayload<ExtArgs>
        fields: Prisma.DocumentVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          findFirst: {
            args: Prisma.DocumentVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          findMany: {
            args: Prisma.DocumentVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>[]
          }
          create: {
            args: Prisma.DocumentVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          createMany: {
            args: Prisma.DocumentVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>[]
          }
          delete: {
            args: Prisma.DocumentVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          update: {
            args: Prisma.DocumentVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          deleteMany: {
            args: Prisma.DocumentVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          aggregate: {
            args: Prisma.DocumentVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentVersion>
          }
          groupBy: {
            args: Prisma.DocumentVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentVersionCountAggregateOutputType> | number
          }
        }
      }
      DocumentTag: {
        payload: Prisma.$DocumentTagPayload<ExtArgs>
        fields: Prisma.DocumentTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          findFirst: {
            args: Prisma.DocumentTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          findMany: {
            args: Prisma.DocumentTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          create: {
            args: Prisma.DocumentTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          createMany: {
            args: Prisma.DocumentTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          delete: {
            args: Prisma.DocumentTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          update: {
            args: Prisma.DocumentTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          deleteMany: {
            args: Prisma.DocumentTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          aggregate: {
            args: Prisma.DocumentTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentTag>
          }
          groupBy: {
            args: Prisma.DocumentTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentTagCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentTagCountAggregateOutputType> | number
          }
        }
      }
      DocumentReadConfirmation: {
        payload: Prisma.$DocumentReadConfirmationPayload<ExtArgs>
        fields: Prisma.DocumentReadConfirmationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentReadConfirmationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentReadConfirmationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>
          }
          findFirst: {
            args: Prisma.DocumentReadConfirmationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentReadConfirmationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>
          }
          findMany: {
            args: Prisma.DocumentReadConfirmationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>[]
          }
          create: {
            args: Prisma.DocumentReadConfirmationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>
          }
          createMany: {
            args: Prisma.DocumentReadConfirmationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentReadConfirmationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>[]
          }
          delete: {
            args: Prisma.DocumentReadConfirmationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>
          }
          update: {
            args: Prisma.DocumentReadConfirmationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>
          }
          deleteMany: {
            args: Prisma.DocumentReadConfirmationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentReadConfirmationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentReadConfirmationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentReadConfirmationPayload>
          }
          aggregate: {
            args: Prisma.DocumentReadConfirmationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentReadConfirmation>
          }
          groupBy: {
            args: Prisma.DocumentReadConfirmationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentReadConfirmationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentReadConfirmationCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentReadConfirmationCountAggregateOutputType> | number
          }
        }
      }
      ReportTemplate: {
        payload: Prisma.$ReportTemplatePayload<ExtArgs>
        fields: Prisma.ReportTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findFirst: {
            args: Prisma.ReportTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findMany: {
            args: Prisma.ReportTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          create: {
            args: Prisma.ReportTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          createMany: {
            args: Prisma.ReportTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          delete: {
            args: Prisma.ReportTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          update: {
            args: Prisma.ReportTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ReportTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          aggregate: {
            args: Prisma.ReportTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportTemplate>
          }
          groupBy: {
            args: Prisma.ReportTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateCountAggregateOutputType> | number
          }
        }
      }
      ReportComponent: {
        payload: Prisma.$ReportComponentPayload<ExtArgs>
        fields: Prisma.ReportComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>
          }
          findFirst: {
            args: Prisma.ReportComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>
          }
          findMany: {
            args: Prisma.ReportComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>[]
          }
          create: {
            args: Prisma.ReportComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>
          }
          createMany: {
            args: Prisma.ReportComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>[]
          }
          delete: {
            args: Prisma.ReportComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>
          }
          update: {
            args: Prisma.ReportComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>
          }
          deleteMany: {
            args: Prisma.ReportComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportComponentPayload>
          }
          aggregate: {
            args: Prisma.ReportComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportComponent>
          }
          groupBy: {
            args: Prisma.ReportComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ReportComponentCountAggregateOutputType> | number
          }
        }
      }
      ScheduledReport: {
        payload: Prisma.$ScheduledReportPayload<ExtArgs>
        fields: Prisma.ScheduledReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          findFirst: {
            args: Prisma.ScheduledReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          findMany: {
            args: Prisma.ScheduledReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          create: {
            args: Prisma.ScheduledReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          createMany: {
            args: Prisma.ScheduledReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>[]
          }
          delete: {
            args: Prisma.ScheduledReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          update: {
            args: Prisma.ScheduledReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReportPayload>
          }
          aggregate: {
            args: Prisma.ScheduledReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledReport>
          }
          groupBy: {
            args: Prisma.ScheduledReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledReportCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReportCountAggregateOutputType> | number
          }
        }
      }
      ReportExecution: {
        payload: Prisma.$ReportExecutionPayload<ExtArgs>
        fields: Prisma.ReportExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>
          }
          findFirst: {
            args: Prisma.ReportExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>
          }
          findMany: {
            args: Prisma.ReportExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>[]
          }
          create: {
            args: Prisma.ReportExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>
          }
          createMany: {
            args: Prisma.ReportExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>[]
          }
          delete: {
            args: Prisma.ReportExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>
          }
          update: {
            args: Prisma.ReportExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>
          }
          deleteMany: {
            args: Prisma.ReportExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportExecutionPayload>
          }
          aggregate: {
            args: Prisma.ReportExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportExecution>
          }
          groupBy: {
            args: Prisma.ReportExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<ReportExecutionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    internalAudits: number
    externalAudits: number
    actionItems: number
    rootCauseAnalyses: number
    occurrences: number
    sectors: number
    importLogs: number
    auditTrails: number
    auditPrograms: number
    attachments: number
    comments: number
    approvals: number
    workflowDefinitions: number
    workflowInstances: number
    documents: number
    documentVersions: number
    documentTags: number
    documentReadConfirmations: number
    reportTemplates: number
    scheduledReports: number
    notifications: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    internalAudits?: boolean | TenantCountOutputTypeCountInternalAuditsArgs
    externalAudits?: boolean | TenantCountOutputTypeCountExternalAuditsArgs
    actionItems?: boolean | TenantCountOutputTypeCountActionItemsArgs
    rootCauseAnalyses?: boolean | TenantCountOutputTypeCountRootCauseAnalysesArgs
    occurrences?: boolean | TenantCountOutputTypeCountOccurrencesArgs
    sectors?: boolean | TenantCountOutputTypeCountSectorsArgs
    importLogs?: boolean | TenantCountOutputTypeCountImportLogsArgs
    auditTrails?: boolean | TenantCountOutputTypeCountAuditTrailsArgs
    auditPrograms?: boolean | TenantCountOutputTypeCountAuditProgramsArgs
    attachments?: boolean | TenantCountOutputTypeCountAttachmentsArgs
    comments?: boolean | TenantCountOutputTypeCountCommentsArgs
    approvals?: boolean | TenantCountOutputTypeCountApprovalsArgs
    workflowDefinitions?: boolean | TenantCountOutputTypeCountWorkflowDefinitionsArgs
    workflowInstances?: boolean | TenantCountOutputTypeCountWorkflowInstancesArgs
    documents?: boolean | TenantCountOutputTypeCountDocumentsArgs
    documentVersions?: boolean | TenantCountOutputTypeCountDocumentVersionsArgs
    documentTags?: boolean | TenantCountOutputTypeCountDocumentTagsArgs
    documentReadConfirmations?: boolean | TenantCountOutputTypeCountDocumentReadConfirmationsArgs
    reportTemplates?: boolean | TenantCountOutputTypeCountReportTemplatesArgs
    scheduledReports?: boolean | TenantCountOutputTypeCountScheduledReportsArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInternalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalAuditWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountExternalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalAuditWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountActionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRootCauseAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RootCauseAnalysisWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccurrenceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountImportLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditProgramWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWorkflowDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWorkflowInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDocumentReadConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentReadConfirmationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountReportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditTrails: number
    attachments: number
    comments: number
    approvalRequests: number
    approvalApprovals: number
    workflowInstances: number
    workflowCancelled: number
    workflowStepExecutions: number
    sessions: number
    createdDocuments: number
    updatedDocumentVersions: number
    createdReportTemplates: number
    createdScheduledReports: number
    documentReadConfirmations: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditTrails?: boolean | UserCountOutputTypeCountAuditTrailsArgs
    attachments?: boolean | UserCountOutputTypeCountAttachmentsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    approvalRequests?: boolean | UserCountOutputTypeCountApprovalRequestsArgs
    approvalApprovals?: boolean | UserCountOutputTypeCountApprovalApprovalsArgs
    workflowInstances?: boolean | UserCountOutputTypeCountWorkflowInstancesArgs
    workflowCancelled?: boolean | UserCountOutputTypeCountWorkflowCancelledArgs
    workflowStepExecutions?: boolean | UserCountOutputTypeCountWorkflowStepExecutionsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    createdDocuments?: boolean | UserCountOutputTypeCountCreatedDocumentsArgs
    updatedDocumentVersions?: boolean | UserCountOutputTypeCountUpdatedDocumentVersionsArgs
    createdReportTemplates?: boolean | UserCountOutputTypeCountCreatedReportTemplatesArgs
    createdScheduledReports?: boolean | UserCountOutputTypeCountCreatedScheduledReportsArgs
    documentReadConfirmations?: boolean | UserCountOutputTypeCountDocumentReadConfirmationsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowCancelledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowStepExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedDocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedReportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentReadConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentReadConfirmationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AuditProgramCountOutputType
   */

  export type AuditProgramCountOutputType = {
    derivatives: number
    checklists: number
    internalAudits: number
    externalAudits: number
  }

  export type AuditProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    derivatives?: boolean | AuditProgramCountOutputTypeCountDerivativesArgs
    checklists?: boolean | AuditProgramCountOutputTypeCountChecklistsArgs
    internalAudits?: boolean | AuditProgramCountOutputTypeCountInternalAuditsArgs
    externalAudits?: boolean | AuditProgramCountOutputTypeCountExternalAuditsArgs
  }

  // Custom InputTypes
  /**
   * AuditProgramCountOutputType without action
   */
  export type AuditProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgramCountOutputType
     */
    select?: AuditProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditProgramCountOutputType without action
   */
  export type AuditProgramCountOutputTypeCountDerivativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditProgramWhereInput
  }

  /**
   * AuditProgramCountOutputType without action
   */
  export type AuditProgramCountOutputTypeCountChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditChecklistWhereInput
  }

  /**
   * AuditProgramCountOutputType without action
   */
  export type AuditProgramCountOutputTypeCountInternalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalAuditWhereInput
  }

  /**
   * AuditProgramCountOutputType without action
   */
  export type AuditProgramCountOutputTypeCountExternalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalAuditWhereInput
  }


  /**
   * Count Type WorkflowDefinitionCountOutputType
   */

  export type WorkflowDefinitionCountOutputType = {
    steps: number
    instances: number
  }

  export type WorkflowDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | WorkflowDefinitionCountOutputTypeCountStepsArgs
    instances?: boolean | WorkflowDefinitionCountOutputTypeCountInstancesArgs
  }

  // Custom InputTypes
  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinitionCountOutputType
     */
    select?: WorkflowDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowDefinitionCountOutputType without action
   */
  export type WorkflowDefinitionCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
  }


  /**
   * Count Type WorkflowInstanceCountOutputType
   */

  export type WorkflowInstanceCountOutputType = {
    stepExecutions: number
    documents: number
  }

  export type WorkflowInstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stepExecutions?: boolean | WorkflowInstanceCountOutputTypeCountStepExecutionsArgs
    documents?: boolean | WorkflowInstanceCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * WorkflowInstanceCountOutputType without action
   */
  export type WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstanceCountOutputType
     */
    select?: WorkflowInstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowInstanceCountOutputType without action
   */
  export type WorkflowInstanceCountOutputTypeCountStepExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowInstanceCountOutputType without action
   */
  export type WorkflowInstanceCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    versions: number
    tags: number
    readConfirmations: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | DocumentCountOutputTypeCountVersionsArgs
    tags?: boolean | DocumentCountOutputTypeCountTagsArgs
    readConfirmations?: boolean | DocumentCountOutputTypeCountReadConfirmationsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountReadConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentReadConfirmationWhereInput
  }


  /**
   * Count Type ReportTemplateCountOutputType
   */

  export type ReportTemplateCountOutputType = {
    components: number
    instances: number
  }

  export type ReportTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    components?: boolean | ReportTemplateCountOutputTypeCountComponentsArgs
    instances?: boolean | ReportTemplateCountOutputTypeCountInstancesArgs
  }

  // Custom InputTypes
  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplateCountOutputType
     */
    select?: ReportTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportComponentWhereInput
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
  }


  /**
   * Count Type ScheduledReportCountOutputType
   */

  export type ScheduledReportCountOutputType = {
    executions: number
  }

  export type ScheduledReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | ScheduledReportCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * ScheduledReportCountOutputType without action
   */
  export type ScheduledReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReportCountOutputType
     */
    select?: ScheduledReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduledReportCountOutputType without action
   */
  export type ScheduledReportCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportExecutionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    internalAudits?: boolean | Tenant$internalAuditsArgs<ExtArgs>
    externalAudits?: boolean | Tenant$externalAuditsArgs<ExtArgs>
    actionItems?: boolean | Tenant$actionItemsArgs<ExtArgs>
    rootCauseAnalyses?: boolean | Tenant$rootCauseAnalysesArgs<ExtArgs>
    occurrences?: boolean | Tenant$occurrencesArgs<ExtArgs>
    sectors?: boolean | Tenant$sectorsArgs<ExtArgs>
    importLogs?: boolean | Tenant$importLogsArgs<ExtArgs>
    auditTrails?: boolean | Tenant$auditTrailsArgs<ExtArgs>
    auditPrograms?: boolean | Tenant$auditProgramsArgs<ExtArgs>
    attachments?: boolean | Tenant$attachmentsArgs<ExtArgs>
    comments?: boolean | Tenant$commentsArgs<ExtArgs>
    approvals?: boolean | Tenant$approvalsArgs<ExtArgs>
    workflowDefinitions?: boolean | Tenant$workflowDefinitionsArgs<ExtArgs>
    workflowInstances?: boolean | Tenant$workflowInstancesArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    documentVersions?: boolean | Tenant$documentVersionsArgs<ExtArgs>
    documentTags?: boolean | Tenant$documentTagsArgs<ExtArgs>
    documentReadConfirmations?: boolean | Tenant$documentReadConfirmationsArgs<ExtArgs>
    reportTemplates?: boolean | Tenant$reportTemplatesArgs<ExtArgs>
    scheduledReports?: boolean | Tenant$scheduledReportsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    internalAudits?: boolean | Tenant$internalAuditsArgs<ExtArgs>
    externalAudits?: boolean | Tenant$externalAuditsArgs<ExtArgs>
    actionItems?: boolean | Tenant$actionItemsArgs<ExtArgs>
    rootCauseAnalyses?: boolean | Tenant$rootCauseAnalysesArgs<ExtArgs>
    occurrences?: boolean | Tenant$occurrencesArgs<ExtArgs>
    sectors?: boolean | Tenant$sectorsArgs<ExtArgs>
    importLogs?: boolean | Tenant$importLogsArgs<ExtArgs>
    auditTrails?: boolean | Tenant$auditTrailsArgs<ExtArgs>
    auditPrograms?: boolean | Tenant$auditProgramsArgs<ExtArgs>
    attachments?: boolean | Tenant$attachmentsArgs<ExtArgs>
    comments?: boolean | Tenant$commentsArgs<ExtArgs>
    approvals?: boolean | Tenant$approvalsArgs<ExtArgs>
    workflowDefinitions?: boolean | Tenant$workflowDefinitionsArgs<ExtArgs>
    workflowInstances?: boolean | Tenant$workflowInstancesArgs<ExtArgs>
    documents?: boolean | Tenant$documentsArgs<ExtArgs>
    documentVersions?: boolean | Tenant$documentVersionsArgs<ExtArgs>
    documentTags?: boolean | Tenant$documentTagsArgs<ExtArgs>
    documentReadConfirmations?: boolean | Tenant$documentReadConfirmationsArgs<ExtArgs>
    reportTemplates?: boolean | Tenant$reportTemplatesArgs<ExtArgs>
    scheduledReports?: boolean | Tenant$scheduledReportsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      internalAudits: Prisma.$InternalAuditPayload<ExtArgs>[]
      externalAudits: Prisma.$ExternalAuditPayload<ExtArgs>[]
      actionItems: Prisma.$ActionItemPayload<ExtArgs>[]
      rootCauseAnalyses: Prisma.$RootCauseAnalysisPayload<ExtArgs>[]
      occurrences: Prisma.$OccurrencePayload<ExtArgs>[]
      sectors: Prisma.$SectorPayload<ExtArgs>[]
      importLogs: Prisma.$ImportLogPayload<ExtArgs>[]
      auditTrails: Prisma.$AuditTrailPayload<ExtArgs>[]
      auditPrograms: Prisma.$AuditProgramPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
      workflowDefinitions: Prisma.$WorkflowDefinitionPayload<ExtArgs>[]
      workflowInstances: Prisma.$WorkflowInstancePayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      documentVersions: Prisma.$DocumentVersionPayload<ExtArgs>[]
      documentTags: Prisma.$DocumentTagPayload<ExtArgs>[]
      documentReadConfirmations: Prisma.$DocumentReadConfirmationPayload<ExtArgs>[]
      reportTemplates: Prisma.$ReportTemplatePayload<ExtArgs>[]
      scheduledReports: Prisma.$ScheduledReportPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    internalAudits<T extends Tenant$internalAuditsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$internalAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findMany"> | Null>
    externalAudits<T extends Tenant$externalAuditsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$externalAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findMany"> | Null>
    actionItems<T extends Tenant$actionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$actionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany"> | Null>
    rootCauseAnalyses<T extends Tenant$rootCauseAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$rootCauseAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    occurrences<T extends Tenant$occurrencesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$occurrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "findMany"> | Null>
    sectors<T extends Tenant$sectorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$sectorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findMany"> | Null>
    importLogs<T extends Tenant$importLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$importLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findMany"> | Null>
    auditTrails<T extends Tenant$auditTrailsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditTrailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany"> | Null>
    auditPrograms<T extends Tenant$auditProgramsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends Tenant$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Tenant$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends Tenant$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    workflowDefinitions<T extends Tenant$workflowDefinitionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$workflowDefinitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findMany"> | Null>
    workflowInstances<T extends Tenant$workflowInstancesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$workflowInstancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Tenant$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    documentVersions<T extends Tenant$documentVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany"> | Null>
    documentTags<T extends Tenant$documentTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany"> | Null>
    documentReadConfirmations<T extends Tenant$documentReadConfirmationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$documentReadConfirmationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findMany"> | Null>
    reportTemplates<T extends Tenant$reportTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$reportTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    scheduledReports<T extends Tenant$scheduledReportsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$scheduledReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.internalAudits
   */
  export type Tenant$internalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    where?: InternalAuditWhereInput
    orderBy?: InternalAuditOrderByWithRelationInput | InternalAuditOrderByWithRelationInput[]
    cursor?: InternalAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternalAuditScalarFieldEnum | InternalAuditScalarFieldEnum[]
  }

  /**
   * Tenant.externalAudits
   */
  export type Tenant$externalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    where?: ExternalAuditWhereInput
    orderBy?: ExternalAuditOrderByWithRelationInput | ExternalAuditOrderByWithRelationInput[]
    cursor?: ExternalAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalAuditScalarFieldEnum | ExternalAuditScalarFieldEnum[]
  }

  /**
   * Tenant.actionItems
   */
  export type Tenant$actionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    cursor?: ActionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * Tenant.rootCauseAnalyses
   */
  export type Tenant$rootCauseAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    where?: RootCauseAnalysisWhereInput
    orderBy?: RootCauseAnalysisOrderByWithRelationInput | RootCauseAnalysisOrderByWithRelationInput[]
    cursor?: RootCauseAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RootCauseAnalysisScalarFieldEnum | RootCauseAnalysisScalarFieldEnum[]
  }

  /**
   * Tenant.occurrences
   */
  export type Tenant$occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    where?: OccurrenceWhereInput
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    cursor?: OccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Tenant.sectors
   */
  export type Tenant$sectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    where?: SectorWhereInput
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    cursor?: SectorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Tenant.importLogs
   */
  export type Tenant$importLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    where?: ImportLogWhereInput
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    cursor?: ImportLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * Tenant.auditTrails
   */
  export type Tenant$auditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    cursor?: AuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * Tenant.auditPrograms
   */
  export type Tenant$auditProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    where?: AuditProgramWhereInput
    orderBy?: AuditProgramOrderByWithRelationInput | AuditProgramOrderByWithRelationInput[]
    cursor?: AuditProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditProgramScalarFieldEnum | AuditProgramScalarFieldEnum[]
  }

  /**
   * Tenant.attachments
   */
  export type Tenant$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Tenant.comments
   */
  export type Tenant$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Tenant.approvals
   */
  export type Tenant$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Tenant.workflowDefinitions
   */
  export type Tenant$workflowDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    where?: WorkflowDefinitionWhereInput
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    cursor?: WorkflowDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * Tenant.workflowInstances
   */
  export type Tenant$workflowInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * Tenant.documents
   */
  export type Tenant$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Tenant.documentVersions
   */
  export type Tenant$documentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    cursor?: DocumentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * Tenant.documentTags
   */
  export type Tenant$documentTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    cursor?: DocumentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * Tenant.documentReadConfirmations
   */
  export type Tenant$documentReadConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    where?: DocumentReadConfirmationWhereInput
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    cursor?: DocumentReadConfirmationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentReadConfirmationScalarFieldEnum | DocumentReadConfirmationScalarFieldEnum[]
  }

  /**
   * Tenant.reportTemplates
   */
  export type Tenant$reportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    cursor?: ReportTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.scheduledReports
   */
  export type Tenant$scheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditTrails?: boolean | User$auditTrailsArgs<ExtArgs>
    attachments?: boolean | User$attachmentsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    approvalRequests?: boolean | User$approvalRequestsArgs<ExtArgs>
    approvalApprovals?: boolean | User$approvalApprovalsArgs<ExtArgs>
    workflowInstances?: boolean | User$workflowInstancesArgs<ExtArgs>
    workflowCancelled?: boolean | User$workflowCancelledArgs<ExtArgs>
    workflowStepExecutions?: boolean | User$workflowStepExecutionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    createdDocuments?: boolean | User$createdDocumentsArgs<ExtArgs>
    updatedDocumentVersions?: boolean | User$updatedDocumentVersionsArgs<ExtArgs>
    createdReportTemplates?: boolean | User$createdReportTemplatesArgs<ExtArgs>
    createdScheduledReports?: boolean | User$createdScheduledReportsArgs<ExtArgs>
    documentReadConfirmations?: boolean | User$documentReadConfirmationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditTrails?: boolean | User$auditTrailsArgs<ExtArgs>
    attachments?: boolean | User$attachmentsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    approvalRequests?: boolean | User$approvalRequestsArgs<ExtArgs>
    approvalApprovals?: boolean | User$approvalApprovalsArgs<ExtArgs>
    workflowInstances?: boolean | User$workflowInstancesArgs<ExtArgs>
    workflowCancelled?: boolean | User$workflowCancelledArgs<ExtArgs>
    workflowStepExecutions?: boolean | User$workflowStepExecutionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    createdDocuments?: boolean | User$createdDocumentsArgs<ExtArgs>
    updatedDocumentVersions?: boolean | User$updatedDocumentVersionsArgs<ExtArgs>
    createdReportTemplates?: boolean | User$createdReportTemplatesArgs<ExtArgs>
    createdScheduledReports?: boolean | User$createdScheduledReportsArgs<ExtArgs>
    documentReadConfirmations?: boolean | User$documentReadConfirmationsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      auditTrails: Prisma.$AuditTrailPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      approvalRequests: Prisma.$ApprovalPayload<ExtArgs>[]
      approvalApprovals: Prisma.$ApprovalPayload<ExtArgs>[]
      workflowInstances: Prisma.$WorkflowInstancePayload<ExtArgs>[]
      workflowCancelled: Prisma.$WorkflowInstancePayload<ExtArgs>[]
      workflowStepExecutions: Prisma.$WorkflowStepExecutionPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      createdDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      updatedDocumentVersions: Prisma.$DocumentVersionPayload<ExtArgs>[]
      createdReportTemplates: Prisma.$ReportTemplatePayload<ExtArgs>[]
      createdScheduledReports: Prisma.$ScheduledReportPayload<ExtArgs>[]
      documentReadConfirmations: Prisma.$DocumentReadConfirmationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string
      passwordHash: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    auditTrails<T extends User$auditTrailsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditTrailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends User$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    approvalRequests<T extends User$approvalRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    approvalApprovals<T extends User$approvalApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    workflowInstances<T extends User$workflowInstancesArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowInstancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    workflowCancelled<T extends User$workflowCancelledArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowCancelledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    workflowStepExecutions<T extends User$workflowStepExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowStepExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    createdDocuments<T extends User$createdDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    updatedDocumentVersions<T extends User$updatedDocumentVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedDocumentVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany"> | Null>
    createdReportTemplates<T extends User$createdReportTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdReportTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    createdScheduledReports<T extends User$createdScheduledReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdScheduledReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany"> | Null>
    documentReadConfirmations<T extends User$documentReadConfirmationsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentReadConfirmationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.auditTrails
   */
  export type User$auditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    cursor?: AuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * User.attachments
   */
  export type User$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.approvalRequests
   */
  export type User$approvalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * User.approvalApprovals
   */
  export type User$approvalApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * User.workflowInstances
   */
  export type User$workflowInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * User.workflowCancelled
   */
  export type User$workflowCancelledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * User.workflowStepExecutions
   */
  export type User$workflowStepExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    cursor?: WorkflowStepExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.createdDocuments
   */
  export type User$createdDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.updatedDocumentVersions
   */
  export type User$updatedDocumentVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    cursor?: DocumentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * User.createdReportTemplates
   */
  export type User$createdReportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    cursor?: ReportTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * User.createdScheduledReports
   */
  export type User$createdScheduledReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * User.documentReadConfirmations
   */
  export type User$documentReadConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    where?: DocumentReadConfirmationWhereInput
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    cursor?: DocumentReadConfirmationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentReadConfirmationScalarFieldEnum | DocumentReadConfirmationScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    type: number
    title: number
    message: number
    link: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    type: string
    title: string
    message: string
    link: string | null
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      type: string
      title: string
      message: string
      link: string | null
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model InternalAudit
   */

  export type AggregateInternalAudit = {
    _count: InternalAuditCountAggregateOutputType | null
    _avg: InternalAuditAvgAggregateOutputType | null
    _sum: InternalAuditSumAggregateOutputType | null
    _min: InternalAuditMinAggregateOutputType | null
    _max: InternalAuditMaxAggregateOutputType | null
  }

  export type InternalAuditAvgAggregateOutputType = {
    ano: number | null
  }

  export type InternalAuditSumAggregateOutputType = {
    ano: number | null
  }

  export type InternalAuditMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    auditProgramId: string | null
    ano: number | null
    entidadeAuditora: string | null
    iso: string | null
    inicio: Date | null
    termino: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InternalAuditMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    auditProgramId: string | null
    ano: number | null
    entidadeAuditora: string | null
    iso: string | null
    inicio: Date | null
    termino: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InternalAuditCountAggregateOutputType = {
    id: number
    tenantId: number
    auditProgramId: number
    ano: number
    entidadeAuditora: number
    iso: number
    inicio: number
    termino: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InternalAuditAvgAggregateInputType = {
    ano?: true
  }

  export type InternalAuditSumAggregateInputType = {
    ano?: true
  }

  export type InternalAuditMinAggregateInputType = {
    id?: true
    tenantId?: true
    auditProgramId?: true
    ano?: true
    entidadeAuditora?: true
    iso?: true
    inicio?: true
    termino?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InternalAuditMaxAggregateInputType = {
    id?: true
    tenantId?: true
    auditProgramId?: true
    ano?: true
    entidadeAuditora?: true
    iso?: true
    inicio?: true
    termino?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InternalAuditCountAggregateInputType = {
    id?: true
    tenantId?: true
    auditProgramId?: true
    ano?: true
    entidadeAuditora?: true
    iso?: true
    inicio?: true
    termino?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InternalAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalAudit to aggregate.
     */
    where?: InternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalAudits to fetch.
     */
    orderBy?: InternalAuditOrderByWithRelationInput | InternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternalAudits
    **/
    _count?: true | InternalAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternalAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternalAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternalAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternalAuditMaxAggregateInputType
  }

  export type GetInternalAuditAggregateType<T extends InternalAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateInternalAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternalAudit[P]>
      : GetScalarType<T[P], AggregateInternalAudit[P]>
  }




  export type InternalAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalAuditWhereInput
    orderBy?: InternalAuditOrderByWithAggregationInput | InternalAuditOrderByWithAggregationInput[]
    by: InternalAuditScalarFieldEnum[] | InternalAuditScalarFieldEnum
    having?: InternalAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternalAuditCountAggregateInputType | true
    _avg?: InternalAuditAvgAggregateInputType
    _sum?: InternalAuditSumAggregateInputType
    _min?: InternalAuditMinAggregateInputType
    _max?: InternalAuditMaxAggregateInputType
  }

  export type InternalAuditGroupByOutputType = {
    id: string
    tenantId: string
    auditProgramId: string | null
    ano: number
    entidadeAuditora: string | null
    iso: string | null
    inicio: Date | null
    termino: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InternalAuditCountAggregateOutputType | null
    _avg: InternalAuditAvgAggregateOutputType | null
    _sum: InternalAuditSumAggregateOutputType | null
    _min: InternalAuditMinAggregateOutputType | null
    _max: InternalAuditMaxAggregateOutputType | null
  }

  type GetInternalAuditGroupByPayload<T extends InternalAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternalAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternalAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternalAuditGroupByOutputType[P]>
            : GetScalarType<T[P], InternalAuditGroupByOutputType[P]>
        }
      >
    >


  export type InternalAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    auditProgramId?: boolean
    ano?: boolean
    entidadeAuditora?: boolean
    iso?: boolean
    inicio?: boolean
    termino?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | InternalAudit$auditProgramArgs<ExtArgs>
  }, ExtArgs["result"]["internalAudit"]>

  export type InternalAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    auditProgramId?: boolean
    ano?: boolean
    entidadeAuditora?: boolean
    iso?: boolean
    inicio?: boolean
    termino?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | InternalAudit$auditProgramArgs<ExtArgs>
  }, ExtArgs["result"]["internalAudit"]>

  export type InternalAuditSelectScalar = {
    id?: boolean
    tenantId?: boolean
    auditProgramId?: boolean
    ano?: boolean
    entidadeAuditora?: boolean
    iso?: boolean
    inicio?: boolean
    termino?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InternalAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | InternalAudit$auditProgramArgs<ExtArgs>
  }
  export type InternalAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | InternalAudit$auditProgramArgs<ExtArgs>
  }

  export type $InternalAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternalAudit"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      auditProgram: Prisma.$AuditProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      auditProgramId: string | null
      ano: number
      entidadeAuditora: string | null
      iso: string | null
      inicio: Date | null
      termino: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["internalAudit"]>
    composites: {}
  }

  type InternalAuditGetPayload<S extends boolean | null | undefined | InternalAuditDefaultArgs> = $Result.GetResult<Prisma.$InternalAuditPayload, S>

  type InternalAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternalAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternalAuditCountAggregateInputType | true
    }

  export interface InternalAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternalAudit'], meta: { name: 'InternalAudit' } }
    /**
     * Find zero or one InternalAudit that matches the filter.
     * @param {InternalAuditFindUniqueArgs} args - Arguments to find a InternalAudit
     * @example
     * // Get one InternalAudit
     * const internalAudit = await prisma.internalAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternalAuditFindUniqueArgs>(args: SelectSubset<T, InternalAuditFindUniqueArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InternalAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InternalAuditFindUniqueOrThrowArgs} args - Arguments to find a InternalAudit
     * @example
     * // Get one InternalAudit
     * const internalAudit = await prisma.internalAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternalAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, InternalAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InternalAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditFindFirstArgs} args - Arguments to find a InternalAudit
     * @example
     * // Get one InternalAudit
     * const internalAudit = await prisma.internalAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternalAuditFindFirstArgs>(args?: SelectSubset<T, InternalAuditFindFirstArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InternalAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditFindFirstOrThrowArgs} args - Arguments to find a InternalAudit
     * @example
     * // Get one InternalAudit
     * const internalAudit = await prisma.internalAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternalAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, InternalAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InternalAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternalAudits
     * const internalAudits = await prisma.internalAudit.findMany()
     * 
     * // Get first 10 InternalAudits
     * const internalAudits = await prisma.internalAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internalAuditWithIdOnly = await prisma.internalAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InternalAuditFindManyArgs>(args?: SelectSubset<T, InternalAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InternalAudit.
     * @param {InternalAuditCreateArgs} args - Arguments to create a InternalAudit.
     * @example
     * // Create one InternalAudit
     * const InternalAudit = await prisma.internalAudit.create({
     *   data: {
     *     // ... data to create a InternalAudit
     *   }
     * })
     * 
     */
    create<T extends InternalAuditCreateArgs>(args: SelectSubset<T, InternalAuditCreateArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InternalAudits.
     * @param {InternalAuditCreateManyArgs} args - Arguments to create many InternalAudits.
     * @example
     * // Create many InternalAudits
     * const internalAudit = await prisma.internalAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternalAuditCreateManyArgs>(args?: SelectSubset<T, InternalAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InternalAudits and returns the data saved in the database.
     * @param {InternalAuditCreateManyAndReturnArgs} args - Arguments to create many InternalAudits.
     * @example
     * // Create many InternalAudits
     * const internalAudit = await prisma.internalAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InternalAudits and only return the `id`
     * const internalAuditWithIdOnly = await prisma.internalAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InternalAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, InternalAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InternalAudit.
     * @param {InternalAuditDeleteArgs} args - Arguments to delete one InternalAudit.
     * @example
     * // Delete one InternalAudit
     * const InternalAudit = await prisma.internalAudit.delete({
     *   where: {
     *     // ... filter to delete one InternalAudit
     *   }
     * })
     * 
     */
    delete<T extends InternalAuditDeleteArgs>(args: SelectSubset<T, InternalAuditDeleteArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InternalAudit.
     * @param {InternalAuditUpdateArgs} args - Arguments to update one InternalAudit.
     * @example
     * // Update one InternalAudit
     * const internalAudit = await prisma.internalAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternalAuditUpdateArgs>(args: SelectSubset<T, InternalAuditUpdateArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InternalAudits.
     * @param {InternalAuditDeleteManyArgs} args - Arguments to filter InternalAudits to delete.
     * @example
     * // Delete a few InternalAudits
     * const { count } = await prisma.internalAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternalAuditDeleteManyArgs>(args?: SelectSubset<T, InternalAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternalAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternalAudits
     * const internalAudit = await prisma.internalAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternalAuditUpdateManyArgs>(args: SelectSubset<T, InternalAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InternalAudit.
     * @param {InternalAuditUpsertArgs} args - Arguments to update or create a InternalAudit.
     * @example
     * // Update or create a InternalAudit
     * const internalAudit = await prisma.internalAudit.upsert({
     *   create: {
     *     // ... data to create a InternalAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternalAudit we want to update
     *   }
     * })
     */
    upsert<T extends InternalAuditUpsertArgs>(args: SelectSubset<T, InternalAuditUpsertArgs<ExtArgs>>): Prisma__InternalAuditClient<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InternalAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditCountArgs} args - Arguments to filter InternalAudits to count.
     * @example
     * // Count the number of InternalAudits
     * const count = await prisma.internalAudit.count({
     *   where: {
     *     // ... the filter for the InternalAudits we want to count
     *   }
     * })
    **/
    count<T extends InternalAuditCountArgs>(
      args?: Subset<T, InternalAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternalAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternalAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternalAuditAggregateArgs>(args: Subset<T, InternalAuditAggregateArgs>): Prisma.PrismaPromise<GetInternalAuditAggregateType<T>>

    /**
     * Group by InternalAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternalAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternalAuditGroupByArgs['orderBy'] }
        : { orderBy?: InternalAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternalAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternalAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternalAudit model
   */
  readonly fields: InternalAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternalAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternalAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    auditProgram<T extends InternalAudit$auditProgramArgs<ExtArgs> = {}>(args?: Subset<T, InternalAudit$auditProgramArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InternalAudit model
   */ 
  interface InternalAuditFieldRefs {
    readonly id: FieldRef<"InternalAudit", 'String'>
    readonly tenantId: FieldRef<"InternalAudit", 'String'>
    readonly auditProgramId: FieldRef<"InternalAudit", 'String'>
    readonly ano: FieldRef<"InternalAudit", 'Int'>
    readonly entidadeAuditora: FieldRef<"InternalAudit", 'String'>
    readonly iso: FieldRef<"InternalAudit", 'String'>
    readonly inicio: FieldRef<"InternalAudit", 'DateTime'>
    readonly termino: FieldRef<"InternalAudit", 'DateTime'>
    readonly createdAt: FieldRef<"InternalAudit", 'DateTime'>
    readonly updatedAt: FieldRef<"InternalAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InternalAudit findUnique
   */
  export type InternalAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which InternalAudit to fetch.
     */
    where: InternalAuditWhereUniqueInput
  }

  /**
   * InternalAudit findUniqueOrThrow
   */
  export type InternalAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which InternalAudit to fetch.
     */
    where: InternalAuditWhereUniqueInput
  }

  /**
   * InternalAudit findFirst
   */
  export type InternalAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which InternalAudit to fetch.
     */
    where?: InternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalAudits to fetch.
     */
    orderBy?: InternalAuditOrderByWithRelationInput | InternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalAudits.
     */
    cursor?: InternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalAudits.
     */
    distinct?: InternalAuditScalarFieldEnum | InternalAuditScalarFieldEnum[]
  }

  /**
   * InternalAudit findFirstOrThrow
   */
  export type InternalAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which InternalAudit to fetch.
     */
    where?: InternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalAudits to fetch.
     */
    orderBy?: InternalAuditOrderByWithRelationInput | InternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalAudits.
     */
    cursor?: InternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalAudits.
     */
    distinct?: InternalAuditScalarFieldEnum | InternalAuditScalarFieldEnum[]
  }

  /**
   * InternalAudit findMany
   */
  export type InternalAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which InternalAudits to fetch.
     */
    where?: InternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalAudits to fetch.
     */
    orderBy?: InternalAuditOrderByWithRelationInput | InternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternalAudits.
     */
    cursor?: InternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalAudits.
     */
    skip?: number
    distinct?: InternalAuditScalarFieldEnum | InternalAuditScalarFieldEnum[]
  }

  /**
   * InternalAudit create
   */
  export type InternalAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a InternalAudit.
     */
    data: XOR<InternalAuditCreateInput, InternalAuditUncheckedCreateInput>
  }

  /**
   * InternalAudit createMany
   */
  export type InternalAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternalAudits.
     */
    data: InternalAuditCreateManyInput | InternalAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InternalAudit createManyAndReturn
   */
  export type InternalAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InternalAudits.
     */
    data: InternalAuditCreateManyInput | InternalAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InternalAudit update
   */
  export type InternalAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a InternalAudit.
     */
    data: XOR<InternalAuditUpdateInput, InternalAuditUncheckedUpdateInput>
    /**
     * Choose, which InternalAudit to update.
     */
    where: InternalAuditWhereUniqueInput
  }

  /**
   * InternalAudit updateMany
   */
  export type InternalAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternalAudits.
     */
    data: XOR<InternalAuditUpdateManyMutationInput, InternalAuditUncheckedUpdateManyInput>
    /**
     * Filter which InternalAudits to update
     */
    where?: InternalAuditWhereInput
  }

  /**
   * InternalAudit upsert
   */
  export type InternalAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the InternalAudit to update in case it exists.
     */
    where: InternalAuditWhereUniqueInput
    /**
     * In case the InternalAudit found by the `where` argument doesn't exist, create a new InternalAudit with this data.
     */
    create: XOR<InternalAuditCreateInput, InternalAuditUncheckedCreateInput>
    /**
     * In case the InternalAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternalAuditUpdateInput, InternalAuditUncheckedUpdateInput>
  }

  /**
   * InternalAudit delete
   */
  export type InternalAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    /**
     * Filter which InternalAudit to delete.
     */
    where: InternalAuditWhereUniqueInput
  }

  /**
   * InternalAudit deleteMany
   */
  export type InternalAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalAudits to delete
     */
    where?: InternalAuditWhereInput
  }

  /**
   * InternalAudit.auditProgram
   */
  export type InternalAudit$auditProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    where?: AuditProgramWhereInput
  }

  /**
   * InternalAudit without action
   */
  export type InternalAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
  }


  /**
   * Model ExternalAudit
   */

  export type AggregateExternalAudit = {
    _count: ExternalAuditCountAggregateOutputType | null
    _avg: ExternalAuditAvgAggregateOutputType | null
    _sum: ExternalAuditSumAggregateOutputType | null
    _min: ExternalAuditMinAggregateOutputType | null
    _max: ExternalAuditMaxAggregateOutputType | null
  }

  export type ExternalAuditAvgAggregateOutputType = {
    ano: number | null
  }

  export type ExternalAuditSumAggregateOutputType = {
    ano: number | null
  }

  export type ExternalAuditMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    auditProgramId: string | null
    ano: number | null
    entidadeAuditora: string | null
    iso: string | null
    inicio: Date | null
    termino: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalAuditMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    auditProgramId: string | null
    ano: number | null
    entidadeAuditora: string | null
    iso: string | null
    inicio: Date | null
    termino: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalAuditCountAggregateOutputType = {
    id: number
    tenantId: number
    auditProgramId: number
    ano: number
    entidadeAuditora: number
    iso: number
    inicio: number
    termino: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalAuditAvgAggregateInputType = {
    ano?: true
  }

  export type ExternalAuditSumAggregateInputType = {
    ano?: true
  }

  export type ExternalAuditMinAggregateInputType = {
    id?: true
    tenantId?: true
    auditProgramId?: true
    ano?: true
    entidadeAuditora?: true
    iso?: true
    inicio?: true
    termino?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalAuditMaxAggregateInputType = {
    id?: true
    tenantId?: true
    auditProgramId?: true
    ano?: true
    entidadeAuditora?: true
    iso?: true
    inicio?: true
    termino?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalAuditCountAggregateInputType = {
    id?: true
    tenantId?: true
    auditProgramId?: true
    ano?: true
    entidadeAuditora?: true
    iso?: true
    inicio?: true
    termino?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalAudit to aggregate.
     */
    where?: ExternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAudits to fetch.
     */
    orderBy?: ExternalAuditOrderByWithRelationInput | ExternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalAudits
    **/
    _count?: true | ExternalAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAuditMaxAggregateInputType
  }

  export type GetExternalAuditAggregateType<T extends ExternalAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalAudit[P]>
      : GetScalarType<T[P], AggregateExternalAudit[P]>
  }




  export type ExternalAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalAuditWhereInput
    orderBy?: ExternalAuditOrderByWithAggregationInput | ExternalAuditOrderByWithAggregationInput[]
    by: ExternalAuditScalarFieldEnum[] | ExternalAuditScalarFieldEnum
    having?: ExternalAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAuditCountAggregateInputType | true
    _avg?: ExternalAuditAvgAggregateInputType
    _sum?: ExternalAuditSumAggregateInputType
    _min?: ExternalAuditMinAggregateInputType
    _max?: ExternalAuditMaxAggregateInputType
  }

  export type ExternalAuditGroupByOutputType = {
    id: string
    tenantId: string
    auditProgramId: string | null
    ano: number
    entidadeAuditora: string
    iso: string | null
    inicio: Date | null
    termino: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExternalAuditCountAggregateOutputType | null
    _avg: ExternalAuditAvgAggregateOutputType | null
    _sum: ExternalAuditSumAggregateOutputType | null
    _min: ExternalAuditMinAggregateOutputType | null
    _max: ExternalAuditMaxAggregateOutputType | null
  }

  type GetExternalAuditGroupByPayload<T extends ExternalAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAuditGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAuditGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    auditProgramId?: boolean
    ano?: boolean
    entidadeAuditora?: boolean
    iso?: boolean
    inicio?: boolean
    termino?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | ExternalAudit$auditProgramArgs<ExtArgs>
  }, ExtArgs["result"]["externalAudit"]>

  export type ExternalAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    auditProgramId?: boolean
    ano?: boolean
    entidadeAuditora?: boolean
    iso?: boolean
    inicio?: boolean
    termino?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | ExternalAudit$auditProgramArgs<ExtArgs>
  }, ExtArgs["result"]["externalAudit"]>

  export type ExternalAuditSelectScalar = {
    id?: boolean
    tenantId?: boolean
    auditProgramId?: boolean
    ano?: boolean
    entidadeAuditora?: boolean
    iso?: boolean
    inicio?: boolean
    termino?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | ExternalAudit$auditProgramArgs<ExtArgs>
  }
  export type ExternalAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    auditProgram?: boolean | ExternalAudit$auditProgramArgs<ExtArgs>
  }

  export type $ExternalAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalAudit"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      auditProgram: Prisma.$AuditProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      auditProgramId: string | null
      ano: number
      entidadeAuditora: string
      iso: string | null
      inicio: Date | null
      termino: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalAudit"]>
    composites: {}
  }

  type ExternalAuditGetPayload<S extends boolean | null | undefined | ExternalAuditDefaultArgs> = $Result.GetResult<Prisma.$ExternalAuditPayload, S>

  type ExternalAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExternalAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExternalAuditCountAggregateInputType | true
    }

  export interface ExternalAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalAudit'], meta: { name: 'ExternalAudit' } }
    /**
     * Find zero or one ExternalAudit that matches the filter.
     * @param {ExternalAuditFindUniqueArgs} args - Arguments to find a ExternalAudit
     * @example
     * // Get one ExternalAudit
     * const externalAudit = await prisma.externalAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalAuditFindUniqueArgs>(args: SelectSubset<T, ExternalAuditFindUniqueArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExternalAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExternalAuditFindUniqueOrThrowArgs} args - Arguments to find a ExternalAudit
     * @example
     * // Get one ExternalAudit
     * const externalAudit = await prisma.externalAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExternalAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditFindFirstArgs} args - Arguments to find a ExternalAudit
     * @example
     * // Get one ExternalAudit
     * const externalAudit = await prisma.externalAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalAuditFindFirstArgs>(args?: SelectSubset<T, ExternalAuditFindFirstArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExternalAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditFindFirstOrThrowArgs} args - Arguments to find a ExternalAudit
     * @example
     * // Get one ExternalAudit
     * const externalAudit = await prisma.externalAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExternalAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalAudits
     * const externalAudits = await prisma.externalAudit.findMany()
     * 
     * // Get first 10 ExternalAudits
     * const externalAudits = await prisma.externalAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalAuditWithIdOnly = await prisma.externalAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalAuditFindManyArgs>(args?: SelectSubset<T, ExternalAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExternalAudit.
     * @param {ExternalAuditCreateArgs} args - Arguments to create a ExternalAudit.
     * @example
     * // Create one ExternalAudit
     * const ExternalAudit = await prisma.externalAudit.create({
     *   data: {
     *     // ... data to create a ExternalAudit
     *   }
     * })
     * 
     */
    create<T extends ExternalAuditCreateArgs>(args: SelectSubset<T, ExternalAuditCreateArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExternalAudits.
     * @param {ExternalAuditCreateManyArgs} args - Arguments to create many ExternalAudits.
     * @example
     * // Create many ExternalAudits
     * const externalAudit = await prisma.externalAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalAuditCreateManyArgs>(args?: SelectSubset<T, ExternalAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalAudits and returns the data saved in the database.
     * @param {ExternalAuditCreateManyAndReturnArgs} args - Arguments to create many ExternalAudits.
     * @example
     * // Create many ExternalAudits
     * const externalAudit = await prisma.externalAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalAudits and only return the `id`
     * const externalAuditWithIdOnly = await prisma.externalAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExternalAudit.
     * @param {ExternalAuditDeleteArgs} args - Arguments to delete one ExternalAudit.
     * @example
     * // Delete one ExternalAudit
     * const ExternalAudit = await prisma.externalAudit.delete({
     *   where: {
     *     // ... filter to delete one ExternalAudit
     *   }
     * })
     * 
     */
    delete<T extends ExternalAuditDeleteArgs>(args: SelectSubset<T, ExternalAuditDeleteArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExternalAudit.
     * @param {ExternalAuditUpdateArgs} args - Arguments to update one ExternalAudit.
     * @example
     * // Update one ExternalAudit
     * const externalAudit = await prisma.externalAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalAuditUpdateArgs>(args: SelectSubset<T, ExternalAuditUpdateArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExternalAudits.
     * @param {ExternalAuditDeleteManyArgs} args - Arguments to filter ExternalAudits to delete.
     * @example
     * // Delete a few ExternalAudits
     * const { count } = await prisma.externalAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalAuditDeleteManyArgs>(args?: SelectSubset<T, ExternalAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalAudits
     * const externalAudit = await prisma.externalAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalAuditUpdateManyArgs>(args: SelectSubset<T, ExternalAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalAudit.
     * @param {ExternalAuditUpsertArgs} args - Arguments to update or create a ExternalAudit.
     * @example
     * // Update or create a ExternalAudit
     * const externalAudit = await prisma.externalAudit.upsert({
     *   create: {
     *     // ... data to create a ExternalAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalAudit we want to update
     *   }
     * })
     */
    upsert<T extends ExternalAuditUpsertArgs>(args: SelectSubset<T, ExternalAuditUpsertArgs<ExtArgs>>): Prisma__ExternalAuditClient<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExternalAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditCountArgs} args - Arguments to filter ExternalAudits to count.
     * @example
     * // Count the number of ExternalAudits
     * const count = await prisma.externalAudit.count({
     *   where: {
     *     // ... the filter for the ExternalAudits we want to count
     *   }
     * })
    **/
    count<T extends ExternalAuditCountArgs>(
      args?: Subset<T, ExternalAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAuditAggregateArgs>(args: Subset<T, ExternalAuditAggregateArgs>): Prisma.PrismaPromise<GetExternalAuditAggregateType<T>>

    /**
     * Group by ExternalAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAuditGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalAudit model
   */
  readonly fields: ExternalAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    auditProgram<T extends ExternalAudit$auditProgramArgs<ExtArgs> = {}>(args?: Subset<T, ExternalAudit$auditProgramArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalAudit model
   */ 
  interface ExternalAuditFieldRefs {
    readonly id: FieldRef<"ExternalAudit", 'String'>
    readonly tenantId: FieldRef<"ExternalAudit", 'String'>
    readonly auditProgramId: FieldRef<"ExternalAudit", 'String'>
    readonly ano: FieldRef<"ExternalAudit", 'Int'>
    readonly entidadeAuditora: FieldRef<"ExternalAudit", 'String'>
    readonly iso: FieldRef<"ExternalAudit", 'String'>
    readonly inicio: FieldRef<"ExternalAudit", 'DateTime'>
    readonly termino: FieldRef<"ExternalAudit", 'DateTime'>
    readonly createdAt: FieldRef<"ExternalAudit", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalAudit findUnique
   */
  export type ExternalAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAudit to fetch.
     */
    where: ExternalAuditWhereUniqueInput
  }

  /**
   * ExternalAudit findUniqueOrThrow
   */
  export type ExternalAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAudit to fetch.
     */
    where: ExternalAuditWhereUniqueInput
  }

  /**
   * ExternalAudit findFirst
   */
  export type ExternalAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAudit to fetch.
     */
    where?: ExternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAudits to fetch.
     */
    orderBy?: ExternalAuditOrderByWithRelationInput | ExternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAudits.
     */
    cursor?: ExternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAudits.
     */
    distinct?: ExternalAuditScalarFieldEnum | ExternalAuditScalarFieldEnum[]
  }

  /**
   * ExternalAudit findFirstOrThrow
   */
  export type ExternalAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAudit to fetch.
     */
    where?: ExternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAudits to fetch.
     */
    orderBy?: ExternalAuditOrderByWithRelationInput | ExternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAudits.
     */
    cursor?: ExternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAudits.
     */
    distinct?: ExternalAuditScalarFieldEnum | ExternalAuditScalarFieldEnum[]
  }

  /**
   * ExternalAudit findMany
   */
  export type ExternalAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAudits to fetch.
     */
    where?: ExternalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAudits to fetch.
     */
    orderBy?: ExternalAuditOrderByWithRelationInput | ExternalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalAudits.
     */
    cursor?: ExternalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAudits.
     */
    skip?: number
    distinct?: ExternalAuditScalarFieldEnum | ExternalAuditScalarFieldEnum[]
  }

  /**
   * ExternalAudit create
   */
  export type ExternalAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalAudit.
     */
    data: XOR<ExternalAuditCreateInput, ExternalAuditUncheckedCreateInput>
  }

  /**
   * ExternalAudit createMany
   */
  export type ExternalAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalAudits.
     */
    data: ExternalAuditCreateManyInput | ExternalAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalAudit createManyAndReturn
   */
  export type ExternalAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExternalAudits.
     */
    data: ExternalAuditCreateManyInput | ExternalAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalAudit update
   */
  export type ExternalAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalAudit.
     */
    data: XOR<ExternalAuditUpdateInput, ExternalAuditUncheckedUpdateInput>
    /**
     * Choose, which ExternalAudit to update.
     */
    where: ExternalAuditWhereUniqueInput
  }

  /**
   * ExternalAudit updateMany
   */
  export type ExternalAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalAudits.
     */
    data: XOR<ExternalAuditUpdateManyMutationInput, ExternalAuditUncheckedUpdateManyInput>
    /**
     * Filter which ExternalAudits to update
     */
    where?: ExternalAuditWhereInput
  }

  /**
   * ExternalAudit upsert
   */
  export type ExternalAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalAudit to update in case it exists.
     */
    where: ExternalAuditWhereUniqueInput
    /**
     * In case the ExternalAudit found by the `where` argument doesn't exist, create a new ExternalAudit with this data.
     */
    create: XOR<ExternalAuditCreateInput, ExternalAuditUncheckedCreateInput>
    /**
     * In case the ExternalAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalAuditUpdateInput, ExternalAuditUncheckedUpdateInput>
  }

  /**
   * ExternalAudit delete
   */
  export type ExternalAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    /**
     * Filter which ExternalAudit to delete.
     */
    where: ExternalAuditWhereUniqueInput
  }

  /**
   * ExternalAudit deleteMany
   */
  export type ExternalAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalAudits to delete
     */
    where?: ExternalAuditWhereInput
  }

  /**
   * ExternalAudit.auditProgram
   */
  export type ExternalAudit$auditProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    where?: AuditProgramWhereInput
  }

  /**
   * ExternalAudit without action
   */
  export type ExternalAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
  }


  /**
   * Model AuditProgram
   */

  export type AggregateAuditProgram = {
    _count: AuditProgramCountAggregateOutputType | null
    _min: AuditProgramMinAggregateOutputType | null
    _max: AuditProgramMaxAggregateOutputType | null
  }

  export type AuditProgramMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    standard: string | null
    version: string | null
    isTemplate: boolean | null
    templateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditProgramMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    standard: string | null
    version: string | null
    isTemplate: boolean | null
    templateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditProgramCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    standard: number
    version: number
    isTemplate: number
    templateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditProgramMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    standard?: true
    version?: true
    isTemplate?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditProgramMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    standard?: true
    version?: true
    isTemplate?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditProgramCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    standard?: true
    version?: true
    isTemplate?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditProgram to aggregate.
     */
    where?: AuditProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditPrograms to fetch.
     */
    orderBy?: AuditProgramOrderByWithRelationInput | AuditProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditPrograms
    **/
    _count?: true | AuditProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditProgramMaxAggregateInputType
  }

  export type GetAuditProgramAggregateType<T extends AuditProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditProgram[P]>
      : GetScalarType<T[P], AggregateAuditProgram[P]>
  }




  export type AuditProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditProgramWhereInput
    orderBy?: AuditProgramOrderByWithAggregationInput | AuditProgramOrderByWithAggregationInput[]
    by: AuditProgramScalarFieldEnum[] | AuditProgramScalarFieldEnum
    having?: AuditProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditProgramCountAggregateInputType | true
    _min?: AuditProgramMinAggregateInputType
    _max?: AuditProgramMaxAggregateInputType
  }

  export type AuditProgramGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    standard: string
    version: string
    isTemplate: boolean
    templateId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuditProgramCountAggregateOutputType | null
    _min: AuditProgramMinAggregateOutputType | null
    _max: AuditProgramMaxAggregateOutputType | null
  }

  type GetAuditProgramGroupByPayload<T extends AuditProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditProgramGroupByOutputType[P]>
            : GetScalarType<T[P], AuditProgramGroupByOutputType[P]>
        }
      >
    >


  export type AuditProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    standard?: boolean
    version?: boolean
    isTemplate?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    template?: boolean | AuditProgram$templateArgs<ExtArgs>
    derivatives?: boolean | AuditProgram$derivativesArgs<ExtArgs>
    checklists?: boolean | AuditProgram$checklistsArgs<ExtArgs>
    internalAudits?: boolean | AuditProgram$internalAuditsArgs<ExtArgs>
    externalAudits?: boolean | AuditProgram$externalAuditsArgs<ExtArgs>
    _count?: boolean | AuditProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditProgram"]>

  export type AuditProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    standard?: boolean
    version?: boolean
    isTemplate?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    template?: boolean | AuditProgram$templateArgs<ExtArgs>
  }, ExtArgs["result"]["auditProgram"]>

  export type AuditProgramSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    standard?: boolean
    version?: boolean
    isTemplate?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    template?: boolean | AuditProgram$templateArgs<ExtArgs>
    derivatives?: boolean | AuditProgram$derivativesArgs<ExtArgs>
    checklists?: boolean | AuditProgram$checklistsArgs<ExtArgs>
    internalAudits?: boolean | AuditProgram$internalAuditsArgs<ExtArgs>
    externalAudits?: boolean | AuditProgram$externalAuditsArgs<ExtArgs>
    _count?: boolean | AuditProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    template?: boolean | AuditProgram$templateArgs<ExtArgs>
  }

  export type $AuditProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditProgram"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      template: Prisma.$AuditProgramPayload<ExtArgs> | null
      derivatives: Prisma.$AuditProgramPayload<ExtArgs>[]
      checklists: Prisma.$AuditChecklistPayload<ExtArgs>[]
      internalAudits: Prisma.$InternalAuditPayload<ExtArgs>[]
      externalAudits: Prisma.$ExternalAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      standard: string
      version: string
      isTemplate: boolean
      templateId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditProgram"]>
    composites: {}
  }

  type AuditProgramGetPayload<S extends boolean | null | undefined | AuditProgramDefaultArgs> = $Result.GetResult<Prisma.$AuditProgramPayload, S>

  type AuditProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditProgramCountAggregateInputType | true
    }

  export interface AuditProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditProgram'], meta: { name: 'AuditProgram' } }
    /**
     * Find zero or one AuditProgram that matches the filter.
     * @param {AuditProgramFindUniqueArgs} args - Arguments to find a AuditProgram
     * @example
     * // Get one AuditProgram
     * const auditProgram = await prisma.auditProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditProgramFindUniqueArgs>(args: SelectSubset<T, AuditProgramFindUniqueArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditProgram that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditProgramFindUniqueOrThrowArgs} args - Arguments to find a AuditProgram
     * @example
     * // Get one AuditProgram
     * const auditProgram = await prisma.auditProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramFindFirstArgs} args - Arguments to find a AuditProgram
     * @example
     * // Get one AuditProgram
     * const auditProgram = await prisma.auditProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditProgramFindFirstArgs>(args?: SelectSubset<T, AuditProgramFindFirstArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramFindFirstOrThrowArgs} args - Arguments to find a AuditProgram
     * @example
     * // Get one AuditProgram
     * const auditProgram = await prisma.auditProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditPrograms
     * const auditPrograms = await prisma.auditProgram.findMany()
     * 
     * // Get first 10 AuditPrograms
     * const auditPrograms = await prisma.auditProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditProgramWithIdOnly = await prisma.auditProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditProgramFindManyArgs>(args?: SelectSubset<T, AuditProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditProgram.
     * @param {AuditProgramCreateArgs} args - Arguments to create a AuditProgram.
     * @example
     * // Create one AuditProgram
     * const AuditProgram = await prisma.auditProgram.create({
     *   data: {
     *     // ... data to create a AuditProgram
     *   }
     * })
     * 
     */
    create<T extends AuditProgramCreateArgs>(args: SelectSubset<T, AuditProgramCreateArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditPrograms.
     * @param {AuditProgramCreateManyArgs} args - Arguments to create many AuditPrograms.
     * @example
     * // Create many AuditPrograms
     * const auditProgram = await prisma.auditProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditProgramCreateManyArgs>(args?: SelectSubset<T, AuditProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditPrograms and returns the data saved in the database.
     * @param {AuditProgramCreateManyAndReturnArgs} args - Arguments to create many AuditPrograms.
     * @example
     * // Create many AuditPrograms
     * const auditProgram = await prisma.auditProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditPrograms and only return the `id`
     * const auditProgramWithIdOnly = await prisma.auditProgram.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditProgram.
     * @param {AuditProgramDeleteArgs} args - Arguments to delete one AuditProgram.
     * @example
     * // Delete one AuditProgram
     * const AuditProgram = await prisma.auditProgram.delete({
     *   where: {
     *     // ... filter to delete one AuditProgram
     *   }
     * })
     * 
     */
    delete<T extends AuditProgramDeleteArgs>(args: SelectSubset<T, AuditProgramDeleteArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditProgram.
     * @param {AuditProgramUpdateArgs} args - Arguments to update one AuditProgram.
     * @example
     * // Update one AuditProgram
     * const auditProgram = await prisma.auditProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditProgramUpdateArgs>(args: SelectSubset<T, AuditProgramUpdateArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditPrograms.
     * @param {AuditProgramDeleteManyArgs} args - Arguments to filter AuditPrograms to delete.
     * @example
     * // Delete a few AuditPrograms
     * const { count } = await prisma.auditProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditProgramDeleteManyArgs>(args?: SelectSubset<T, AuditProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditPrograms
     * const auditProgram = await prisma.auditProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditProgramUpdateManyArgs>(args: SelectSubset<T, AuditProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditProgram.
     * @param {AuditProgramUpsertArgs} args - Arguments to update or create a AuditProgram.
     * @example
     * // Update or create a AuditProgram
     * const auditProgram = await prisma.auditProgram.upsert({
     *   create: {
     *     // ... data to create a AuditProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditProgram we want to update
     *   }
     * })
     */
    upsert<T extends AuditProgramUpsertArgs>(args: SelectSubset<T, AuditProgramUpsertArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramCountArgs} args - Arguments to filter AuditPrograms to count.
     * @example
     * // Count the number of AuditPrograms
     * const count = await prisma.auditProgram.count({
     *   where: {
     *     // ... the filter for the AuditPrograms we want to count
     *   }
     * })
    **/
    count<T extends AuditProgramCountArgs>(
      args?: Subset<T, AuditProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditProgramAggregateArgs>(args: Subset<T, AuditProgramAggregateArgs>): Prisma.PrismaPromise<GetAuditProgramAggregateType<T>>

    /**
     * Group by AuditProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditProgramGroupByArgs['orderBy'] }
        : { orderBy?: AuditProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditProgram model
   */
  readonly fields: AuditProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    template<T extends AuditProgram$templateArgs<ExtArgs> = {}>(args?: Subset<T, AuditProgram$templateArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    derivatives<T extends AuditProgram$derivativesArgs<ExtArgs> = {}>(args?: Subset<T, AuditProgram$derivativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findMany"> | Null>
    checklists<T extends AuditProgram$checklistsArgs<ExtArgs> = {}>(args?: Subset<T, AuditProgram$checklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "findMany"> | Null>
    internalAudits<T extends AuditProgram$internalAuditsArgs<ExtArgs> = {}>(args?: Subset<T, AuditProgram$internalAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalAuditPayload<ExtArgs>, T, "findMany"> | Null>
    externalAudits<T extends AuditProgram$externalAuditsArgs<ExtArgs> = {}>(args?: Subset<T, AuditProgram$externalAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalAuditPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditProgram model
   */ 
  interface AuditProgramFieldRefs {
    readonly id: FieldRef<"AuditProgram", 'String'>
    readonly tenantId: FieldRef<"AuditProgram", 'String'>
    readonly name: FieldRef<"AuditProgram", 'String'>
    readonly description: FieldRef<"AuditProgram", 'String'>
    readonly standard: FieldRef<"AuditProgram", 'String'>
    readonly version: FieldRef<"AuditProgram", 'String'>
    readonly isTemplate: FieldRef<"AuditProgram", 'Boolean'>
    readonly templateId: FieldRef<"AuditProgram", 'String'>
    readonly createdAt: FieldRef<"AuditProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditProgram findUnique
   */
  export type AuditProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * Filter, which AuditProgram to fetch.
     */
    where: AuditProgramWhereUniqueInput
  }

  /**
   * AuditProgram findUniqueOrThrow
   */
  export type AuditProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * Filter, which AuditProgram to fetch.
     */
    where: AuditProgramWhereUniqueInput
  }

  /**
   * AuditProgram findFirst
   */
  export type AuditProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * Filter, which AuditProgram to fetch.
     */
    where?: AuditProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditPrograms to fetch.
     */
    orderBy?: AuditProgramOrderByWithRelationInput | AuditProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditPrograms.
     */
    cursor?: AuditProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditPrograms.
     */
    distinct?: AuditProgramScalarFieldEnum | AuditProgramScalarFieldEnum[]
  }

  /**
   * AuditProgram findFirstOrThrow
   */
  export type AuditProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * Filter, which AuditProgram to fetch.
     */
    where?: AuditProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditPrograms to fetch.
     */
    orderBy?: AuditProgramOrderByWithRelationInput | AuditProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditPrograms.
     */
    cursor?: AuditProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditPrograms.
     */
    distinct?: AuditProgramScalarFieldEnum | AuditProgramScalarFieldEnum[]
  }

  /**
   * AuditProgram findMany
   */
  export type AuditProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * Filter, which AuditPrograms to fetch.
     */
    where?: AuditProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditPrograms to fetch.
     */
    orderBy?: AuditProgramOrderByWithRelationInput | AuditProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditPrograms.
     */
    cursor?: AuditProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditPrograms.
     */
    skip?: number
    distinct?: AuditProgramScalarFieldEnum | AuditProgramScalarFieldEnum[]
  }

  /**
   * AuditProgram create
   */
  export type AuditProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditProgram.
     */
    data: XOR<AuditProgramCreateInput, AuditProgramUncheckedCreateInput>
  }

  /**
   * AuditProgram createMany
   */
  export type AuditProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditPrograms.
     */
    data: AuditProgramCreateManyInput | AuditProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditProgram createManyAndReturn
   */
  export type AuditProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditPrograms.
     */
    data: AuditProgramCreateManyInput | AuditProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditProgram update
   */
  export type AuditProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditProgram.
     */
    data: XOR<AuditProgramUpdateInput, AuditProgramUncheckedUpdateInput>
    /**
     * Choose, which AuditProgram to update.
     */
    where: AuditProgramWhereUniqueInput
  }

  /**
   * AuditProgram updateMany
   */
  export type AuditProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditPrograms.
     */
    data: XOR<AuditProgramUpdateManyMutationInput, AuditProgramUncheckedUpdateManyInput>
    /**
     * Filter which AuditPrograms to update
     */
    where?: AuditProgramWhereInput
  }

  /**
   * AuditProgram upsert
   */
  export type AuditProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditProgram to update in case it exists.
     */
    where: AuditProgramWhereUniqueInput
    /**
     * In case the AuditProgram found by the `where` argument doesn't exist, create a new AuditProgram with this data.
     */
    create: XOR<AuditProgramCreateInput, AuditProgramUncheckedCreateInput>
    /**
     * In case the AuditProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditProgramUpdateInput, AuditProgramUncheckedUpdateInput>
  }

  /**
   * AuditProgram delete
   */
  export type AuditProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    /**
     * Filter which AuditProgram to delete.
     */
    where: AuditProgramWhereUniqueInput
  }

  /**
   * AuditProgram deleteMany
   */
  export type AuditProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditPrograms to delete
     */
    where?: AuditProgramWhereInput
  }

  /**
   * AuditProgram.template
   */
  export type AuditProgram$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    where?: AuditProgramWhereInput
  }

  /**
   * AuditProgram.derivatives
   */
  export type AuditProgram$derivativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
    where?: AuditProgramWhereInput
    orderBy?: AuditProgramOrderByWithRelationInput | AuditProgramOrderByWithRelationInput[]
    cursor?: AuditProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditProgramScalarFieldEnum | AuditProgramScalarFieldEnum[]
  }

  /**
   * AuditProgram.checklists
   */
  export type AuditProgram$checklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    where?: AuditChecklistWhereInput
    orderBy?: AuditChecklistOrderByWithRelationInput | AuditChecklistOrderByWithRelationInput[]
    cursor?: AuditChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditChecklistScalarFieldEnum | AuditChecklistScalarFieldEnum[]
  }

  /**
   * AuditProgram.internalAudits
   */
  export type AuditProgram$internalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalAudit
     */
    select?: InternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalAuditInclude<ExtArgs> | null
    where?: InternalAuditWhereInput
    orderBy?: InternalAuditOrderByWithRelationInput | InternalAuditOrderByWithRelationInput[]
    cursor?: InternalAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternalAuditScalarFieldEnum | InternalAuditScalarFieldEnum[]
  }

  /**
   * AuditProgram.externalAudits
   */
  export type AuditProgram$externalAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAudit
     */
    select?: ExternalAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAuditInclude<ExtArgs> | null
    where?: ExternalAuditWhereInput
    orderBy?: ExternalAuditOrderByWithRelationInput | ExternalAuditOrderByWithRelationInput[]
    cursor?: ExternalAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalAuditScalarFieldEnum | ExternalAuditScalarFieldEnum[]
  }

  /**
   * AuditProgram without action
   */
  export type AuditProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditProgram
     */
    select?: AuditProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditProgramInclude<ExtArgs> | null
  }


  /**
   * Model AuditChecklist
   */

  export type AggregateAuditChecklist = {
    _count: AuditChecklistCountAggregateOutputType | null
    _avg: AuditChecklistAvgAggregateOutputType | null
    _sum: AuditChecklistSumAggregateOutputType | null
    _min: AuditChecklistMinAggregateOutputType | null
    _max: AuditChecklistMaxAggregateOutputType | null
  }

  export type AuditChecklistAvgAggregateOutputType = {
    order: number | null
  }

  export type AuditChecklistSumAggregateOutputType = {
    order: number | null
  }

  export type AuditChecklistMinAggregateOutputType = {
    id: string | null
    auditProgramId: string | null
    clause: string | null
    item: string | null
    requirement: string | null
    evidenceType: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditChecklistMaxAggregateOutputType = {
    id: string | null
    auditProgramId: string | null
    clause: string | null
    item: string | null
    requirement: string | null
    evidenceType: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditChecklistCountAggregateOutputType = {
    id: number
    auditProgramId: number
    clause: number
    item: number
    requirement: number
    evidenceType: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditChecklistAvgAggregateInputType = {
    order?: true
  }

  export type AuditChecklistSumAggregateInputType = {
    order?: true
  }

  export type AuditChecklistMinAggregateInputType = {
    id?: true
    auditProgramId?: true
    clause?: true
    item?: true
    requirement?: true
    evidenceType?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditChecklistMaxAggregateInputType = {
    id?: true
    auditProgramId?: true
    clause?: true
    item?: true
    requirement?: true
    evidenceType?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditChecklistCountAggregateInputType = {
    id?: true
    auditProgramId?: true
    clause?: true
    item?: true
    requirement?: true
    evidenceType?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditChecklist to aggregate.
     */
    where?: AuditChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditChecklists to fetch.
     */
    orderBy?: AuditChecklistOrderByWithRelationInput | AuditChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditChecklists
    **/
    _count?: true | AuditChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditChecklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditChecklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditChecklistMaxAggregateInputType
  }

  export type GetAuditChecklistAggregateType<T extends AuditChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditChecklist[P]>
      : GetScalarType<T[P], AggregateAuditChecklist[P]>
  }




  export type AuditChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditChecklistWhereInput
    orderBy?: AuditChecklistOrderByWithAggregationInput | AuditChecklistOrderByWithAggregationInput[]
    by: AuditChecklistScalarFieldEnum[] | AuditChecklistScalarFieldEnum
    having?: AuditChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditChecklistCountAggregateInputType | true
    _avg?: AuditChecklistAvgAggregateInputType
    _sum?: AuditChecklistSumAggregateInputType
    _min?: AuditChecklistMinAggregateInputType
    _max?: AuditChecklistMaxAggregateInputType
  }

  export type AuditChecklistGroupByOutputType = {
    id: string
    auditProgramId: string
    clause: string
    item: string
    requirement: string | null
    evidenceType: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: AuditChecklistCountAggregateOutputType | null
    _avg: AuditChecklistAvgAggregateOutputType | null
    _sum: AuditChecklistSumAggregateOutputType | null
    _min: AuditChecklistMinAggregateOutputType | null
    _max: AuditChecklistMaxAggregateOutputType | null
  }

  type GetAuditChecklistGroupByPayload<T extends AuditChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], AuditChecklistGroupByOutputType[P]>
        }
      >
    >


  export type AuditChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditProgramId?: boolean
    clause?: boolean
    item?: boolean
    requirement?: boolean
    evidenceType?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditProgram?: boolean | AuditProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditChecklist"]>

  export type AuditChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditProgramId?: boolean
    clause?: boolean
    item?: boolean
    requirement?: boolean
    evidenceType?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditProgram?: boolean | AuditProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditChecklist"]>

  export type AuditChecklistSelectScalar = {
    id?: boolean
    auditProgramId?: boolean
    clause?: boolean
    item?: boolean
    requirement?: boolean
    evidenceType?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditProgram?: boolean | AuditProgramDefaultArgs<ExtArgs>
  }
  export type AuditChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditProgram?: boolean | AuditProgramDefaultArgs<ExtArgs>
  }

  export type $AuditChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditChecklist"
    objects: {
      auditProgram: Prisma.$AuditProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditProgramId: string
      clause: string
      item: string
      requirement: string | null
      evidenceType: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditChecklist"]>
    composites: {}
  }

  type AuditChecklistGetPayload<S extends boolean | null | undefined | AuditChecklistDefaultArgs> = $Result.GetResult<Prisma.$AuditChecklistPayload, S>

  type AuditChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditChecklistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditChecklistCountAggregateInputType | true
    }

  export interface AuditChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditChecklist'], meta: { name: 'AuditChecklist' } }
    /**
     * Find zero or one AuditChecklist that matches the filter.
     * @param {AuditChecklistFindUniqueArgs} args - Arguments to find a AuditChecklist
     * @example
     * // Get one AuditChecklist
     * const auditChecklist = await prisma.auditChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditChecklistFindUniqueArgs>(args: SelectSubset<T, AuditChecklistFindUniqueArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditChecklist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditChecklistFindUniqueOrThrowArgs} args - Arguments to find a AuditChecklist
     * @example
     * // Get one AuditChecklist
     * const auditChecklist = await prisma.auditChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistFindFirstArgs} args - Arguments to find a AuditChecklist
     * @example
     * // Get one AuditChecklist
     * const auditChecklist = await prisma.auditChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditChecklistFindFirstArgs>(args?: SelectSubset<T, AuditChecklistFindFirstArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistFindFirstOrThrowArgs} args - Arguments to find a AuditChecklist
     * @example
     * // Get one AuditChecklist
     * const auditChecklist = await prisma.auditChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditChecklists
     * const auditChecklists = await prisma.auditChecklist.findMany()
     * 
     * // Get first 10 AuditChecklists
     * const auditChecklists = await prisma.auditChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditChecklistWithIdOnly = await prisma.auditChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditChecklistFindManyArgs>(args?: SelectSubset<T, AuditChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditChecklist.
     * @param {AuditChecklistCreateArgs} args - Arguments to create a AuditChecklist.
     * @example
     * // Create one AuditChecklist
     * const AuditChecklist = await prisma.auditChecklist.create({
     *   data: {
     *     // ... data to create a AuditChecklist
     *   }
     * })
     * 
     */
    create<T extends AuditChecklistCreateArgs>(args: SelectSubset<T, AuditChecklistCreateArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditChecklists.
     * @param {AuditChecklistCreateManyArgs} args - Arguments to create many AuditChecklists.
     * @example
     * // Create many AuditChecklists
     * const auditChecklist = await prisma.auditChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditChecklistCreateManyArgs>(args?: SelectSubset<T, AuditChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditChecklists and returns the data saved in the database.
     * @param {AuditChecklistCreateManyAndReturnArgs} args - Arguments to create many AuditChecklists.
     * @example
     * // Create many AuditChecklists
     * const auditChecklist = await prisma.auditChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditChecklists and only return the `id`
     * const auditChecklistWithIdOnly = await prisma.auditChecklist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditChecklist.
     * @param {AuditChecklistDeleteArgs} args - Arguments to delete one AuditChecklist.
     * @example
     * // Delete one AuditChecklist
     * const AuditChecklist = await prisma.auditChecklist.delete({
     *   where: {
     *     // ... filter to delete one AuditChecklist
     *   }
     * })
     * 
     */
    delete<T extends AuditChecklistDeleteArgs>(args: SelectSubset<T, AuditChecklistDeleteArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditChecklist.
     * @param {AuditChecklistUpdateArgs} args - Arguments to update one AuditChecklist.
     * @example
     * // Update one AuditChecklist
     * const auditChecklist = await prisma.auditChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditChecklistUpdateArgs>(args: SelectSubset<T, AuditChecklistUpdateArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditChecklists.
     * @param {AuditChecklistDeleteManyArgs} args - Arguments to filter AuditChecklists to delete.
     * @example
     * // Delete a few AuditChecklists
     * const { count } = await prisma.auditChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditChecklistDeleteManyArgs>(args?: SelectSubset<T, AuditChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditChecklists
     * const auditChecklist = await prisma.auditChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditChecklistUpdateManyArgs>(args: SelectSubset<T, AuditChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditChecklist.
     * @param {AuditChecklistUpsertArgs} args - Arguments to update or create a AuditChecklist.
     * @example
     * // Update or create a AuditChecklist
     * const auditChecklist = await prisma.auditChecklist.upsert({
     *   create: {
     *     // ... data to create a AuditChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditChecklist we want to update
     *   }
     * })
     */
    upsert<T extends AuditChecklistUpsertArgs>(args: SelectSubset<T, AuditChecklistUpsertArgs<ExtArgs>>): Prisma__AuditChecklistClient<$Result.GetResult<Prisma.$AuditChecklistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistCountArgs} args - Arguments to filter AuditChecklists to count.
     * @example
     * // Count the number of AuditChecklists
     * const count = await prisma.auditChecklist.count({
     *   where: {
     *     // ... the filter for the AuditChecklists we want to count
     *   }
     * })
    **/
    count<T extends AuditChecklistCountArgs>(
      args?: Subset<T, AuditChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditChecklistAggregateArgs>(args: Subset<T, AuditChecklistAggregateArgs>): Prisma.PrismaPromise<GetAuditChecklistAggregateType<T>>

    /**
     * Group by AuditChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditChecklistGroupByArgs['orderBy'] }
        : { orderBy?: AuditChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditChecklist model
   */
  readonly fields: AuditChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditProgram<T extends AuditProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditProgramDefaultArgs<ExtArgs>>): Prisma__AuditProgramClient<$Result.GetResult<Prisma.$AuditProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditChecklist model
   */ 
  interface AuditChecklistFieldRefs {
    readonly id: FieldRef<"AuditChecklist", 'String'>
    readonly auditProgramId: FieldRef<"AuditChecklist", 'String'>
    readonly clause: FieldRef<"AuditChecklist", 'String'>
    readonly item: FieldRef<"AuditChecklist", 'String'>
    readonly requirement: FieldRef<"AuditChecklist", 'String'>
    readonly evidenceType: FieldRef<"AuditChecklist", 'String'>
    readonly order: FieldRef<"AuditChecklist", 'Int'>
    readonly createdAt: FieldRef<"AuditChecklist", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditChecklist findUnique
   */
  export type AuditChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * Filter, which AuditChecklist to fetch.
     */
    where: AuditChecklistWhereUniqueInput
  }

  /**
   * AuditChecklist findUniqueOrThrow
   */
  export type AuditChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * Filter, which AuditChecklist to fetch.
     */
    where: AuditChecklistWhereUniqueInput
  }

  /**
   * AuditChecklist findFirst
   */
  export type AuditChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * Filter, which AuditChecklist to fetch.
     */
    where?: AuditChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditChecklists to fetch.
     */
    orderBy?: AuditChecklistOrderByWithRelationInput | AuditChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditChecklists.
     */
    cursor?: AuditChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditChecklists.
     */
    distinct?: AuditChecklistScalarFieldEnum | AuditChecklistScalarFieldEnum[]
  }

  /**
   * AuditChecklist findFirstOrThrow
   */
  export type AuditChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * Filter, which AuditChecklist to fetch.
     */
    where?: AuditChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditChecklists to fetch.
     */
    orderBy?: AuditChecklistOrderByWithRelationInput | AuditChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditChecklists.
     */
    cursor?: AuditChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditChecklists.
     */
    distinct?: AuditChecklistScalarFieldEnum | AuditChecklistScalarFieldEnum[]
  }

  /**
   * AuditChecklist findMany
   */
  export type AuditChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * Filter, which AuditChecklists to fetch.
     */
    where?: AuditChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditChecklists to fetch.
     */
    orderBy?: AuditChecklistOrderByWithRelationInput | AuditChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditChecklists.
     */
    cursor?: AuditChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditChecklists.
     */
    skip?: number
    distinct?: AuditChecklistScalarFieldEnum | AuditChecklistScalarFieldEnum[]
  }

  /**
   * AuditChecklist create
   */
  export type AuditChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditChecklist.
     */
    data: XOR<AuditChecklistCreateInput, AuditChecklistUncheckedCreateInput>
  }

  /**
   * AuditChecklist createMany
   */
  export type AuditChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditChecklists.
     */
    data: AuditChecklistCreateManyInput | AuditChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditChecklist createManyAndReturn
   */
  export type AuditChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditChecklists.
     */
    data: AuditChecklistCreateManyInput | AuditChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditChecklist update
   */
  export type AuditChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditChecklist.
     */
    data: XOR<AuditChecklistUpdateInput, AuditChecklistUncheckedUpdateInput>
    /**
     * Choose, which AuditChecklist to update.
     */
    where: AuditChecklistWhereUniqueInput
  }

  /**
   * AuditChecklist updateMany
   */
  export type AuditChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditChecklists.
     */
    data: XOR<AuditChecklistUpdateManyMutationInput, AuditChecklistUncheckedUpdateManyInput>
    /**
     * Filter which AuditChecklists to update
     */
    where?: AuditChecklistWhereInput
  }

  /**
   * AuditChecklist upsert
   */
  export type AuditChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditChecklist to update in case it exists.
     */
    where: AuditChecklistWhereUniqueInput
    /**
     * In case the AuditChecklist found by the `where` argument doesn't exist, create a new AuditChecklist with this data.
     */
    create: XOR<AuditChecklistCreateInput, AuditChecklistUncheckedCreateInput>
    /**
     * In case the AuditChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditChecklistUpdateInput, AuditChecklistUncheckedUpdateInput>
  }

  /**
   * AuditChecklist delete
   */
  export type AuditChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
    /**
     * Filter which AuditChecklist to delete.
     */
    where: AuditChecklistWhereUniqueInput
  }

  /**
   * AuditChecklist deleteMany
   */
  export type AuditChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditChecklists to delete
     */
    where?: AuditChecklistWhereInput
  }

  /**
   * AuditChecklist without action
   */
  export type AuditChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditChecklist
     */
    select?: AuditChecklistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditChecklistInclude<ExtArgs> | null
  }


  /**
   * Model ActionItem
   */

  export type AggregateActionItem = {
    _count: ActionItemCountAggregateOutputType | null
    _min: ActionItemMinAggregateOutputType | null
    _max: ActionItemMaxAggregateOutputType | null
  }

  export type ActionItemMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    origem: $Enums.ActionOrigin | null
    acaoRelacionada: string | null
    conformidade: $Enums.Conformidade | null
    numeroAssociado: string | null
    ambito: string | null
    descricao: string | null
    causaRaizIdentificada: string | null
    acaoCorretiva: string | null
    local: string | null
    responsavel: string | null
    inicio: Date | null
    termino: Date | null
    conclusao: Date | null
    status: $Enums.ActionStatus | null
    mes: string | null
    evidencia: string | null
    avaliacaoEficacia: string | null
    setor: string | null
    dataAbertura: Date | null
    dataLimite: Date | null
    dataConclusao: Date | null
    impacto: $Enums.Impact | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionItemMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    origem: $Enums.ActionOrigin | null
    acaoRelacionada: string | null
    conformidade: $Enums.Conformidade | null
    numeroAssociado: string | null
    ambito: string | null
    descricao: string | null
    causaRaizIdentificada: string | null
    acaoCorretiva: string | null
    local: string | null
    responsavel: string | null
    inicio: Date | null
    termino: Date | null
    conclusao: Date | null
    status: $Enums.ActionStatus | null
    mes: string | null
    evidencia: string | null
    avaliacaoEficacia: string | null
    setor: string | null
    dataAbertura: Date | null
    dataLimite: Date | null
    dataConclusao: Date | null
    impacto: $Enums.Impact | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionItemCountAggregateOutputType = {
    id: number
    tenantId: number
    origem: number
    acaoRelacionada: number
    conformidade: number
    numeroAssociado: number
    ambito: number
    descricao: number
    causaRaizIdentificada: number
    acaoCorretiva: number
    local: number
    responsavel: number
    inicio: number
    termino: number
    conclusao: number
    status: number
    mes: number
    evidencia: number
    avaliacaoEficacia: number
    setor: number
    dataAbertura: number
    dataLimite: number
    dataConclusao: number
    impacto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionItemMinAggregateInputType = {
    id?: true
    tenantId?: true
    origem?: true
    acaoRelacionada?: true
    conformidade?: true
    numeroAssociado?: true
    ambito?: true
    descricao?: true
    causaRaizIdentificada?: true
    acaoCorretiva?: true
    local?: true
    responsavel?: true
    inicio?: true
    termino?: true
    conclusao?: true
    status?: true
    mes?: true
    evidencia?: true
    avaliacaoEficacia?: true
    setor?: true
    dataAbertura?: true
    dataLimite?: true
    dataConclusao?: true
    impacto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionItemMaxAggregateInputType = {
    id?: true
    tenantId?: true
    origem?: true
    acaoRelacionada?: true
    conformidade?: true
    numeroAssociado?: true
    ambito?: true
    descricao?: true
    causaRaizIdentificada?: true
    acaoCorretiva?: true
    local?: true
    responsavel?: true
    inicio?: true
    termino?: true
    conclusao?: true
    status?: true
    mes?: true
    evidencia?: true
    avaliacaoEficacia?: true
    setor?: true
    dataAbertura?: true
    dataLimite?: true
    dataConclusao?: true
    impacto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionItemCountAggregateInputType = {
    id?: true
    tenantId?: true
    origem?: true
    acaoRelacionada?: true
    conformidade?: true
    numeroAssociado?: true
    ambito?: true
    descricao?: true
    causaRaizIdentificada?: true
    acaoCorretiva?: true
    local?: true
    responsavel?: true
    inicio?: true
    termino?: true
    conclusao?: true
    status?: true
    mes?: true
    evidencia?: true
    avaliacaoEficacia?: true
    setor?: true
    dataAbertura?: true
    dataLimite?: true
    dataConclusao?: true
    impacto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionItem to aggregate.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionItems
    **/
    _count?: true | ActionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionItemMaxAggregateInputType
  }

  export type GetActionItemAggregateType<T extends ActionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateActionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionItem[P]>
      : GetScalarType<T[P], AggregateActionItem[P]>
  }




  export type ActionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithAggregationInput | ActionItemOrderByWithAggregationInput[]
    by: ActionItemScalarFieldEnum[] | ActionItemScalarFieldEnum
    having?: ActionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionItemCountAggregateInputType | true
    _min?: ActionItemMinAggregateInputType
    _max?: ActionItemMaxAggregateInputType
  }

  export type ActionItemGroupByOutputType = {
    id: string
    tenantId: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade: $Enums.Conformidade | null
    numeroAssociado: string | null
    ambito: string | null
    descricao: string
    causaRaizIdentificada: string | null
    acaoCorretiva: string | null
    local: string | null
    responsavel: string | null
    inicio: Date | null
    termino: Date | null
    conclusao: Date | null
    status: $Enums.ActionStatus
    mes: string | null
    evidencia: string | null
    avaliacaoEficacia: string | null
    setor: string
    dataAbertura: Date
    dataLimite: Date
    dataConclusao: Date | null
    impacto: $Enums.Impact
    createdAt: Date
    updatedAt: Date
    _count: ActionItemCountAggregateOutputType | null
    _min: ActionItemMinAggregateOutputType | null
    _max: ActionItemMaxAggregateOutputType | null
  }

  type GetActionItemGroupByPayload<T extends ActionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionItemGroupByOutputType[P]>
            : GetScalarType<T[P], ActionItemGroupByOutputType[P]>
        }
      >
    >


  export type ActionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    origem?: boolean
    acaoRelacionada?: boolean
    conformidade?: boolean
    numeroAssociado?: boolean
    ambito?: boolean
    descricao?: boolean
    causaRaizIdentificada?: boolean
    acaoCorretiva?: boolean
    local?: boolean
    responsavel?: boolean
    inicio?: boolean
    termino?: boolean
    conclusao?: boolean
    status?: boolean
    mes?: boolean
    evidencia?: boolean
    avaliacaoEficacia?: boolean
    setor?: boolean
    dataAbertura?: boolean
    dataLimite?: boolean
    dataConclusao?: boolean
    impacto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    rootCauseAnalysis?: boolean | ActionItem$rootCauseAnalysisArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    origem?: boolean
    acaoRelacionada?: boolean
    conformidade?: boolean
    numeroAssociado?: boolean
    ambito?: boolean
    descricao?: boolean
    causaRaizIdentificada?: boolean
    acaoCorretiva?: boolean
    local?: boolean
    responsavel?: boolean
    inicio?: boolean
    termino?: boolean
    conclusao?: boolean
    status?: boolean
    mes?: boolean
    evidencia?: boolean
    avaliacaoEficacia?: boolean
    setor?: boolean
    dataAbertura?: boolean
    dataLimite?: boolean
    dataConclusao?: boolean
    impacto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectScalar = {
    id?: boolean
    tenantId?: boolean
    origem?: boolean
    acaoRelacionada?: boolean
    conformidade?: boolean
    numeroAssociado?: boolean
    ambito?: boolean
    descricao?: boolean
    causaRaizIdentificada?: boolean
    acaoCorretiva?: boolean
    local?: boolean
    responsavel?: boolean
    inicio?: boolean
    termino?: boolean
    conclusao?: boolean
    status?: boolean
    mes?: boolean
    evidencia?: boolean
    avaliacaoEficacia?: boolean
    setor?: boolean
    dataAbertura?: boolean
    dataLimite?: boolean
    dataConclusao?: boolean
    impacto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    rootCauseAnalysis?: boolean | ActionItem$rootCauseAnalysisArgs<ExtArgs>
  }
  export type ActionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ActionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      rootCauseAnalysis: Prisma.$RootCauseAnalysisPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      origem: $Enums.ActionOrigin
      acaoRelacionada: string
      conformidade: $Enums.Conformidade | null
      numeroAssociado: string | null
      ambito: string | null
      descricao: string
      causaRaizIdentificada: string | null
      acaoCorretiva: string | null
      local: string | null
      responsavel: string | null
      inicio: Date | null
      termino: Date | null
      conclusao: Date | null
      status: $Enums.ActionStatus
      mes: string | null
      evidencia: string | null
      avaliacaoEficacia: string | null
      setor: string
      dataAbertura: Date
      dataLimite: Date
      dataConclusao: Date | null
      impacto: $Enums.Impact
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actionItem"]>
    composites: {}
  }

  type ActionItemGetPayload<S extends boolean | null | undefined | ActionItemDefaultArgs> = $Result.GetResult<Prisma.$ActionItemPayload, S>

  type ActionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionItemCountAggregateInputType | true
    }

  export interface ActionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionItem'], meta: { name: 'ActionItem' } }
    /**
     * Find zero or one ActionItem that matches the filter.
     * @param {ActionItemFindUniqueArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionItemFindUniqueArgs>(args: SelectSubset<T, ActionItemFindUniqueArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActionItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionItemFindUniqueOrThrowArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindFirstArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionItemFindFirstArgs>(args?: SelectSubset<T, ActionItemFindFirstArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindFirstOrThrowArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionItems
     * const actionItems = await prisma.actionItem.findMany()
     * 
     * // Get first 10 ActionItems
     * const actionItems = await prisma.actionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionItemFindManyArgs>(args?: SelectSubset<T, ActionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActionItem.
     * @param {ActionItemCreateArgs} args - Arguments to create a ActionItem.
     * @example
     * // Create one ActionItem
     * const ActionItem = await prisma.actionItem.create({
     *   data: {
     *     // ... data to create a ActionItem
     *   }
     * })
     * 
     */
    create<T extends ActionItemCreateArgs>(args: SelectSubset<T, ActionItemCreateArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActionItems.
     * @param {ActionItemCreateManyArgs} args - Arguments to create many ActionItems.
     * @example
     * // Create many ActionItems
     * const actionItem = await prisma.actionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionItemCreateManyArgs>(args?: SelectSubset<T, ActionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionItems and returns the data saved in the database.
     * @param {ActionItemCreateManyAndReturnArgs} args - Arguments to create many ActionItems.
     * @example
     * // Create many ActionItems
     * const actionItem = await prisma.actionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionItems and only return the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActionItem.
     * @param {ActionItemDeleteArgs} args - Arguments to delete one ActionItem.
     * @example
     * // Delete one ActionItem
     * const ActionItem = await prisma.actionItem.delete({
     *   where: {
     *     // ... filter to delete one ActionItem
     *   }
     * })
     * 
     */
    delete<T extends ActionItemDeleteArgs>(args: SelectSubset<T, ActionItemDeleteArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActionItem.
     * @param {ActionItemUpdateArgs} args - Arguments to update one ActionItem.
     * @example
     * // Update one ActionItem
     * const actionItem = await prisma.actionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionItemUpdateArgs>(args: SelectSubset<T, ActionItemUpdateArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActionItems.
     * @param {ActionItemDeleteManyArgs} args - Arguments to filter ActionItems to delete.
     * @example
     * // Delete a few ActionItems
     * const { count } = await prisma.actionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionItemDeleteManyArgs>(args?: SelectSubset<T, ActionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionItems
     * const actionItem = await prisma.actionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionItemUpdateManyArgs>(args: SelectSubset<T, ActionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActionItem.
     * @param {ActionItemUpsertArgs} args - Arguments to update or create a ActionItem.
     * @example
     * // Update or create a ActionItem
     * const actionItem = await prisma.actionItem.upsert({
     *   create: {
     *     // ... data to create a ActionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionItem we want to update
     *   }
     * })
     */
    upsert<T extends ActionItemUpsertArgs>(args: SelectSubset<T, ActionItemUpsertArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemCountArgs} args - Arguments to filter ActionItems to count.
     * @example
     * // Count the number of ActionItems
     * const count = await prisma.actionItem.count({
     *   where: {
     *     // ... the filter for the ActionItems we want to count
     *   }
     * })
    **/
    count<T extends ActionItemCountArgs>(
      args?: Subset<T, ActionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionItemAggregateArgs>(args: Subset<T, ActionItemAggregateArgs>): Prisma.PrismaPromise<GetActionItemAggregateType<T>>

    /**
     * Group by ActionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionItemGroupByArgs['orderBy'] }
        : { orderBy?: ActionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionItem model
   */
  readonly fields: ActionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rootCauseAnalysis<T extends ActionItem$rootCauseAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, ActionItem$rootCauseAnalysisArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionItem model
   */ 
  interface ActionItemFieldRefs {
    readonly id: FieldRef<"ActionItem", 'String'>
    readonly tenantId: FieldRef<"ActionItem", 'String'>
    readonly origem: FieldRef<"ActionItem", 'ActionOrigin'>
    readonly acaoRelacionada: FieldRef<"ActionItem", 'String'>
    readonly conformidade: FieldRef<"ActionItem", 'Conformidade'>
    readonly numeroAssociado: FieldRef<"ActionItem", 'String'>
    readonly ambito: FieldRef<"ActionItem", 'String'>
    readonly descricao: FieldRef<"ActionItem", 'String'>
    readonly causaRaizIdentificada: FieldRef<"ActionItem", 'String'>
    readonly acaoCorretiva: FieldRef<"ActionItem", 'String'>
    readonly local: FieldRef<"ActionItem", 'String'>
    readonly responsavel: FieldRef<"ActionItem", 'String'>
    readonly inicio: FieldRef<"ActionItem", 'DateTime'>
    readonly termino: FieldRef<"ActionItem", 'DateTime'>
    readonly conclusao: FieldRef<"ActionItem", 'DateTime'>
    readonly status: FieldRef<"ActionItem", 'ActionStatus'>
    readonly mes: FieldRef<"ActionItem", 'String'>
    readonly evidencia: FieldRef<"ActionItem", 'String'>
    readonly avaliacaoEficacia: FieldRef<"ActionItem", 'String'>
    readonly setor: FieldRef<"ActionItem", 'String'>
    readonly dataAbertura: FieldRef<"ActionItem", 'DateTime'>
    readonly dataLimite: FieldRef<"ActionItem", 'DateTime'>
    readonly dataConclusao: FieldRef<"ActionItem", 'DateTime'>
    readonly impacto: FieldRef<"ActionItem", 'Impact'>
    readonly createdAt: FieldRef<"ActionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ActionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionItem findUnique
   */
  export type ActionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem findUniqueOrThrow
   */
  export type ActionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem findFirst
   */
  export type ActionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionItems.
     */
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem findFirstOrThrow
   */
  export type ActionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionItems.
     */
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem findMany
   */
  export type ActionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItems to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem create
   */
  export type ActionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionItem.
     */
    data: XOR<ActionItemCreateInput, ActionItemUncheckedCreateInput>
  }

  /**
   * ActionItem createMany
   */
  export type ActionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionItems.
     */
    data: ActionItemCreateManyInput | ActionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionItem createManyAndReturn
   */
  export type ActionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActionItems.
     */
    data: ActionItemCreateManyInput | ActionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionItem update
   */
  export type ActionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionItem.
     */
    data: XOR<ActionItemUpdateInput, ActionItemUncheckedUpdateInput>
    /**
     * Choose, which ActionItem to update.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem updateMany
   */
  export type ActionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionItems.
     */
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyInput>
    /**
     * Filter which ActionItems to update
     */
    where?: ActionItemWhereInput
  }

  /**
   * ActionItem upsert
   */
  export type ActionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionItem to update in case it exists.
     */
    where: ActionItemWhereUniqueInput
    /**
     * In case the ActionItem found by the `where` argument doesn't exist, create a new ActionItem with this data.
     */
    create: XOR<ActionItemCreateInput, ActionItemUncheckedCreateInput>
    /**
     * In case the ActionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionItemUpdateInput, ActionItemUncheckedUpdateInput>
  }

  /**
   * ActionItem delete
   */
  export type ActionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter which ActionItem to delete.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem deleteMany
   */
  export type ActionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionItems to delete
     */
    where?: ActionItemWhereInput
  }

  /**
   * ActionItem.rootCauseAnalysis
   */
  export type ActionItem$rootCauseAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    where?: RootCauseAnalysisWhereInput
  }

  /**
   * ActionItem without action
   */
  export type ActionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
  }


  /**
   * Model RootCauseAnalysis
   */

  export type AggregateRootCauseAnalysis = {
    _count: RootCauseAnalysisCountAggregateOutputType | null
    _min: RootCauseAnalysisMinAggregateOutputType | null
    _max: RootCauseAnalysisMaxAggregateOutputType | null
  }

  export type RootCauseAnalysisMinAggregateOutputType = {
    id: string | null
    actionItemId: string | null
    tenantId: string | null
    analysisType: $Enums.RootCauseAnalysisType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RootCauseAnalysisMaxAggregateOutputType = {
    id: string | null
    actionItemId: string | null
    tenantId: string | null
    analysisType: $Enums.RootCauseAnalysisType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RootCauseAnalysisCountAggregateOutputType = {
    id: number
    actionItemId: number
    tenantId: number
    analysisType: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RootCauseAnalysisMinAggregateInputType = {
    id?: true
    actionItemId?: true
    tenantId?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RootCauseAnalysisMaxAggregateInputType = {
    id?: true
    actionItemId?: true
    tenantId?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RootCauseAnalysisCountAggregateInputType = {
    id?: true
    actionItemId?: true
    tenantId?: true
    analysisType?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RootCauseAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RootCauseAnalysis to aggregate.
     */
    where?: RootCauseAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RootCauseAnalyses to fetch.
     */
    orderBy?: RootCauseAnalysisOrderByWithRelationInput | RootCauseAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RootCauseAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RootCauseAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RootCauseAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RootCauseAnalyses
    **/
    _count?: true | RootCauseAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RootCauseAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RootCauseAnalysisMaxAggregateInputType
  }

  export type GetRootCauseAnalysisAggregateType<T extends RootCauseAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateRootCauseAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRootCauseAnalysis[P]>
      : GetScalarType<T[P], AggregateRootCauseAnalysis[P]>
  }




  export type RootCauseAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RootCauseAnalysisWhereInput
    orderBy?: RootCauseAnalysisOrderByWithAggregationInput | RootCauseAnalysisOrderByWithAggregationInput[]
    by: RootCauseAnalysisScalarFieldEnum[] | RootCauseAnalysisScalarFieldEnum
    having?: RootCauseAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RootCauseAnalysisCountAggregateInputType | true
    _min?: RootCauseAnalysisMinAggregateInputType
    _max?: RootCauseAnalysisMaxAggregateInputType
  }

  export type RootCauseAnalysisGroupByOutputType = {
    id: string
    actionItemId: string
    tenantId: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: RootCauseAnalysisCountAggregateOutputType | null
    _min: RootCauseAnalysisMinAggregateOutputType | null
    _max: RootCauseAnalysisMaxAggregateOutputType | null
  }

  type GetRootCauseAnalysisGroupByPayload<T extends RootCauseAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RootCauseAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RootCauseAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RootCauseAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], RootCauseAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type RootCauseAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionItemId?: boolean
    tenantId?: boolean
    analysisType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionItem?: boolean | ActionItemDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rootCauseAnalysis"]>

  export type RootCauseAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionItemId?: boolean
    tenantId?: boolean
    analysisType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    actionItem?: boolean | ActionItemDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rootCauseAnalysis"]>

  export type RootCauseAnalysisSelectScalar = {
    id?: boolean
    actionItemId?: boolean
    tenantId?: boolean
    analysisType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RootCauseAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionItem?: boolean | ActionItemDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type RootCauseAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionItem?: boolean | ActionItemDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $RootCauseAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RootCauseAnalysis"
    objects: {
      actionItem: Prisma.$ActionItemPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actionItemId: string
      tenantId: string
      analysisType: $Enums.RootCauseAnalysisType
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rootCauseAnalysis"]>
    composites: {}
  }

  type RootCauseAnalysisGetPayload<S extends boolean | null | undefined | RootCauseAnalysisDefaultArgs> = $Result.GetResult<Prisma.$RootCauseAnalysisPayload, S>

  type RootCauseAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RootCauseAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RootCauseAnalysisCountAggregateInputType | true
    }

  export interface RootCauseAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RootCauseAnalysis'], meta: { name: 'RootCauseAnalysis' } }
    /**
     * Find zero or one RootCauseAnalysis that matches the filter.
     * @param {RootCauseAnalysisFindUniqueArgs} args - Arguments to find a RootCauseAnalysis
     * @example
     * // Get one RootCauseAnalysis
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RootCauseAnalysisFindUniqueArgs>(args: SelectSubset<T, RootCauseAnalysisFindUniqueArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RootCauseAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RootCauseAnalysisFindUniqueOrThrowArgs} args - Arguments to find a RootCauseAnalysis
     * @example
     * // Get one RootCauseAnalysis
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RootCauseAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, RootCauseAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RootCauseAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisFindFirstArgs} args - Arguments to find a RootCauseAnalysis
     * @example
     * // Get one RootCauseAnalysis
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RootCauseAnalysisFindFirstArgs>(args?: SelectSubset<T, RootCauseAnalysisFindFirstArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RootCauseAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisFindFirstOrThrowArgs} args - Arguments to find a RootCauseAnalysis
     * @example
     * // Get one RootCauseAnalysis
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RootCauseAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, RootCauseAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RootCauseAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RootCauseAnalyses
     * const rootCauseAnalyses = await prisma.rootCauseAnalysis.findMany()
     * 
     * // Get first 10 RootCauseAnalyses
     * const rootCauseAnalyses = await prisma.rootCauseAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rootCauseAnalysisWithIdOnly = await prisma.rootCauseAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RootCauseAnalysisFindManyArgs>(args?: SelectSubset<T, RootCauseAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RootCauseAnalysis.
     * @param {RootCauseAnalysisCreateArgs} args - Arguments to create a RootCauseAnalysis.
     * @example
     * // Create one RootCauseAnalysis
     * const RootCauseAnalysis = await prisma.rootCauseAnalysis.create({
     *   data: {
     *     // ... data to create a RootCauseAnalysis
     *   }
     * })
     * 
     */
    create<T extends RootCauseAnalysisCreateArgs>(args: SelectSubset<T, RootCauseAnalysisCreateArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RootCauseAnalyses.
     * @param {RootCauseAnalysisCreateManyArgs} args - Arguments to create many RootCauseAnalyses.
     * @example
     * // Create many RootCauseAnalyses
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RootCauseAnalysisCreateManyArgs>(args?: SelectSubset<T, RootCauseAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RootCauseAnalyses and returns the data saved in the database.
     * @param {RootCauseAnalysisCreateManyAndReturnArgs} args - Arguments to create many RootCauseAnalyses.
     * @example
     * // Create many RootCauseAnalyses
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RootCauseAnalyses and only return the `id`
     * const rootCauseAnalysisWithIdOnly = await prisma.rootCauseAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RootCauseAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, RootCauseAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RootCauseAnalysis.
     * @param {RootCauseAnalysisDeleteArgs} args - Arguments to delete one RootCauseAnalysis.
     * @example
     * // Delete one RootCauseAnalysis
     * const RootCauseAnalysis = await prisma.rootCauseAnalysis.delete({
     *   where: {
     *     // ... filter to delete one RootCauseAnalysis
     *   }
     * })
     * 
     */
    delete<T extends RootCauseAnalysisDeleteArgs>(args: SelectSubset<T, RootCauseAnalysisDeleteArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RootCauseAnalysis.
     * @param {RootCauseAnalysisUpdateArgs} args - Arguments to update one RootCauseAnalysis.
     * @example
     * // Update one RootCauseAnalysis
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RootCauseAnalysisUpdateArgs>(args: SelectSubset<T, RootCauseAnalysisUpdateArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RootCauseAnalyses.
     * @param {RootCauseAnalysisDeleteManyArgs} args - Arguments to filter RootCauseAnalyses to delete.
     * @example
     * // Delete a few RootCauseAnalyses
     * const { count } = await prisma.rootCauseAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RootCauseAnalysisDeleteManyArgs>(args?: SelectSubset<T, RootCauseAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RootCauseAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RootCauseAnalyses
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RootCauseAnalysisUpdateManyArgs>(args: SelectSubset<T, RootCauseAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RootCauseAnalysis.
     * @param {RootCauseAnalysisUpsertArgs} args - Arguments to update or create a RootCauseAnalysis.
     * @example
     * // Update or create a RootCauseAnalysis
     * const rootCauseAnalysis = await prisma.rootCauseAnalysis.upsert({
     *   create: {
     *     // ... data to create a RootCauseAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RootCauseAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends RootCauseAnalysisUpsertArgs>(args: SelectSubset<T, RootCauseAnalysisUpsertArgs<ExtArgs>>): Prisma__RootCauseAnalysisClient<$Result.GetResult<Prisma.$RootCauseAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RootCauseAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisCountArgs} args - Arguments to filter RootCauseAnalyses to count.
     * @example
     * // Count the number of RootCauseAnalyses
     * const count = await prisma.rootCauseAnalysis.count({
     *   where: {
     *     // ... the filter for the RootCauseAnalyses we want to count
     *   }
     * })
    **/
    count<T extends RootCauseAnalysisCountArgs>(
      args?: Subset<T, RootCauseAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RootCauseAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RootCauseAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RootCauseAnalysisAggregateArgs>(args: Subset<T, RootCauseAnalysisAggregateArgs>): Prisma.PrismaPromise<GetRootCauseAnalysisAggregateType<T>>

    /**
     * Group by RootCauseAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RootCauseAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RootCauseAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RootCauseAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: RootCauseAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RootCauseAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRootCauseAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RootCauseAnalysis model
   */
  readonly fields: RootCauseAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RootCauseAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RootCauseAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionItem<T extends ActionItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionItemDefaultArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RootCauseAnalysis model
   */ 
  interface RootCauseAnalysisFieldRefs {
    readonly id: FieldRef<"RootCauseAnalysis", 'String'>
    readonly actionItemId: FieldRef<"RootCauseAnalysis", 'String'>
    readonly tenantId: FieldRef<"RootCauseAnalysis", 'String'>
    readonly analysisType: FieldRef<"RootCauseAnalysis", 'RootCauseAnalysisType'>
    readonly data: FieldRef<"RootCauseAnalysis", 'Json'>
    readonly createdAt: FieldRef<"RootCauseAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"RootCauseAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RootCauseAnalysis findUnique
   */
  export type RootCauseAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which RootCauseAnalysis to fetch.
     */
    where: RootCauseAnalysisWhereUniqueInput
  }

  /**
   * RootCauseAnalysis findUniqueOrThrow
   */
  export type RootCauseAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which RootCauseAnalysis to fetch.
     */
    where: RootCauseAnalysisWhereUniqueInput
  }

  /**
   * RootCauseAnalysis findFirst
   */
  export type RootCauseAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which RootCauseAnalysis to fetch.
     */
    where?: RootCauseAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RootCauseAnalyses to fetch.
     */
    orderBy?: RootCauseAnalysisOrderByWithRelationInput | RootCauseAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RootCauseAnalyses.
     */
    cursor?: RootCauseAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RootCauseAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RootCauseAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RootCauseAnalyses.
     */
    distinct?: RootCauseAnalysisScalarFieldEnum | RootCauseAnalysisScalarFieldEnum[]
  }

  /**
   * RootCauseAnalysis findFirstOrThrow
   */
  export type RootCauseAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which RootCauseAnalysis to fetch.
     */
    where?: RootCauseAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RootCauseAnalyses to fetch.
     */
    orderBy?: RootCauseAnalysisOrderByWithRelationInput | RootCauseAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RootCauseAnalyses.
     */
    cursor?: RootCauseAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RootCauseAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RootCauseAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RootCauseAnalyses.
     */
    distinct?: RootCauseAnalysisScalarFieldEnum | RootCauseAnalysisScalarFieldEnum[]
  }

  /**
   * RootCauseAnalysis findMany
   */
  export type RootCauseAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which RootCauseAnalyses to fetch.
     */
    where?: RootCauseAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RootCauseAnalyses to fetch.
     */
    orderBy?: RootCauseAnalysisOrderByWithRelationInput | RootCauseAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RootCauseAnalyses.
     */
    cursor?: RootCauseAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RootCauseAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RootCauseAnalyses.
     */
    skip?: number
    distinct?: RootCauseAnalysisScalarFieldEnum | RootCauseAnalysisScalarFieldEnum[]
  }

  /**
   * RootCauseAnalysis create
   */
  export type RootCauseAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a RootCauseAnalysis.
     */
    data: XOR<RootCauseAnalysisCreateInput, RootCauseAnalysisUncheckedCreateInput>
  }

  /**
   * RootCauseAnalysis createMany
   */
  export type RootCauseAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RootCauseAnalyses.
     */
    data: RootCauseAnalysisCreateManyInput | RootCauseAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RootCauseAnalysis createManyAndReturn
   */
  export type RootCauseAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RootCauseAnalyses.
     */
    data: RootCauseAnalysisCreateManyInput | RootCauseAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RootCauseAnalysis update
   */
  export type RootCauseAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a RootCauseAnalysis.
     */
    data: XOR<RootCauseAnalysisUpdateInput, RootCauseAnalysisUncheckedUpdateInput>
    /**
     * Choose, which RootCauseAnalysis to update.
     */
    where: RootCauseAnalysisWhereUniqueInput
  }

  /**
   * RootCauseAnalysis updateMany
   */
  export type RootCauseAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RootCauseAnalyses.
     */
    data: XOR<RootCauseAnalysisUpdateManyMutationInput, RootCauseAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which RootCauseAnalyses to update
     */
    where?: RootCauseAnalysisWhereInput
  }

  /**
   * RootCauseAnalysis upsert
   */
  export type RootCauseAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the RootCauseAnalysis to update in case it exists.
     */
    where: RootCauseAnalysisWhereUniqueInput
    /**
     * In case the RootCauseAnalysis found by the `where` argument doesn't exist, create a new RootCauseAnalysis with this data.
     */
    create: XOR<RootCauseAnalysisCreateInput, RootCauseAnalysisUncheckedCreateInput>
    /**
     * In case the RootCauseAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RootCauseAnalysisUpdateInput, RootCauseAnalysisUncheckedUpdateInput>
  }

  /**
   * RootCauseAnalysis delete
   */
  export type RootCauseAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
    /**
     * Filter which RootCauseAnalysis to delete.
     */
    where: RootCauseAnalysisWhereUniqueInput
  }

  /**
   * RootCauseAnalysis deleteMany
   */
  export type RootCauseAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RootCauseAnalyses to delete
     */
    where?: RootCauseAnalysisWhereInput
  }

  /**
   * RootCauseAnalysis without action
   */
  export type RootCauseAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RootCauseAnalysis
     */
    select?: RootCauseAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RootCauseAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Occurrence
   */

  export type AggregateOccurrence = {
    _count: OccurrenceCountAggregateOutputType | null
    _min: OccurrenceMinAggregateOutputType | null
    _max: OccurrenceMaxAggregateOutputType | null
  }

  export type OccurrenceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tipo: $Enums.OccurrenceType | null
    setor: string | null
    responsavel: string | null
    data: Date | null
    descricao: string | null
    resolucao: string | null
    gravidade: $Enums.OccurrenceSeverity | null
    acaoGerada: string | null
    status: $Enums.OccurrenceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OccurrenceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tipo: $Enums.OccurrenceType | null
    setor: string | null
    responsavel: string | null
    data: Date | null
    descricao: string | null
    resolucao: string | null
    gravidade: $Enums.OccurrenceSeverity | null
    acaoGerada: string | null
    status: $Enums.OccurrenceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OccurrenceCountAggregateOutputType = {
    id: number
    tenantId: number
    tipo: number
    setor: number
    departamentosAtingidos: number
    responsavel: number
    data: number
    descricao: number
    resolucao: number
    gravidade: number
    acaoGerada: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OccurrenceMinAggregateInputType = {
    id?: true
    tenantId?: true
    tipo?: true
    setor?: true
    responsavel?: true
    data?: true
    descricao?: true
    resolucao?: true
    gravidade?: true
    acaoGerada?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OccurrenceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tipo?: true
    setor?: true
    responsavel?: true
    data?: true
    descricao?: true
    resolucao?: true
    gravidade?: true
    acaoGerada?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OccurrenceCountAggregateInputType = {
    id?: true
    tenantId?: true
    tipo?: true
    setor?: true
    departamentosAtingidos?: true
    responsavel?: true
    data?: true
    descricao?: true
    resolucao?: true
    gravidade?: true
    acaoGerada?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OccurrenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occurrence to aggregate.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Occurrences
    **/
    _count?: true | OccurrenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccurrenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccurrenceMaxAggregateInputType
  }

  export type GetOccurrenceAggregateType<T extends OccurrenceAggregateArgs> = {
        [P in keyof T & keyof AggregateOccurrence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccurrence[P]>
      : GetScalarType<T[P], AggregateOccurrence[P]>
  }




  export type OccurrenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccurrenceWhereInput
    orderBy?: OccurrenceOrderByWithAggregationInput | OccurrenceOrderByWithAggregationInput[]
    by: OccurrenceScalarFieldEnum[] | OccurrenceScalarFieldEnum
    having?: OccurrenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccurrenceCountAggregateInputType | true
    _min?: OccurrenceMinAggregateInputType
    _max?: OccurrenceMaxAggregateInputType
  }

  export type OccurrenceGroupByOutputType = {
    id: string
    tenantId: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos: JsonValue
    responsavel: string
    data: Date
    descricao: string
    resolucao: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada: string | null
    status: $Enums.OccurrenceStatus
    createdAt: Date
    updatedAt: Date
    _count: OccurrenceCountAggregateOutputType | null
    _min: OccurrenceMinAggregateOutputType | null
    _max: OccurrenceMaxAggregateOutputType | null
  }

  type GetOccurrenceGroupByPayload<T extends OccurrenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccurrenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccurrenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccurrenceGroupByOutputType[P]>
            : GetScalarType<T[P], OccurrenceGroupByOutputType[P]>
        }
      >
    >


  export type OccurrenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tipo?: boolean
    setor?: boolean
    departamentosAtingidos?: boolean
    responsavel?: boolean
    data?: boolean
    descricao?: boolean
    resolucao?: boolean
    gravidade?: boolean
    acaoGerada?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occurrence"]>

  export type OccurrenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tipo?: boolean
    setor?: boolean
    departamentosAtingidos?: boolean
    responsavel?: boolean
    data?: boolean
    descricao?: boolean
    resolucao?: boolean
    gravidade?: boolean
    acaoGerada?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occurrence"]>

  export type OccurrenceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tipo?: boolean
    setor?: boolean
    departamentosAtingidos?: boolean
    responsavel?: boolean
    data?: boolean
    descricao?: boolean
    resolucao?: boolean
    gravidade?: boolean
    acaoGerada?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OccurrenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type OccurrenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $OccurrencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Occurrence"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tipo: $Enums.OccurrenceType
      setor: string
      departamentosAtingidos: Prisma.JsonValue
      responsavel: string
      data: Date
      descricao: string
      resolucao: string | null
      gravidade: $Enums.OccurrenceSeverity
      acaoGerada: string | null
      status: $Enums.OccurrenceStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["occurrence"]>
    composites: {}
  }

  type OccurrenceGetPayload<S extends boolean | null | undefined | OccurrenceDefaultArgs> = $Result.GetResult<Prisma.$OccurrencePayload, S>

  type OccurrenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OccurrenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OccurrenceCountAggregateInputType | true
    }

  export interface OccurrenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Occurrence'], meta: { name: 'Occurrence' } }
    /**
     * Find zero or one Occurrence that matches the filter.
     * @param {OccurrenceFindUniqueArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OccurrenceFindUniqueArgs>(args: SelectSubset<T, OccurrenceFindUniqueArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Occurrence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OccurrenceFindUniqueOrThrowArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OccurrenceFindUniqueOrThrowArgs>(args: SelectSubset<T, OccurrenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Occurrence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceFindFirstArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OccurrenceFindFirstArgs>(args?: SelectSubset<T, OccurrenceFindFirstArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Occurrence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceFindFirstOrThrowArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OccurrenceFindFirstOrThrowArgs>(args?: SelectSubset<T, OccurrenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Occurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Occurrences
     * const occurrences = await prisma.occurrence.findMany()
     * 
     * // Get first 10 Occurrences
     * const occurrences = await prisma.occurrence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const occurrenceWithIdOnly = await prisma.occurrence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OccurrenceFindManyArgs>(args?: SelectSubset<T, OccurrenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Occurrence.
     * @param {OccurrenceCreateArgs} args - Arguments to create a Occurrence.
     * @example
     * // Create one Occurrence
     * const Occurrence = await prisma.occurrence.create({
     *   data: {
     *     // ... data to create a Occurrence
     *   }
     * })
     * 
     */
    create<T extends OccurrenceCreateArgs>(args: SelectSubset<T, OccurrenceCreateArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Occurrences.
     * @param {OccurrenceCreateManyArgs} args - Arguments to create many Occurrences.
     * @example
     * // Create many Occurrences
     * const occurrence = await prisma.occurrence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OccurrenceCreateManyArgs>(args?: SelectSubset<T, OccurrenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Occurrences and returns the data saved in the database.
     * @param {OccurrenceCreateManyAndReturnArgs} args - Arguments to create many Occurrences.
     * @example
     * // Create many Occurrences
     * const occurrence = await prisma.occurrence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Occurrences and only return the `id`
     * const occurrenceWithIdOnly = await prisma.occurrence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OccurrenceCreateManyAndReturnArgs>(args?: SelectSubset<T, OccurrenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Occurrence.
     * @param {OccurrenceDeleteArgs} args - Arguments to delete one Occurrence.
     * @example
     * // Delete one Occurrence
     * const Occurrence = await prisma.occurrence.delete({
     *   where: {
     *     // ... filter to delete one Occurrence
     *   }
     * })
     * 
     */
    delete<T extends OccurrenceDeleteArgs>(args: SelectSubset<T, OccurrenceDeleteArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Occurrence.
     * @param {OccurrenceUpdateArgs} args - Arguments to update one Occurrence.
     * @example
     * // Update one Occurrence
     * const occurrence = await prisma.occurrence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OccurrenceUpdateArgs>(args: SelectSubset<T, OccurrenceUpdateArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Occurrences.
     * @param {OccurrenceDeleteManyArgs} args - Arguments to filter Occurrences to delete.
     * @example
     * // Delete a few Occurrences
     * const { count } = await prisma.occurrence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OccurrenceDeleteManyArgs>(args?: SelectSubset<T, OccurrenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Occurrences
     * const occurrence = await prisma.occurrence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OccurrenceUpdateManyArgs>(args: SelectSubset<T, OccurrenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Occurrence.
     * @param {OccurrenceUpsertArgs} args - Arguments to update or create a Occurrence.
     * @example
     * // Update or create a Occurrence
     * const occurrence = await prisma.occurrence.upsert({
     *   create: {
     *     // ... data to create a Occurrence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Occurrence we want to update
     *   }
     * })
     */
    upsert<T extends OccurrenceUpsertArgs>(args: SelectSubset<T, OccurrenceUpsertArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Occurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceCountArgs} args - Arguments to filter Occurrences to count.
     * @example
     * // Count the number of Occurrences
     * const count = await prisma.occurrence.count({
     *   where: {
     *     // ... the filter for the Occurrences we want to count
     *   }
     * })
    **/
    count<T extends OccurrenceCountArgs>(
      args?: Subset<T, OccurrenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccurrenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Occurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccurrenceAggregateArgs>(args: Subset<T, OccurrenceAggregateArgs>): Prisma.PrismaPromise<GetOccurrenceAggregateType<T>>

    /**
     * Group by Occurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OccurrenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OccurrenceGroupByArgs['orderBy'] }
        : { orderBy?: OccurrenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OccurrenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccurrenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Occurrence model
   */
  readonly fields: OccurrenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Occurrence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OccurrenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Occurrence model
   */ 
  interface OccurrenceFieldRefs {
    readonly id: FieldRef<"Occurrence", 'String'>
    readonly tenantId: FieldRef<"Occurrence", 'String'>
    readonly tipo: FieldRef<"Occurrence", 'OccurrenceType'>
    readonly setor: FieldRef<"Occurrence", 'String'>
    readonly departamentosAtingidos: FieldRef<"Occurrence", 'Json'>
    readonly responsavel: FieldRef<"Occurrence", 'String'>
    readonly data: FieldRef<"Occurrence", 'DateTime'>
    readonly descricao: FieldRef<"Occurrence", 'String'>
    readonly resolucao: FieldRef<"Occurrence", 'String'>
    readonly gravidade: FieldRef<"Occurrence", 'OccurrenceSeverity'>
    readonly acaoGerada: FieldRef<"Occurrence", 'String'>
    readonly status: FieldRef<"Occurrence", 'OccurrenceStatus'>
    readonly createdAt: FieldRef<"Occurrence", 'DateTime'>
    readonly updatedAt: FieldRef<"Occurrence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Occurrence findUnique
   */
  export type OccurrenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence findUniqueOrThrow
   */
  export type OccurrenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence findFirst
   */
  export type OccurrenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occurrences.
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occurrences.
     */
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Occurrence findFirstOrThrow
   */
  export type OccurrenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occurrences.
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occurrences.
     */
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Occurrence findMany
   */
  export type OccurrenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrences to fetch.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Occurrences.
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Occurrence create
   */
  export type OccurrenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Occurrence.
     */
    data: XOR<OccurrenceCreateInput, OccurrenceUncheckedCreateInput>
  }

  /**
   * Occurrence createMany
   */
  export type OccurrenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Occurrences.
     */
    data: OccurrenceCreateManyInput | OccurrenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Occurrence createManyAndReturn
   */
  export type OccurrenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Occurrences.
     */
    data: OccurrenceCreateManyInput | OccurrenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Occurrence update
   */
  export type OccurrenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Occurrence.
     */
    data: XOR<OccurrenceUpdateInput, OccurrenceUncheckedUpdateInput>
    /**
     * Choose, which Occurrence to update.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence updateMany
   */
  export type OccurrenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Occurrences.
     */
    data: XOR<OccurrenceUpdateManyMutationInput, OccurrenceUncheckedUpdateManyInput>
    /**
     * Filter which Occurrences to update
     */
    where?: OccurrenceWhereInput
  }

  /**
   * Occurrence upsert
   */
  export type OccurrenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Occurrence to update in case it exists.
     */
    where: OccurrenceWhereUniqueInput
    /**
     * In case the Occurrence found by the `where` argument doesn't exist, create a new Occurrence with this data.
     */
    create: XOR<OccurrenceCreateInput, OccurrenceUncheckedCreateInput>
    /**
     * In case the Occurrence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OccurrenceUpdateInput, OccurrenceUncheckedUpdateInput>
  }

  /**
   * Occurrence delete
   */
  export type OccurrenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter which Occurrence to delete.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence deleteMany
   */
  export type OccurrenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occurrences to delete
     */
    where?: OccurrenceWhereInput
  }

  /**
   * Occurrence without action
   */
  export type OccurrenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
  }


  /**
   * Model Sector
   */

  export type AggregateSector = {
    _count: SectorCountAggregateOutputType | null
    _min: SectorMinAggregateOutputType | null
    _max: SectorMaxAggregateOutputType | null
  }

  export type SectorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    nome: string | null
    responsavel: string | null
    email: string | null
    telefone: string | null
    descricao: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    nome: string | null
    responsavel: string | null
    email: string | null
    telefone: string | null
    descricao: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorCountAggregateOutputType = {
    id: number
    tenantId: number
    nome: number
    responsavel: number
    email: number
    telefone: number
    descricao: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectorMinAggregateInputType = {
    id?: true
    tenantId?: true
    nome?: true
    responsavel?: true
    email?: true
    telefone?: true
    descricao?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    nome?: true
    responsavel?: true
    email?: true
    telefone?: true
    descricao?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorCountAggregateInputType = {
    id?: true
    tenantId?: true
    nome?: true
    responsavel?: true
    email?: true
    telefone?: true
    descricao?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sector to aggregate.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sectors
    **/
    _count?: true | SectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectorMaxAggregateInputType
  }

  export type GetSectorAggregateType<T extends SectorAggregateArgs> = {
        [P in keyof T & keyof AggregateSector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSector[P]>
      : GetScalarType<T[P], AggregateSector[P]>
  }




  export type SectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectorWhereInput
    orderBy?: SectorOrderByWithAggregationInput | SectorOrderByWithAggregationInput[]
    by: SectorScalarFieldEnum[] | SectorScalarFieldEnum
    having?: SectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectorCountAggregateInputType | true
    _min?: SectorMinAggregateInputType
    _max?: SectorMaxAggregateInputType
  }

  export type SectorGroupByOutputType = {
    id: string
    tenantId: string
    nome: string
    responsavel: string
    email: string | null
    telefone: string | null
    descricao: string | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: SectorCountAggregateOutputType | null
    _min: SectorMinAggregateOutputType | null
    _max: SectorMaxAggregateOutputType | null
  }

  type GetSectorGroupByPayload<T extends SectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectorGroupByOutputType[P]>
            : GetScalarType<T[P], SectorGroupByOutputType[P]>
        }
      >
    >


  export type SectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    nome?: boolean
    responsavel?: boolean
    email?: boolean
    telefone?: boolean
    descricao?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sector"]>

  export type SectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    nome?: boolean
    responsavel?: boolean
    email?: boolean
    telefone?: boolean
    descricao?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sector"]>

  export type SectorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    nome?: boolean
    responsavel?: boolean
    email?: boolean
    telefone?: boolean
    descricao?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SectorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sector"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      nome: string
      responsavel: string
      email: string | null
      telefone: string | null
      descricao: string | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sector"]>
    composites: {}
  }

  type SectorGetPayload<S extends boolean | null | undefined | SectorDefaultArgs> = $Result.GetResult<Prisma.$SectorPayload, S>

  type SectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectorCountAggregateInputType | true
    }

  export interface SectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sector'], meta: { name: 'Sector' } }
    /**
     * Find zero or one Sector that matches the filter.
     * @param {SectorFindUniqueArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectorFindUniqueArgs>(args: SelectSubset<T, SectorFindUniqueArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectorFindUniqueOrThrowArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectorFindUniqueOrThrowArgs>(args: SelectSubset<T, SectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindFirstArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectorFindFirstArgs>(args?: SelectSubset<T, SectorFindFirstArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindFirstOrThrowArgs} args - Arguments to find a Sector
     * @example
     * // Get one Sector
     * const sector = await prisma.sector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectorFindFirstOrThrowArgs>(args?: SelectSubset<T, SectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sectors
     * const sectors = await prisma.sector.findMany()
     * 
     * // Get first 10 Sectors
     * const sectors = await prisma.sector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorWithIdOnly = await prisma.sector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectorFindManyArgs>(args?: SelectSubset<T, SectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sector.
     * @param {SectorCreateArgs} args - Arguments to create a Sector.
     * @example
     * // Create one Sector
     * const Sector = await prisma.sector.create({
     *   data: {
     *     // ... data to create a Sector
     *   }
     * })
     * 
     */
    create<T extends SectorCreateArgs>(args: SelectSubset<T, SectorCreateArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sectors.
     * @param {SectorCreateManyArgs} args - Arguments to create many Sectors.
     * @example
     * // Create many Sectors
     * const sector = await prisma.sector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectorCreateManyArgs>(args?: SelectSubset<T, SectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sectors and returns the data saved in the database.
     * @param {SectorCreateManyAndReturnArgs} args - Arguments to create many Sectors.
     * @example
     * // Create many Sectors
     * const sector = await prisma.sector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sectors and only return the `id`
     * const sectorWithIdOnly = await prisma.sector.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectorCreateManyAndReturnArgs>(args?: SelectSubset<T, SectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sector.
     * @param {SectorDeleteArgs} args - Arguments to delete one Sector.
     * @example
     * // Delete one Sector
     * const Sector = await prisma.sector.delete({
     *   where: {
     *     // ... filter to delete one Sector
     *   }
     * })
     * 
     */
    delete<T extends SectorDeleteArgs>(args: SelectSubset<T, SectorDeleteArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sector.
     * @param {SectorUpdateArgs} args - Arguments to update one Sector.
     * @example
     * // Update one Sector
     * const sector = await prisma.sector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectorUpdateArgs>(args: SelectSubset<T, SectorUpdateArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sectors.
     * @param {SectorDeleteManyArgs} args - Arguments to filter Sectors to delete.
     * @example
     * // Delete a few Sectors
     * const { count } = await prisma.sector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectorDeleteManyArgs>(args?: SelectSubset<T, SectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sectors
     * const sector = await prisma.sector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectorUpdateManyArgs>(args: SelectSubset<T, SectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sector.
     * @param {SectorUpsertArgs} args - Arguments to update or create a Sector.
     * @example
     * // Update or create a Sector
     * const sector = await prisma.sector.upsert({
     *   create: {
     *     // ... data to create a Sector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sector we want to update
     *   }
     * })
     */
    upsert<T extends SectorUpsertArgs>(args: SelectSubset<T, SectorUpsertArgs<ExtArgs>>): Prisma__SectorClient<$Result.GetResult<Prisma.$SectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorCountArgs} args - Arguments to filter Sectors to count.
     * @example
     * // Count the number of Sectors
     * const count = await prisma.sector.count({
     *   where: {
     *     // ... the filter for the Sectors we want to count
     *   }
     * })
    **/
    count<T extends SectorCountArgs>(
      args?: Subset<T, SectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorAggregateArgs>(args: Subset<T, SectorAggregateArgs>): Prisma.PrismaPromise<GetSectorAggregateType<T>>

    /**
     * Group by Sector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectorGroupByArgs['orderBy'] }
        : { orderBy?: SectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sector model
   */
  readonly fields: SectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sector model
   */ 
  interface SectorFieldRefs {
    readonly id: FieldRef<"Sector", 'String'>
    readonly tenantId: FieldRef<"Sector", 'String'>
    readonly nome: FieldRef<"Sector", 'String'>
    readonly responsavel: FieldRef<"Sector", 'String'>
    readonly email: FieldRef<"Sector", 'String'>
    readonly telefone: FieldRef<"Sector", 'String'>
    readonly descricao: FieldRef<"Sector", 'String'>
    readonly ativo: FieldRef<"Sector", 'Boolean'>
    readonly createdAt: FieldRef<"Sector", 'DateTime'>
    readonly updatedAt: FieldRef<"Sector", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sector findUnique
   */
  export type SectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector findUniqueOrThrow
   */
  export type SectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector findFirst
   */
  export type SectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     */
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector findFirstOrThrow
   */
  export type SectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sector to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     */
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector findMany
   */
  export type SectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter, which Sectors to fetch.
     */
    where?: SectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     */
    orderBy?: SectorOrderByWithRelationInput | SectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sectors.
     */
    cursor?: SectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     */
    skip?: number
    distinct?: SectorScalarFieldEnum | SectorScalarFieldEnum[]
  }

  /**
   * Sector create
   */
  export type SectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sector.
     */
    data: XOR<SectorCreateInput, SectorUncheckedCreateInput>
  }

  /**
   * Sector createMany
   */
  export type SectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sectors.
     */
    data: SectorCreateManyInput | SectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sector createManyAndReturn
   */
  export type SectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sectors.
     */
    data: SectorCreateManyInput | SectorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sector update
   */
  export type SectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sector.
     */
    data: XOR<SectorUpdateInput, SectorUncheckedUpdateInput>
    /**
     * Choose, which Sector to update.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector updateMany
   */
  export type SectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sectors.
     */
    data: XOR<SectorUpdateManyMutationInput, SectorUncheckedUpdateManyInput>
    /**
     * Filter which Sectors to update
     */
    where?: SectorWhereInput
  }

  /**
   * Sector upsert
   */
  export type SectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sector to update in case it exists.
     */
    where: SectorWhereUniqueInput
    /**
     * In case the Sector found by the `where` argument doesn't exist, create a new Sector with this data.
     */
    create: XOR<SectorCreateInput, SectorUncheckedCreateInput>
    /**
     * In case the Sector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectorUpdateInput, SectorUncheckedUpdateInput>
  }

  /**
   * Sector delete
   */
  export type SectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
    /**
     * Filter which Sector to delete.
     */
    where: SectorWhereUniqueInput
  }

  /**
   * Sector deleteMany
   */
  export type SectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sectors to delete
     */
    where?: SectorWhereInput
  }

  /**
   * Sector without action
   */
  export type SectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sector
     */
    select?: SectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectorInclude<ExtArgs> | null
  }


  /**
   * Model ImportLog
   */

  export type AggregateImportLog = {
    _count: ImportLogCountAggregateOutputType | null
    _avg: ImportLogAvgAggregateOutputType | null
    _sum: ImportLogSumAggregateOutputType | null
    _min: ImportLogMinAggregateOutputType | null
    _max: ImportLogMaxAggregateOutputType | null
  }

  export type ImportLogAvgAggregateOutputType = {
    totalRecords: number | null
  }

  export type ImportLogSumAggregateOutputType = {
    totalRecords: number | null
  }

  export type ImportLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    fileName: string | null
    mode: string | null
    entity: string | null
    status: $Enums.ImportStatus | null
    totalRecords: number | null
    createdAt: Date | null
    finishedAt: Date | null
    errorMessage: string | null
  }

  export type ImportLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    fileName: string | null
    mode: string | null
    entity: string | null
    status: $Enums.ImportStatus | null
    totalRecords: number | null
    createdAt: Date | null
    finishedAt: Date | null
    errorMessage: string | null
  }

  export type ImportLogCountAggregateOutputType = {
    id: number
    tenantId: number
    fileName: number
    mode: number
    entity: number
    status: number
    totalRecords: number
    createdAt: number
    finishedAt: number
    errorMessage: number
    _all: number
  }


  export type ImportLogAvgAggregateInputType = {
    totalRecords?: true
  }

  export type ImportLogSumAggregateInputType = {
    totalRecords?: true
  }

  export type ImportLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    fileName?: true
    mode?: true
    entity?: true
    status?: true
    totalRecords?: true
    createdAt?: true
    finishedAt?: true
    errorMessage?: true
  }

  export type ImportLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    fileName?: true
    mode?: true
    entity?: true
    status?: true
    totalRecords?: true
    createdAt?: true
    finishedAt?: true
    errorMessage?: true
  }

  export type ImportLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    fileName?: true
    mode?: true
    entity?: true
    status?: true
    totalRecords?: true
    createdAt?: true
    finishedAt?: true
    errorMessage?: true
    _all?: true
  }

  export type ImportLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportLog to aggregate.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportLogs
    **/
    _count?: true | ImportLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportLogMaxAggregateInputType
  }

  export type GetImportLogAggregateType<T extends ImportLogAggregateArgs> = {
        [P in keyof T & keyof AggregateImportLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportLog[P]>
      : GetScalarType<T[P], AggregateImportLog[P]>
  }




  export type ImportLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportLogWhereInput
    orderBy?: ImportLogOrderByWithAggregationInput | ImportLogOrderByWithAggregationInput[]
    by: ImportLogScalarFieldEnum[] | ImportLogScalarFieldEnum
    having?: ImportLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportLogCountAggregateInputType | true
    _avg?: ImportLogAvgAggregateInputType
    _sum?: ImportLogSumAggregateInputType
    _min?: ImportLogMinAggregateInputType
    _max?: ImportLogMaxAggregateInputType
  }

  export type ImportLogGroupByOutputType = {
    id: string
    tenantId: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt: Date
    finishedAt: Date | null
    errorMessage: string | null
    _count: ImportLogCountAggregateOutputType | null
    _avg: ImportLogAvgAggregateOutputType | null
    _sum: ImportLogSumAggregateOutputType | null
    _min: ImportLogMinAggregateOutputType | null
    _max: ImportLogMaxAggregateOutputType | null
  }

  type GetImportLogGroupByPayload<T extends ImportLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportLogGroupByOutputType[P]>
            : GetScalarType<T[P], ImportLogGroupByOutputType[P]>
        }
      >
    >


  export type ImportLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fileName?: boolean
    mode?: boolean
    entity?: boolean
    status?: boolean
    totalRecords?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    errorMessage?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importLog"]>

  export type ImportLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fileName?: boolean
    mode?: boolean
    entity?: boolean
    status?: boolean
    totalRecords?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    errorMessage?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importLog"]>

  export type ImportLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    fileName?: boolean
    mode?: boolean
    entity?: boolean
    status?: boolean
    totalRecords?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    errorMessage?: boolean
  }

  export type ImportLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ImportLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ImportLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      fileName: string
      mode: string
      entity: string
      status: $Enums.ImportStatus
      totalRecords: number
      createdAt: Date
      finishedAt: Date | null
      errorMessage: string | null
    }, ExtArgs["result"]["importLog"]>
    composites: {}
  }

  type ImportLogGetPayload<S extends boolean | null | undefined | ImportLogDefaultArgs> = $Result.GetResult<Prisma.$ImportLogPayload, S>

  type ImportLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportLogCountAggregateInputType | true
    }

  export interface ImportLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportLog'], meta: { name: 'ImportLog' } }
    /**
     * Find zero or one ImportLog that matches the filter.
     * @param {ImportLogFindUniqueArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportLogFindUniqueArgs>(args: SelectSubset<T, ImportLogFindUniqueArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportLogFindUniqueOrThrowArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogFindFirstArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportLogFindFirstArgs>(args?: SelectSubset<T, ImportLogFindFirstArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogFindFirstOrThrowArgs} args - Arguments to find a ImportLog
     * @example
     * // Get one ImportLog
     * const importLog = await prisma.importLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportLogs
     * const importLogs = await prisma.importLog.findMany()
     * 
     * // Get first 10 ImportLogs
     * const importLogs = await prisma.importLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importLogWithIdOnly = await prisma.importLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportLogFindManyArgs>(args?: SelectSubset<T, ImportLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportLog.
     * @param {ImportLogCreateArgs} args - Arguments to create a ImportLog.
     * @example
     * // Create one ImportLog
     * const ImportLog = await prisma.importLog.create({
     *   data: {
     *     // ... data to create a ImportLog
     *   }
     * })
     * 
     */
    create<T extends ImportLogCreateArgs>(args: SelectSubset<T, ImportLogCreateArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportLogs.
     * @param {ImportLogCreateManyArgs} args - Arguments to create many ImportLogs.
     * @example
     * // Create many ImportLogs
     * const importLog = await prisma.importLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportLogCreateManyArgs>(args?: SelectSubset<T, ImportLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportLogs and returns the data saved in the database.
     * @param {ImportLogCreateManyAndReturnArgs} args - Arguments to create many ImportLogs.
     * @example
     * // Create many ImportLogs
     * const importLog = await prisma.importLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportLogs and only return the `id`
     * const importLogWithIdOnly = await prisma.importLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportLog.
     * @param {ImportLogDeleteArgs} args - Arguments to delete one ImportLog.
     * @example
     * // Delete one ImportLog
     * const ImportLog = await prisma.importLog.delete({
     *   where: {
     *     // ... filter to delete one ImportLog
     *   }
     * })
     * 
     */
    delete<T extends ImportLogDeleteArgs>(args: SelectSubset<T, ImportLogDeleteArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportLog.
     * @param {ImportLogUpdateArgs} args - Arguments to update one ImportLog.
     * @example
     * // Update one ImportLog
     * const importLog = await prisma.importLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportLogUpdateArgs>(args: SelectSubset<T, ImportLogUpdateArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportLogs.
     * @param {ImportLogDeleteManyArgs} args - Arguments to filter ImportLogs to delete.
     * @example
     * // Delete a few ImportLogs
     * const { count } = await prisma.importLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportLogDeleteManyArgs>(args?: SelectSubset<T, ImportLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportLogs
     * const importLog = await prisma.importLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportLogUpdateManyArgs>(args: SelectSubset<T, ImportLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportLog.
     * @param {ImportLogUpsertArgs} args - Arguments to update or create a ImportLog.
     * @example
     * // Update or create a ImportLog
     * const importLog = await prisma.importLog.upsert({
     *   create: {
     *     // ... data to create a ImportLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportLog we want to update
     *   }
     * })
     */
    upsert<T extends ImportLogUpsertArgs>(args: SelectSubset<T, ImportLogUpsertArgs<ExtArgs>>): Prisma__ImportLogClient<$Result.GetResult<Prisma.$ImportLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogCountArgs} args - Arguments to filter ImportLogs to count.
     * @example
     * // Count the number of ImportLogs
     * const count = await prisma.importLog.count({
     *   where: {
     *     // ... the filter for the ImportLogs we want to count
     *   }
     * })
    **/
    count<T extends ImportLogCountArgs>(
      args?: Subset<T, ImportLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportLogAggregateArgs>(args: Subset<T, ImportLogAggregateArgs>): Prisma.PrismaPromise<GetImportLogAggregateType<T>>

    /**
     * Group by ImportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportLogGroupByArgs['orderBy'] }
        : { orderBy?: ImportLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportLog model
   */
  readonly fields: ImportLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportLog model
   */ 
  interface ImportLogFieldRefs {
    readonly id: FieldRef<"ImportLog", 'String'>
    readonly tenantId: FieldRef<"ImportLog", 'String'>
    readonly fileName: FieldRef<"ImportLog", 'String'>
    readonly mode: FieldRef<"ImportLog", 'String'>
    readonly entity: FieldRef<"ImportLog", 'String'>
    readonly status: FieldRef<"ImportLog", 'ImportStatus'>
    readonly totalRecords: FieldRef<"ImportLog", 'Int'>
    readonly createdAt: FieldRef<"ImportLog", 'DateTime'>
    readonly finishedAt: FieldRef<"ImportLog", 'DateTime'>
    readonly errorMessage: FieldRef<"ImportLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImportLog findUnique
   */
  export type ImportLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog findUniqueOrThrow
   */
  export type ImportLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog findFirst
   */
  export type ImportLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportLogs.
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportLogs.
     */
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * ImportLog findFirstOrThrow
   */
  export type ImportLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLog to fetch.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportLogs.
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportLogs.
     */
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * ImportLog findMany
   */
  export type ImportLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter, which ImportLogs to fetch.
     */
    where?: ImportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportLogs to fetch.
     */
    orderBy?: ImportLogOrderByWithRelationInput | ImportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportLogs.
     */
    cursor?: ImportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportLogs.
     */
    skip?: number
    distinct?: ImportLogScalarFieldEnum | ImportLogScalarFieldEnum[]
  }

  /**
   * ImportLog create
   */
  export type ImportLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportLog.
     */
    data: XOR<ImportLogCreateInput, ImportLogUncheckedCreateInput>
  }

  /**
   * ImportLog createMany
   */
  export type ImportLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportLogs.
     */
    data: ImportLogCreateManyInput | ImportLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportLog createManyAndReturn
   */
  export type ImportLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportLogs.
     */
    data: ImportLogCreateManyInput | ImportLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportLog update
   */
  export type ImportLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportLog.
     */
    data: XOR<ImportLogUpdateInput, ImportLogUncheckedUpdateInput>
    /**
     * Choose, which ImportLog to update.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog updateMany
   */
  export type ImportLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportLogs.
     */
    data: XOR<ImportLogUpdateManyMutationInput, ImportLogUncheckedUpdateManyInput>
    /**
     * Filter which ImportLogs to update
     */
    where?: ImportLogWhereInput
  }

  /**
   * ImportLog upsert
   */
  export type ImportLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportLog to update in case it exists.
     */
    where: ImportLogWhereUniqueInput
    /**
     * In case the ImportLog found by the `where` argument doesn't exist, create a new ImportLog with this data.
     */
    create: XOR<ImportLogCreateInput, ImportLogUncheckedCreateInput>
    /**
     * In case the ImportLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportLogUpdateInput, ImportLogUncheckedUpdateInput>
  }

  /**
   * ImportLog delete
   */
  export type ImportLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
    /**
     * Filter which ImportLog to delete.
     */
    where: ImportLogWhereUniqueInput
  }

  /**
   * ImportLog deleteMany
   */
  export type ImportLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportLogs to delete
     */
    where?: ImportLogWhereInput
  }

  /**
   * ImportLog without action
   */
  export type ImportLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportLog
     */
    select?: ImportLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportLogInclude<ExtArgs> | null
  }


  /**
   * Model AuditTrail
   */

  export type AggregateAuditTrail = {
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  export type AuditTrailMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: $Enums.AuditAction | null
    entity: string | null
    entityId: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AuditTrailMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: $Enums.AuditAction | null
    entity: string | null
    entityId: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AuditTrailCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    entity: number
    entityId: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditTrailMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    description?: true
    createdAt?: true
  }

  export type AuditTrailMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    description?: true
    createdAt?: true
  }

  export type AuditTrailCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditTrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrail to aggregate.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditTrails
    **/
    _count?: true | AuditTrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditTrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditTrailMaxAggregateInputType
  }

  export type GetAuditTrailAggregateType<T extends AuditTrailAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditTrail[P]>
      : GetScalarType<T[P], AggregateAuditTrail[P]>
  }




  export type AuditTrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithAggregationInput | AuditTrailOrderByWithAggregationInput[]
    by: AuditTrailScalarFieldEnum[] | AuditTrailScalarFieldEnum
    having?: AuditTrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditTrailCountAggregateInputType | true
    _min?: AuditTrailMinAggregateInputType
    _max?: AuditTrailMaxAggregateInputType
  }

  export type AuditTrailGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    action: $Enums.AuditAction
    entity: string
    entityId: string | null
    description: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  type GetAuditTrailGroupByPayload<T extends AuditTrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditTrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditTrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
            : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
        }
      >
    >


  export type AuditTrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditTrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }
  export type AuditTrailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }

  export type $AuditTrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditTrail"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      action: $Enums.AuditAction
      entity: string
      entityId: string | null
      description: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditTrail"]>
    composites: {}
  }

  type AuditTrailGetPayload<S extends boolean | null | undefined | AuditTrailDefaultArgs> = $Result.GetResult<Prisma.$AuditTrailPayload, S>

  type AuditTrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditTrailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditTrailCountAggregateInputType | true
    }

  export interface AuditTrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditTrail'], meta: { name: 'AuditTrail' } }
    /**
     * Find zero or one AuditTrail that matches the filter.
     * @param {AuditTrailFindUniqueArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditTrailFindUniqueArgs>(args: SelectSubset<T, AuditTrailFindUniqueArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditTrail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditTrailFindUniqueOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditTrailFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditTrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditTrail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditTrailFindFirstArgs>(args?: SelectSubset<T, AuditTrailFindFirstArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditTrail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditTrailFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditTrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditTrails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany()
     * 
     * // Get first 10 AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditTrailFindManyArgs>(args?: SelectSubset<T, AuditTrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditTrail.
     * @param {AuditTrailCreateArgs} args - Arguments to create a AuditTrail.
     * @example
     * // Create one AuditTrail
     * const AuditTrail = await prisma.auditTrail.create({
     *   data: {
     *     // ... data to create a AuditTrail
     *   }
     * })
     * 
     */
    create<T extends AuditTrailCreateArgs>(args: SelectSubset<T, AuditTrailCreateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditTrails.
     * @param {AuditTrailCreateManyArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditTrailCreateManyArgs>(args?: SelectSubset<T, AuditTrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditTrails and returns the data saved in the database.
     * @param {AuditTrailCreateManyAndReturnArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditTrails and only return the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditTrailCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditTrailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditTrail.
     * @param {AuditTrailDeleteArgs} args - Arguments to delete one AuditTrail.
     * @example
     * // Delete one AuditTrail
     * const AuditTrail = await prisma.auditTrail.delete({
     *   where: {
     *     // ... filter to delete one AuditTrail
     *   }
     * })
     * 
     */
    delete<T extends AuditTrailDeleteArgs>(args: SelectSubset<T, AuditTrailDeleteArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditTrail.
     * @param {AuditTrailUpdateArgs} args - Arguments to update one AuditTrail.
     * @example
     * // Update one AuditTrail
     * const auditTrail = await prisma.auditTrail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditTrailUpdateArgs>(args: SelectSubset<T, AuditTrailUpdateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditTrails.
     * @param {AuditTrailDeleteManyArgs} args - Arguments to filter AuditTrails to delete.
     * @example
     * // Delete a few AuditTrails
     * const { count } = await prisma.auditTrail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditTrailDeleteManyArgs>(args?: SelectSubset<T, AuditTrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditTrails
     * const auditTrail = await prisma.auditTrail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditTrailUpdateManyArgs>(args: SelectSubset<T, AuditTrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditTrail.
     * @param {AuditTrailUpsertArgs} args - Arguments to update or create a AuditTrail.
     * @example
     * // Update or create a AuditTrail
     * const auditTrail = await prisma.auditTrail.upsert({
     *   create: {
     *     // ... data to create a AuditTrail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditTrail we want to update
     *   }
     * })
     */
    upsert<T extends AuditTrailUpsertArgs>(args: SelectSubset<T, AuditTrailUpsertArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailCountArgs} args - Arguments to filter AuditTrails to count.
     * @example
     * // Count the number of AuditTrails
     * const count = await prisma.auditTrail.count({
     *   where: {
     *     // ... the filter for the AuditTrails we want to count
     *   }
     * })
    **/
    count<T extends AuditTrailCountArgs>(
      args?: Subset<T, AuditTrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditTrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditTrailAggregateArgs>(args: Subset<T, AuditTrailAggregateArgs>): Prisma.PrismaPromise<GetAuditTrailAggregateType<T>>

    /**
     * Group by AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditTrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditTrailGroupByArgs['orderBy'] }
        : { orderBy?: AuditTrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditTrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditTrail model
   */
  readonly fields: AuditTrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditTrail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditTrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends AuditTrail$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditTrail$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditTrail model
   */ 
  interface AuditTrailFieldRefs {
    readonly id: FieldRef<"AuditTrail", 'String'>
    readonly tenantId: FieldRef<"AuditTrail", 'String'>
    readonly userId: FieldRef<"AuditTrail", 'String'>
    readonly action: FieldRef<"AuditTrail", 'AuditAction'>
    readonly entity: FieldRef<"AuditTrail", 'String'>
    readonly entityId: FieldRef<"AuditTrail", 'String'>
    readonly description: FieldRef<"AuditTrail", 'String'>
    readonly metadata: FieldRef<"AuditTrail", 'Json'>
    readonly createdAt: FieldRef<"AuditTrail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditTrail findUnique
   */
  export type AuditTrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findUniqueOrThrow
   */
  export type AuditTrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findFirst
   */
  export type AuditTrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findFirstOrThrow
   */
  export type AuditTrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findMany
   */
  export type AuditTrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrails to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail create
   */
  export type AuditTrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditTrail.
     */
    data: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
  }

  /**
   * AuditTrail createMany
   */
  export type AuditTrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditTrail createManyAndReturn
   */
  export type AuditTrailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditTrail update
   */
  export type AuditTrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditTrail.
     */
    data: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
    /**
     * Choose, which AuditTrail to update.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail updateMany
   */
  export type AuditTrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditTrails.
     */
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which AuditTrails to update
     */
    where?: AuditTrailWhereInput
  }

  /**
   * AuditTrail upsert
   */
  export type AuditTrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditTrail to update in case it exists.
     */
    where: AuditTrailWhereUniqueInput
    /**
     * In case the AuditTrail found by the `where` argument doesn't exist, create a new AuditTrail with this data.
     */
    create: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
    /**
     * In case the AuditTrail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
  }

  /**
   * AuditTrail delete
   */
  export type AuditTrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter which AuditTrail to delete.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail deleteMany
   */
  export type AuditTrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrails to delete
     */
    where?: AuditTrailWhereInput
  }

  /**
   * AuditTrail.user
   */
  export type AuditTrail$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditTrail without action
   */
  export type AuditTrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    entityType: string | null
    entityId: string | null
    fileName: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    path: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    entityType: string | null
    entityId: string | null
    fileName: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    path: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    tenantId: number
    entityType: number
    entityId: number
    fileName: number
    originalName: number
    mimeType: number
    size: number
    path: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    size?: true
  }

  export type AttachmentSumAggregateInputType = {
    size?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    fileName?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    fileName?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    fileName?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    tenantId: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    uploadedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    fileName?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    fileName?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    fileName?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Attachment$userArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      entityType: string
      entityId: string
      fileName: string
      originalName: string
      mimeType: string
      size: number
      path: string
      uploadedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends Attachment$userArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly tenantId: FieldRef<"Attachment", 'String'>
    readonly entityType: FieldRef<"Attachment", 'String'>
    readonly entityId: FieldRef<"Attachment", 'String'>
    readonly fileName: FieldRef<"Attachment", 'String'>
    readonly originalName: FieldRef<"Attachment", 'String'>
    readonly mimeType: FieldRef<"Attachment", 'String'>
    readonly size: FieldRef<"Attachment", 'Int'>
    readonly path: FieldRef<"Attachment", 'String'>
    readonly uploadedBy: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
    readonly updatedAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment.user
   */
  export type Attachment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    entityType: string | null
    entityId: string | null
    content: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    entityType: string | null
    entityId: string | null
    content: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    tenantId: number
    entityType: number
    entityId: number
    content: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    content?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    content?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    content?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    tenantId: string
    entityType: string
    entityId: string
    content: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    content?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    content?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    content?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      entityType: string
      entityId: string
      content: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly tenantId: FieldRef<"Comment", 'String'>
    readonly entityType: FieldRef<"Comment", 'String'>
    readonly entityId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Approval
   */

  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.ApprovalStatus | null
    requestedBy: string | null
    approvedBy: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedAt: Date | null
  }

  export type ApprovalMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.ApprovalStatus | null
    requestedBy: string | null
    approvedBy: string | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedAt: Date | null
  }

  export type ApprovalCountAggregateOutputType = {
    id: number
    tenantId: number
    entityType: number
    entityId: number
    status: number
    requestedBy: number
    approvedBy: number
    comments: number
    createdAt: number
    updatedAt: number
    approvedAt: number
    _all: number
  }


  export type ApprovalMinAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
  }

  export type ApprovalMaxAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
  }

  export type ApprovalCountAggregateInputType = {
    id?: true
    tenantId?: true
    entityType?: true
    entityId?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
    _all?: true
  }

  export type ApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approval to aggregate.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithAggregationInput | ApprovalOrderByWithAggregationInput[]
    by: ApprovalScalarFieldEnum[] | ApprovalScalarFieldEnum
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }

  export type ApprovalGroupByOutputType = {
    id: string
    tenantId: string
    entityType: string
    entityId: string
    status: $Enums.ApprovalStatus
    requestedBy: string
    approvedBy: string | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    approvedAt: Date | null
    _count: ApprovalCountAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Approval$approverArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Approval$approverArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectScalar = {
    id?: boolean
    tenantId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
  }

  export type ApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Approval$approverArgs<ExtArgs>
  }
  export type ApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Approval$approverArgs<ExtArgs>
  }

  export type $ApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Approval"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      requester: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      entityType: string
      entityId: string
      status: $Enums.ApprovalStatus
      requestedBy: string
      approvedBy: string | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
      approvedAt: Date | null
    }, ExtArgs["result"]["approval"]>
    composites: {}
  }

  type ApprovalGetPayload<S extends boolean | null | undefined | ApprovalDefaultArgs> = $Result.GetResult<Prisma.$ApprovalPayload, S>

  type ApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalCountAggregateInputType | true
    }

  export interface ApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Approval'], meta: { name: 'Approval' } }
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalFindUniqueArgs>(args: SelectSubset<T, ApprovalFindUniqueArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Approval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalFindUniqueOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalFindFirstArgs>(args?: SelectSubset<T, ApprovalFindFirstArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWithIdOnly = await prisma.approval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalFindManyArgs>(args?: SelectSubset<T, ApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
     */
    create<T extends ApprovalCreateArgs>(args: SelectSubset<T, ApprovalCreateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Approvals.
     * @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalCreateManyArgs>(args?: SelectSubset<T, ApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Approvals and returns the data saved in the database.
     * @param {ApprovalCreateManyAndReturnArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
     */
    delete<T extends ApprovalDeleteArgs>(args: SelectSubset<T, ApprovalDeleteArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalUpdateArgs>(args: SelectSubset<T, ApprovalUpdateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalDeleteManyArgs>(args?: SelectSubset<T, ApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalUpdateManyArgs>(args: SelectSubset<T, ApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalUpsertArgs>(args: SelectSubset<T, ApprovalUpsertArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): Prisma.PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Approval model
   */
  readonly fields: ApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends Approval$approverArgs<ExtArgs> = {}>(args?: Subset<T, Approval$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Approval model
   */ 
  interface ApprovalFieldRefs {
    readonly id: FieldRef<"Approval", 'String'>
    readonly tenantId: FieldRef<"Approval", 'String'>
    readonly entityType: FieldRef<"Approval", 'String'>
    readonly entityId: FieldRef<"Approval", 'String'>
    readonly status: FieldRef<"Approval", 'ApprovalStatus'>
    readonly requestedBy: FieldRef<"Approval", 'String'>
    readonly approvedBy: FieldRef<"Approval", 'String'>
    readonly comments: FieldRef<"Approval", 'String'>
    readonly createdAt: FieldRef<"Approval", 'DateTime'>
    readonly updatedAt: FieldRef<"Approval", 'DateTime'>
    readonly approvedAt: FieldRef<"Approval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findUniqueOrThrow
   */
  export type ApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findFirstOrThrow
   */
  export type ApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approvals to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval create
   */
  export type ApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a Approval.
     */
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }

  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Approval createManyAndReturn
   */
  export type ApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval update
   */
  export type ApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a Approval.
     */
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
  }

  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the Approval to update in case it exists.
     */
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     */
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }

  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter which Approval to delete.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approvals to delete
     */
    where?: ApprovalWhereInput
  }

  /**
   * Approval.approver
   */
  export type Approval$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Approval without action
   */
  export type ApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowDefinition
   */

  export type AggregateWorkflowDefinition = {
    _count: WorkflowDefinitionCountAggregateOutputType | null
    _min: WorkflowDefinitionMinAggregateOutputType | null
    _max: WorkflowDefinitionMaxAggregateOutputType | null
  }

  export type WorkflowDefinitionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    entityType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowDefinitionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    entityType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowDefinitionCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    entityType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowDefinitionMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    entityType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowDefinitionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    entityType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowDefinitionCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    entityType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowDefinition to aggregate.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowDefinitions
    **/
    _count?: true | WorkflowDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowDefinitionMaxAggregateInputType
  }

  export type GetWorkflowDefinitionAggregateType<T extends WorkflowDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowDefinition[P]>
      : GetScalarType<T[P], AggregateWorkflowDefinition[P]>
  }




  export type WorkflowDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowDefinitionWhereInput
    orderBy?: WorkflowDefinitionOrderByWithAggregationInput | WorkflowDefinitionOrderByWithAggregationInput[]
    by: WorkflowDefinitionScalarFieldEnum[] | WorkflowDefinitionScalarFieldEnum
    having?: WorkflowDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowDefinitionCountAggregateInputType | true
    _min?: WorkflowDefinitionMinAggregateInputType
    _max?: WorkflowDefinitionMaxAggregateInputType
  }

  export type WorkflowDefinitionGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    entityType: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkflowDefinitionCountAggregateOutputType | null
    _min: WorkflowDefinitionMinAggregateOutputType | null
    _max: WorkflowDefinitionMaxAggregateOutputType | null
  }

  type GetWorkflowDefinitionGroupByPayload<T extends WorkflowDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    steps?: boolean | WorkflowDefinition$stepsArgs<ExtArgs>
    instances?: boolean | WorkflowDefinition$instancesArgs<ExtArgs>
    _count?: boolean | WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowDefinition"]>

  export type WorkflowDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowDefinition"]>

  export type WorkflowDefinitionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    steps?: boolean | WorkflowDefinition$stepsArgs<ExtArgs>
    instances?: boolean | WorkflowDefinition$instancesArgs<ExtArgs>
    _count?: boolean | WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WorkflowDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowDefinition"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      steps: Prisma.$WorkflowStepPayload<ExtArgs>[]
      instances: Prisma.$WorkflowInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      entityType: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowDefinition"]>
    composites: {}
  }

  type WorkflowDefinitionGetPayload<S extends boolean | null | undefined | WorkflowDefinitionDefaultArgs> = $Result.GetResult<Prisma.$WorkflowDefinitionPayload, S>

  type WorkflowDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowDefinitionCountAggregateInputType | true
    }

  export interface WorkflowDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowDefinition'], meta: { name: 'WorkflowDefinition' } }
    /**
     * Find zero or one WorkflowDefinition that matches the filter.
     * @param {WorkflowDefinitionFindUniqueArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowDefinitionFindUniqueArgs>(args: SelectSubset<T, WorkflowDefinitionFindUniqueArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowDefinitionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionFindFirstArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowDefinitionFindFirstArgs>(args?: SelectSubset<T, WorkflowDefinitionFindFirstArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionFindFirstOrThrowArgs} args - Arguments to find a WorkflowDefinition
     * @example
     * // Get one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowDefinitions
     * const workflowDefinitions = await prisma.workflowDefinition.findMany()
     * 
     * // Get first 10 WorkflowDefinitions
     * const workflowDefinitions = await prisma.workflowDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowDefinitionWithIdOnly = await prisma.workflowDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowDefinitionFindManyArgs>(args?: SelectSubset<T, WorkflowDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowDefinition.
     * @param {WorkflowDefinitionCreateArgs} args - Arguments to create a WorkflowDefinition.
     * @example
     * // Create one WorkflowDefinition
     * const WorkflowDefinition = await prisma.workflowDefinition.create({
     *   data: {
     *     // ... data to create a WorkflowDefinition
     *   }
     * })
     * 
     */
    create<T extends WorkflowDefinitionCreateArgs>(args: SelectSubset<T, WorkflowDefinitionCreateArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowDefinitions.
     * @param {WorkflowDefinitionCreateManyArgs} args - Arguments to create many WorkflowDefinitions.
     * @example
     * // Create many WorkflowDefinitions
     * const workflowDefinition = await prisma.workflowDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowDefinitionCreateManyArgs>(args?: SelectSubset<T, WorkflowDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowDefinitions and returns the data saved in the database.
     * @param {WorkflowDefinitionCreateManyAndReturnArgs} args - Arguments to create many WorkflowDefinitions.
     * @example
     * // Create many WorkflowDefinitions
     * const workflowDefinition = await prisma.workflowDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowDefinitions and only return the `id`
     * const workflowDefinitionWithIdOnly = await prisma.workflowDefinition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowDefinition.
     * @param {WorkflowDefinitionDeleteArgs} args - Arguments to delete one WorkflowDefinition.
     * @example
     * // Delete one WorkflowDefinition
     * const WorkflowDefinition = await prisma.workflowDefinition.delete({
     *   where: {
     *     // ... filter to delete one WorkflowDefinition
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDefinitionDeleteArgs>(args: SelectSubset<T, WorkflowDefinitionDeleteArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowDefinition.
     * @param {WorkflowDefinitionUpdateArgs} args - Arguments to update one WorkflowDefinition.
     * @example
     * // Update one WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowDefinitionUpdateArgs>(args: SelectSubset<T, WorkflowDefinitionUpdateArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowDefinitions.
     * @param {WorkflowDefinitionDeleteManyArgs} args - Arguments to filter WorkflowDefinitions to delete.
     * @example
     * // Delete a few WorkflowDefinitions
     * const { count } = await prisma.workflowDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDefinitionDeleteManyArgs>(args?: SelectSubset<T, WorkflowDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowDefinitions
     * const workflowDefinition = await prisma.workflowDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowDefinitionUpdateManyArgs>(args: SelectSubset<T, WorkflowDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowDefinition.
     * @param {WorkflowDefinitionUpsertArgs} args - Arguments to update or create a WorkflowDefinition.
     * @example
     * // Update or create a WorkflowDefinition
     * const workflowDefinition = await prisma.workflowDefinition.upsert({
     *   create: {
     *     // ... data to create a WorkflowDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowDefinition we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowDefinitionUpsertArgs>(args: SelectSubset<T, WorkflowDefinitionUpsertArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionCountArgs} args - Arguments to filter WorkflowDefinitions to count.
     * @example
     * // Count the number of WorkflowDefinitions
     * const count = await prisma.workflowDefinition.count({
     *   where: {
     *     // ... the filter for the WorkflowDefinitions we want to count
     *   }
     * })
    **/
    count<T extends WorkflowDefinitionCountArgs>(
      args?: Subset<T, WorkflowDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowDefinitionAggregateArgs>(args: Subset<T, WorkflowDefinitionAggregateArgs>): Prisma.PrismaPromise<GetWorkflowDefinitionAggregateType<T>>

    /**
     * Group by WorkflowDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowDefinition model
   */
  readonly fields: WorkflowDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    steps<T extends WorkflowDefinition$stepsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinition$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany"> | Null>
    instances<T extends WorkflowDefinition$instancesArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinition$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowDefinition model
   */ 
  interface WorkflowDefinitionFieldRefs {
    readonly id: FieldRef<"WorkflowDefinition", 'String'>
    readonly tenantId: FieldRef<"WorkflowDefinition", 'String'>
    readonly name: FieldRef<"WorkflowDefinition", 'String'>
    readonly description: FieldRef<"WorkflowDefinition", 'String'>
    readonly entityType: FieldRef<"WorkflowDefinition", 'String'>
    readonly isActive: FieldRef<"WorkflowDefinition", 'Boolean'>
    readonly createdAt: FieldRef<"WorkflowDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowDefinition findUnique
   */
  export type WorkflowDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition findUniqueOrThrow
   */
  export type WorkflowDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition findFirst
   */
  export type WorkflowDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowDefinitions.
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowDefinitions.
     */
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition findFirstOrThrow
   */
  export type WorkflowDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinition to fetch.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowDefinitions.
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowDefinitions.
     */
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition findMany
   */
  export type WorkflowDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowDefinitions to fetch.
     */
    where?: WorkflowDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowDefinitions to fetch.
     */
    orderBy?: WorkflowDefinitionOrderByWithRelationInput | WorkflowDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowDefinitions.
     */
    cursor?: WorkflowDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowDefinitions.
     */
    skip?: number
    distinct?: WorkflowDefinitionScalarFieldEnum | WorkflowDefinitionScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition create
   */
  export type WorkflowDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowDefinition.
     */
    data: XOR<WorkflowDefinitionCreateInput, WorkflowDefinitionUncheckedCreateInput>
  }

  /**
   * WorkflowDefinition createMany
   */
  export type WorkflowDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowDefinitions.
     */
    data: WorkflowDefinitionCreateManyInput | WorkflowDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowDefinition createManyAndReturn
   */
  export type WorkflowDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowDefinitions.
     */
    data: WorkflowDefinitionCreateManyInput | WorkflowDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowDefinition update
   */
  export type WorkflowDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowDefinition.
     */
    data: XOR<WorkflowDefinitionUpdateInput, WorkflowDefinitionUncheckedUpdateInput>
    /**
     * Choose, which WorkflowDefinition to update.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition updateMany
   */
  export type WorkflowDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowDefinitions.
     */
    data: XOR<WorkflowDefinitionUpdateManyMutationInput, WorkflowDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowDefinitions to update
     */
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * WorkflowDefinition upsert
   */
  export type WorkflowDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowDefinition to update in case it exists.
     */
    where: WorkflowDefinitionWhereUniqueInput
    /**
     * In case the WorkflowDefinition found by the `where` argument doesn't exist, create a new WorkflowDefinition with this data.
     */
    create: XOR<WorkflowDefinitionCreateInput, WorkflowDefinitionUncheckedCreateInput>
    /**
     * In case the WorkflowDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowDefinitionUpdateInput, WorkflowDefinitionUncheckedUpdateInput>
  }

  /**
   * WorkflowDefinition delete
   */
  export type WorkflowDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
    /**
     * Filter which WorkflowDefinition to delete.
     */
    where: WorkflowDefinitionWhereUniqueInput
  }

  /**
   * WorkflowDefinition deleteMany
   */
  export type WorkflowDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowDefinitions to delete
     */
    where?: WorkflowDefinitionWhereInput
  }

  /**
   * WorkflowDefinition.steps
   */
  export type WorkflowDefinition$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    cursor?: WorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition.instances
   */
  export type WorkflowDefinition$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    cursor?: WorkflowInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowDefinition without action
   */
  export type WorkflowDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowDefinition
     */
    select?: WorkflowDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStep
   */

  export type AggregateWorkflowStep = {
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  export type WorkflowStepAvgAggregateOutputType = {
    stepOrder: number | null
    timeoutDays: number | null
  }

  export type WorkflowStepSumAggregateOutputType = {
    stepOrder: number | null
    timeoutDays: number | null
  }

  export type WorkflowStepMinAggregateOutputType = {
    id: string | null
    workflowDefinitionId: string | null
    stepOrder: number | null
    stepType: $Enums.WorkflowStepType | null
    name: string | null
    description: string | null
    notificationTemplate: string | null
    autoAdvance: boolean | null
    timeoutDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepMaxAggregateOutputType = {
    id: string | null
    workflowDefinitionId: string | null
    stepOrder: number | null
    stepType: $Enums.WorkflowStepType | null
    name: string | null
    description: string | null
    notificationTemplate: string | null
    autoAdvance: boolean | null
    timeoutDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepCountAggregateOutputType = {
    id: number
    workflowDefinitionId: number
    stepOrder: number
    stepType: number
    name: number
    description: number
    requiredRoles: number
    requiredUsers: number
    conditionExpression: number
    notificationTemplate: number
    autoAdvance: number
    timeoutDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowStepAvgAggregateInputType = {
    stepOrder?: true
    timeoutDays?: true
  }

  export type WorkflowStepSumAggregateInputType = {
    stepOrder?: true
    timeoutDays?: true
  }

  export type WorkflowStepMinAggregateInputType = {
    id?: true
    workflowDefinitionId?: true
    stepOrder?: true
    stepType?: true
    name?: true
    description?: true
    notificationTemplate?: true
    autoAdvance?: true
    timeoutDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepMaxAggregateInputType = {
    id?: true
    workflowDefinitionId?: true
    stepOrder?: true
    stepType?: true
    name?: true
    description?: true
    notificationTemplate?: true
    autoAdvance?: true
    timeoutDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepCountAggregateInputType = {
    id?: true
    workflowDefinitionId?: true
    stepOrder?: true
    stepType?: true
    name?: true
    description?: true
    requiredRoles?: true
    requiredUsers?: true
    conditionExpression?: true
    notificationTemplate?: true
    autoAdvance?: true
    timeoutDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStep to aggregate.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowSteps
    **/
    _count?: true | WorkflowStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type GetWorkflowStepAggregateType<T extends WorkflowStepAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStep[P]>
      : GetScalarType<T[P], AggregateWorkflowStep[P]>
  }




  export type WorkflowStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithAggregationInput | WorkflowStepOrderByWithAggregationInput[]
    by: WorkflowStepScalarFieldEnum[] | WorkflowStepScalarFieldEnum
    having?: WorkflowStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepCountAggregateInputType | true
    _avg?: WorkflowStepAvgAggregateInputType
    _sum?: WorkflowStepSumAggregateInputType
    _min?: WorkflowStepMinAggregateInputType
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type WorkflowStepGroupByOutputType = {
    id: string
    workflowDefinitionId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description: string | null
    requiredRoles: JsonValue
    requiredUsers: JsonValue
    conditionExpression: JsonValue | null
    notificationTemplate: string | null
    autoAdvance: boolean
    timeoutDays: number | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  type GetWorkflowStepGroupByPayload<T extends WorkflowStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowDefinitionId?: boolean
    stepOrder?: boolean
    stepType?: boolean
    name?: boolean
    description?: boolean
    requiredRoles?: boolean
    requiredUsers?: boolean
    conditionExpression?: boolean
    notificationTemplate?: boolean
    autoAdvance?: boolean
    timeoutDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowDefinitionId?: boolean
    stepOrder?: boolean
    stepType?: boolean
    name?: boolean
    description?: boolean
    requiredRoles?: boolean
    requiredUsers?: boolean
    conditionExpression?: boolean
    notificationTemplate?: boolean
    autoAdvance?: boolean
    timeoutDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectScalar = {
    id?: boolean
    workflowDefinitionId?: boolean
    stepOrder?: boolean
    stepType?: boolean
    name?: boolean
    description?: boolean
    requiredRoles?: boolean
    requiredUsers?: boolean
    conditionExpression?: boolean
    notificationTemplate?: boolean
    autoAdvance?: boolean
    timeoutDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
  }
  export type WorkflowStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
  }

  export type $WorkflowStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStep"
    objects: {
      workflowDefinition: Prisma.$WorkflowDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowDefinitionId: string
      stepOrder: number
      stepType: $Enums.WorkflowStepType
      name: string
      description: string | null
      requiredRoles: Prisma.JsonValue
      requiredUsers: Prisma.JsonValue
      conditionExpression: Prisma.JsonValue | null
      notificationTemplate: string | null
      autoAdvance: boolean
      timeoutDays: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowStep"]>
    composites: {}
  }

  type WorkflowStepGetPayload<S extends boolean | null | undefined | WorkflowStepDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepPayload, S>

  type WorkflowStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowStepCountAggregateInputType | true
    }

  export interface WorkflowStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStep'], meta: { name: 'WorkflowStep' } }
    /**
     * Find zero or one WorkflowStep that matches the filter.
     * @param {WorkflowStepFindUniqueArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepFindUniqueArgs>(args: SelectSubset<T, WorkflowStepFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowStepFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepFindFirstArgs>(args?: SelectSubset<T, WorkflowStepFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany()
     * 
     * // Get first 10 WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepFindManyArgs>(args?: SelectSubset<T, WorkflowStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowStep.
     * @param {WorkflowStepCreateArgs} args - Arguments to create a WorkflowStep.
     * @example
     * // Create one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.create({
     *   data: {
     *     // ... data to create a WorkflowStep
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepCreateArgs>(args: SelectSubset<T, WorkflowStepCreateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowSteps.
     * @param {WorkflowStepCreateManyArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepCreateManyArgs>(args?: SelectSubset<T, WorkflowStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowSteps and returns the data saved in the database.
     * @param {WorkflowStepCreateManyAndReturnArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowSteps and only return the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowStepCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowStep.
     * @param {WorkflowStepDeleteArgs} args - Arguments to delete one WorkflowStep.
     * @example
     * // Delete one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStep
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepDeleteArgs>(args: SelectSubset<T, WorkflowStepDeleteArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowStep.
     * @param {WorkflowStepUpdateArgs} args - Arguments to update one WorkflowStep.
     * @example
     * // Update one WorkflowStep
     * const workflowStep = await prisma.workflowStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepUpdateArgs>(args: SelectSubset<T, WorkflowStepUpdateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowSteps.
     * @param {WorkflowStepDeleteManyArgs} args - Arguments to filter WorkflowSteps to delete.
     * @example
     * // Delete a few WorkflowSteps
     * const { count } = await prisma.workflowStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepUpdateManyArgs>(args: SelectSubset<T, WorkflowStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowStep.
     * @param {WorkflowStepUpsertArgs} args - Arguments to update or create a WorkflowStep.
     * @example
     * // Update or create a WorkflowStep
     * const workflowStep = await prisma.workflowStep.upsert({
     *   create: {
     *     // ... data to create a WorkflowStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStep we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepUpsertArgs>(args: SelectSubset<T, WorkflowStepUpsertArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepCountArgs} args - Arguments to filter WorkflowSteps to count.
     * @example
     * // Count the number of WorkflowSteps
     * const count = await prisma.workflowStep.count({
     *   where: {
     *     // ... the filter for the WorkflowSteps we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepCountArgs>(
      args?: Subset<T, WorkflowStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepAggregateArgs>(args: Subset<T, WorkflowStepAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepAggregateType<T>>

    /**
     * Group by WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStep model
   */
  readonly fields: WorkflowStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflowDefinition<T extends WorkflowDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinitionDefaultArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStep model
   */ 
  interface WorkflowStepFieldRefs {
    readonly id: FieldRef<"WorkflowStep", 'String'>
    readonly workflowDefinitionId: FieldRef<"WorkflowStep", 'String'>
    readonly stepOrder: FieldRef<"WorkflowStep", 'Int'>
    readonly stepType: FieldRef<"WorkflowStep", 'WorkflowStepType'>
    readonly name: FieldRef<"WorkflowStep", 'String'>
    readonly description: FieldRef<"WorkflowStep", 'String'>
    readonly requiredRoles: FieldRef<"WorkflowStep", 'Json'>
    readonly requiredUsers: FieldRef<"WorkflowStep", 'Json'>
    readonly conditionExpression: FieldRef<"WorkflowStep", 'Json'>
    readonly notificationTemplate: FieldRef<"WorkflowStep", 'String'>
    readonly autoAdvance: FieldRef<"WorkflowStep", 'Boolean'>
    readonly timeoutDays: FieldRef<"WorkflowStep", 'Int'>
    readonly createdAt: FieldRef<"WorkflowStep", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStep findUnique
   */
  export type WorkflowStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findUniqueOrThrow
   */
  export type WorkflowStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findFirst
   */
  export type WorkflowStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findFirstOrThrow
   */
  export type WorkflowStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findMany
   */
  export type WorkflowStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowSteps to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep create
   */
  export type WorkflowStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStep.
     */
    data: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
  }

  /**
   * WorkflowStep createMany
   */
  export type WorkflowStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowStep createManyAndReturn
   */
  export type WorkflowStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStep update
   */
  export type WorkflowStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStep.
     */
    data: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStep to update.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep updateMany
   */
  export type WorkflowStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowSteps.
     */
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowSteps to update
     */
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowStep upsert
   */
  export type WorkflowStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStep to update in case it exists.
     */
    where: WorkflowStepWhereUniqueInput
    /**
     * In case the WorkflowStep found by the `where` argument doesn't exist, create a new WorkflowStep with this data.
     */
    create: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
    /**
     * In case the WorkflowStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
  }

  /**
   * WorkflowStep delete
   */
  export type WorkflowStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStep to delete.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep deleteMany
   */
  export type WorkflowStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowSteps to delete
     */
    where?: WorkflowStepWhereInput
  }

  /**
   * WorkflowStep without action
   */
  export type WorkflowStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowInstance
   */

  export type AggregateWorkflowInstance = {
    _count: WorkflowInstanceCountAggregateOutputType | null
    _avg: WorkflowInstanceAvgAggregateOutputType | null
    _sum: WorkflowInstanceSumAggregateOutputType | null
    _min: WorkflowInstanceMinAggregateOutputType | null
    _max: WorkflowInstanceMaxAggregateOutputType | null
  }

  export type WorkflowInstanceAvgAggregateOutputType = {
    currentStepOrder: number | null
  }

  export type WorkflowInstanceSumAggregateOutputType = {
    currentStepOrder: number | null
  }

  export type WorkflowInstanceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    workflowDefinitionId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.WorkflowStatus | null
    startedBy: string | null
    currentStepOrder: number | null
    completedAt: Date | null
    cancelledAt: Date | null
    cancelledBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowInstanceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    workflowDefinitionId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.WorkflowStatus | null
    startedBy: string | null
    currentStepOrder: number | null
    completedAt: Date | null
    cancelledAt: Date | null
    cancelledBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowInstanceCountAggregateOutputType = {
    id: number
    tenantId: number
    workflowDefinitionId: number
    entityType: number
    entityId: number
    status: number
    startedBy: number
    currentStepOrder: number
    completedAt: number
    cancelledAt: number
    cancelledBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowInstanceAvgAggregateInputType = {
    currentStepOrder?: true
  }

  export type WorkflowInstanceSumAggregateInputType = {
    currentStepOrder?: true
  }

  export type WorkflowInstanceMinAggregateInputType = {
    id?: true
    tenantId?: true
    workflowDefinitionId?: true
    entityType?: true
    entityId?: true
    status?: true
    startedBy?: true
    currentStepOrder?: true
    completedAt?: true
    cancelledAt?: true
    cancelledBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowInstanceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    workflowDefinitionId?: true
    entityType?: true
    entityId?: true
    status?: true
    startedBy?: true
    currentStepOrder?: true
    completedAt?: true
    cancelledAt?: true
    cancelledBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowInstanceCountAggregateInputType = {
    id?: true
    tenantId?: true
    workflowDefinitionId?: true
    entityType?: true
    entityId?: true
    status?: true
    startedBy?: true
    currentStepOrder?: true
    completedAt?: true
    cancelledAt?: true
    cancelledBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowInstance to aggregate.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowInstances
    **/
    _count?: true | WorkflowInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowInstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowInstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowInstanceMaxAggregateInputType
  }

  export type GetWorkflowInstanceAggregateType<T extends WorkflowInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowInstance[P]>
      : GetScalarType<T[P], AggregateWorkflowInstance[P]>
  }




  export type WorkflowInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowInstanceWhereInput
    orderBy?: WorkflowInstanceOrderByWithAggregationInput | WorkflowInstanceOrderByWithAggregationInput[]
    by: WorkflowInstanceScalarFieldEnum[] | WorkflowInstanceScalarFieldEnum
    having?: WorkflowInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowInstanceCountAggregateInputType | true
    _avg?: WorkflowInstanceAvgAggregateInputType
    _sum?: WorkflowInstanceSumAggregateInputType
    _min?: WorkflowInstanceMinAggregateInputType
    _max?: WorkflowInstanceMaxAggregateInputType
  }

  export type WorkflowInstanceGroupByOutputType = {
    id: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder: number | null
    completedAt: Date | null
    cancelledAt: Date | null
    cancelledBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowInstanceCountAggregateOutputType | null
    _avg: WorkflowInstanceAvgAggregateOutputType | null
    _sum: WorkflowInstanceSumAggregateOutputType | null
    _min: WorkflowInstanceMinAggregateOutputType | null
    _max: WorkflowInstanceMaxAggregateOutputType | null
  }

  type GetWorkflowInstanceGroupByPayload<T extends WorkflowInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowInstanceGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    workflowDefinitionId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    startedBy?: boolean
    currentStepOrder?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    startedByUser?: boolean | UserDefaultArgs<ExtArgs>
    cancelledByUser?: boolean | WorkflowInstance$cancelledByUserArgs<ExtArgs>
    stepExecutions?: boolean | WorkflowInstance$stepExecutionsArgs<ExtArgs>
    documents?: boolean | WorkflowInstance$documentsArgs<ExtArgs>
    _count?: boolean | WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowInstance"]>

  export type WorkflowInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    workflowDefinitionId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    startedBy?: boolean
    currentStepOrder?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    startedByUser?: boolean | UserDefaultArgs<ExtArgs>
    cancelledByUser?: boolean | WorkflowInstance$cancelledByUserArgs<ExtArgs>
  }, ExtArgs["result"]["workflowInstance"]>

  export type WorkflowInstanceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    workflowDefinitionId?: boolean
    entityType?: boolean
    entityId?: boolean
    status?: boolean
    startedBy?: boolean
    currentStepOrder?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    startedByUser?: boolean | UserDefaultArgs<ExtArgs>
    cancelledByUser?: boolean | WorkflowInstance$cancelledByUserArgs<ExtArgs>
    stepExecutions?: boolean | WorkflowInstance$stepExecutionsArgs<ExtArgs>
    documents?: boolean | WorkflowInstance$documentsArgs<ExtArgs>
    _count?: boolean | WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    workflowDefinition?: boolean | WorkflowDefinitionDefaultArgs<ExtArgs>
    startedByUser?: boolean | UserDefaultArgs<ExtArgs>
    cancelledByUser?: boolean | WorkflowInstance$cancelledByUserArgs<ExtArgs>
  }

  export type $WorkflowInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowInstance"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      workflowDefinition: Prisma.$WorkflowDefinitionPayload<ExtArgs>
      startedByUser: Prisma.$UserPayload<ExtArgs>
      cancelledByUser: Prisma.$UserPayload<ExtArgs> | null
      stepExecutions: Prisma.$WorkflowStepExecutionPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      workflowDefinitionId: string
      entityType: string
      entityId: string
      status: $Enums.WorkflowStatus
      startedBy: string
      currentStepOrder: number | null
      completedAt: Date | null
      cancelledAt: Date | null
      cancelledBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowInstance"]>
    composites: {}
  }

  type WorkflowInstanceGetPayload<S extends boolean | null | undefined | WorkflowInstanceDefaultArgs> = $Result.GetResult<Prisma.$WorkflowInstancePayload, S>

  type WorkflowInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowInstanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowInstanceCountAggregateInputType | true
    }

  export interface WorkflowInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowInstance'], meta: { name: 'WorkflowInstance' } }
    /**
     * Find zero or one WorkflowInstance that matches the filter.
     * @param {WorkflowInstanceFindUniqueArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowInstanceFindUniqueArgs>(args: SelectSubset<T, WorkflowInstanceFindUniqueArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowInstance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowInstanceFindUniqueOrThrowArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceFindFirstArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowInstanceFindFirstArgs>(args?: SelectSubset<T, WorkflowInstanceFindFirstArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceFindFirstOrThrowArgs} args - Arguments to find a WorkflowInstance
     * @example
     * // Get one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowInstances
     * const workflowInstances = await prisma.workflowInstance.findMany()
     * 
     * // Get first 10 WorkflowInstances
     * const workflowInstances = await prisma.workflowInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowInstanceWithIdOnly = await prisma.workflowInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowInstanceFindManyArgs>(args?: SelectSubset<T, WorkflowInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowInstance.
     * @param {WorkflowInstanceCreateArgs} args - Arguments to create a WorkflowInstance.
     * @example
     * // Create one WorkflowInstance
     * const WorkflowInstance = await prisma.workflowInstance.create({
     *   data: {
     *     // ... data to create a WorkflowInstance
     *   }
     * })
     * 
     */
    create<T extends WorkflowInstanceCreateArgs>(args: SelectSubset<T, WorkflowInstanceCreateArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowInstances.
     * @param {WorkflowInstanceCreateManyArgs} args - Arguments to create many WorkflowInstances.
     * @example
     * // Create many WorkflowInstances
     * const workflowInstance = await prisma.workflowInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowInstanceCreateManyArgs>(args?: SelectSubset<T, WorkflowInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowInstances and returns the data saved in the database.
     * @param {WorkflowInstanceCreateManyAndReturnArgs} args - Arguments to create many WorkflowInstances.
     * @example
     * // Create many WorkflowInstances
     * const workflowInstance = await prisma.workflowInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowInstances and only return the `id`
     * const workflowInstanceWithIdOnly = await prisma.workflowInstance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowInstance.
     * @param {WorkflowInstanceDeleteArgs} args - Arguments to delete one WorkflowInstance.
     * @example
     * // Delete one WorkflowInstance
     * const WorkflowInstance = await prisma.workflowInstance.delete({
     *   where: {
     *     // ... filter to delete one WorkflowInstance
     *   }
     * })
     * 
     */
    delete<T extends WorkflowInstanceDeleteArgs>(args: SelectSubset<T, WorkflowInstanceDeleteArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowInstance.
     * @param {WorkflowInstanceUpdateArgs} args - Arguments to update one WorkflowInstance.
     * @example
     * // Update one WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowInstanceUpdateArgs>(args: SelectSubset<T, WorkflowInstanceUpdateArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowInstances.
     * @param {WorkflowInstanceDeleteManyArgs} args - Arguments to filter WorkflowInstances to delete.
     * @example
     * // Delete a few WorkflowInstances
     * const { count } = await prisma.workflowInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowInstanceDeleteManyArgs>(args?: SelectSubset<T, WorkflowInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowInstances
     * const workflowInstance = await prisma.workflowInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowInstanceUpdateManyArgs>(args: SelectSubset<T, WorkflowInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowInstance.
     * @param {WorkflowInstanceUpsertArgs} args - Arguments to update or create a WorkflowInstance.
     * @example
     * // Update or create a WorkflowInstance
     * const workflowInstance = await prisma.workflowInstance.upsert({
     *   create: {
     *     // ... data to create a WorkflowInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowInstance we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowInstanceUpsertArgs>(args: SelectSubset<T, WorkflowInstanceUpsertArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceCountArgs} args - Arguments to filter WorkflowInstances to count.
     * @example
     * // Count the number of WorkflowInstances
     * const count = await prisma.workflowInstance.count({
     *   where: {
     *     // ... the filter for the WorkflowInstances we want to count
     *   }
     * })
    **/
    count<T extends WorkflowInstanceCountArgs>(
      args?: Subset<T, WorkflowInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowInstanceAggregateArgs>(args: Subset<T, WorkflowInstanceAggregateArgs>): Prisma.PrismaPromise<GetWorkflowInstanceAggregateType<T>>

    /**
     * Group by WorkflowInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowInstanceGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowInstance model
   */
  readonly fields: WorkflowInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workflowDefinition<T extends WorkflowDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefinitionDefaultArgs<ExtArgs>>): Prisma__WorkflowDefinitionClient<$Result.GetResult<Prisma.$WorkflowDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    startedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cancelledByUser<T extends WorkflowInstance$cancelledByUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstance$cancelledByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stepExecutions<T extends WorkflowInstance$stepExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstance$stepExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends WorkflowInstance$documentsArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstance$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowInstance model
   */ 
  interface WorkflowInstanceFieldRefs {
    readonly id: FieldRef<"WorkflowInstance", 'String'>
    readonly tenantId: FieldRef<"WorkflowInstance", 'String'>
    readonly workflowDefinitionId: FieldRef<"WorkflowInstance", 'String'>
    readonly entityType: FieldRef<"WorkflowInstance", 'String'>
    readonly entityId: FieldRef<"WorkflowInstance", 'String'>
    readonly status: FieldRef<"WorkflowInstance", 'WorkflowStatus'>
    readonly startedBy: FieldRef<"WorkflowInstance", 'String'>
    readonly currentStepOrder: FieldRef<"WorkflowInstance", 'Int'>
    readonly completedAt: FieldRef<"WorkflowInstance", 'DateTime'>
    readonly cancelledAt: FieldRef<"WorkflowInstance", 'DateTime'>
    readonly cancelledBy: FieldRef<"WorkflowInstance", 'String'>
    readonly createdAt: FieldRef<"WorkflowInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowInstance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowInstance findUnique
   */
  export type WorkflowInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance findUniqueOrThrow
   */
  export type WorkflowInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance findFirst
   */
  export type WorkflowInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowInstances.
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowInstances.
     */
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowInstance findFirstOrThrow
   */
  export type WorkflowInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstance to fetch.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowInstances.
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowInstances.
     */
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowInstance findMany
   */
  export type WorkflowInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowInstances to fetch.
     */
    where?: WorkflowInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowInstances to fetch.
     */
    orderBy?: WorkflowInstanceOrderByWithRelationInput | WorkflowInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowInstances.
     */
    cursor?: WorkflowInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowInstances.
     */
    skip?: number
    distinct?: WorkflowInstanceScalarFieldEnum | WorkflowInstanceScalarFieldEnum[]
  }

  /**
   * WorkflowInstance create
   */
  export type WorkflowInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowInstance.
     */
    data: XOR<WorkflowInstanceCreateInput, WorkflowInstanceUncheckedCreateInput>
  }

  /**
   * WorkflowInstance createMany
   */
  export type WorkflowInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowInstances.
     */
    data: WorkflowInstanceCreateManyInput | WorkflowInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowInstance createManyAndReturn
   */
  export type WorkflowInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowInstances.
     */
    data: WorkflowInstanceCreateManyInput | WorkflowInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowInstance update
   */
  export type WorkflowInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowInstance.
     */
    data: XOR<WorkflowInstanceUpdateInput, WorkflowInstanceUncheckedUpdateInput>
    /**
     * Choose, which WorkflowInstance to update.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance updateMany
   */
  export type WorkflowInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowInstances.
     */
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowInstances to update
     */
    where?: WorkflowInstanceWhereInput
  }

  /**
   * WorkflowInstance upsert
   */
  export type WorkflowInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowInstance to update in case it exists.
     */
    where: WorkflowInstanceWhereUniqueInput
    /**
     * In case the WorkflowInstance found by the `where` argument doesn't exist, create a new WorkflowInstance with this data.
     */
    create: XOR<WorkflowInstanceCreateInput, WorkflowInstanceUncheckedCreateInput>
    /**
     * In case the WorkflowInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowInstanceUpdateInput, WorkflowInstanceUncheckedUpdateInput>
  }

  /**
   * WorkflowInstance delete
   */
  export type WorkflowInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    /**
     * Filter which WorkflowInstance to delete.
     */
    where: WorkflowInstanceWhereUniqueInput
  }

  /**
   * WorkflowInstance deleteMany
   */
  export type WorkflowInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowInstances to delete
     */
    where?: WorkflowInstanceWhereInput
  }

  /**
   * WorkflowInstance.cancelledByUser
   */
  export type WorkflowInstance$cancelledByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkflowInstance.stepExecutions
   */
  export type WorkflowInstance$stepExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    cursor?: WorkflowStepExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowInstance.documents
   */
  export type WorkflowInstance$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * WorkflowInstance without action
   */
  export type WorkflowInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStepExecution
   */

  export type AggregateWorkflowStepExecution = {
    _count: WorkflowStepExecutionCountAggregateOutputType | null
    _avg: WorkflowStepExecutionAvgAggregateOutputType | null
    _sum: WorkflowStepExecutionSumAggregateOutputType | null
    _min: WorkflowStepExecutionMinAggregateOutputType | null
    _max: WorkflowStepExecutionMaxAggregateOutputType | null
  }

  export type WorkflowStepExecutionAvgAggregateOutputType = {
    stepOrder: number | null
  }

  export type WorkflowStepExecutionSumAggregateOutputType = {
    stepOrder: number | null
  }

  export type WorkflowStepExecutionMinAggregateOutputType = {
    id: string | null
    workflowInstanceId: string | null
    stepOrder: number | null
    stepType: $Enums.WorkflowStepType | null
    status: $Enums.WorkflowStatus | null
    executedBy: string | null
    comments: string | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepExecutionMaxAggregateOutputType = {
    id: string | null
    workflowInstanceId: string | null
    stepOrder: number | null
    stepType: $Enums.WorkflowStepType | null
    status: $Enums.WorkflowStatus | null
    executedBy: string | null
    comments: string | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkflowStepExecutionCountAggregateOutputType = {
    id: number
    workflowInstanceId: number
    stepOrder: number
    stepType: number
    status: number
    executedBy: number
    comments: number
    executedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkflowStepExecutionAvgAggregateInputType = {
    stepOrder?: true
  }

  export type WorkflowStepExecutionSumAggregateInputType = {
    stepOrder?: true
  }

  export type WorkflowStepExecutionMinAggregateInputType = {
    id?: true
    workflowInstanceId?: true
    stepOrder?: true
    stepType?: true
    status?: true
    executedBy?: true
    comments?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepExecutionMaxAggregateInputType = {
    id?: true
    workflowInstanceId?: true
    stepOrder?: true
    stepType?: true
    status?: true
    executedBy?: true
    comments?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkflowStepExecutionCountAggregateInputType = {
    id?: true
    workflowInstanceId?: true
    stepOrder?: true
    stepType?: true
    status?: true
    executedBy?: true
    comments?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkflowStepExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStepExecution to aggregate.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowStepExecutions
    **/
    _count?: true | WorkflowStepExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepExecutionMaxAggregateInputType
  }

  export type GetWorkflowStepExecutionAggregateType<T extends WorkflowStepExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStepExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStepExecution[P]>
      : GetScalarType<T[P], AggregateWorkflowStepExecution[P]>
  }




  export type WorkflowStepExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepExecutionWhereInput
    orderBy?: WorkflowStepExecutionOrderByWithAggregationInput | WorkflowStepExecutionOrderByWithAggregationInput[]
    by: WorkflowStepExecutionScalarFieldEnum[] | WorkflowStepExecutionScalarFieldEnum
    having?: WorkflowStepExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepExecutionCountAggregateInputType | true
    _avg?: WorkflowStepExecutionAvgAggregateInputType
    _sum?: WorkflowStepExecutionSumAggregateInputType
    _min?: WorkflowStepExecutionMinAggregateInputType
    _max?: WorkflowStepExecutionMaxAggregateInputType
  }

  export type WorkflowStepExecutionGroupByOutputType = {
    id: string
    workflowInstanceId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status: $Enums.WorkflowStatus
    executedBy: string | null
    comments: string | null
    executedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WorkflowStepExecutionCountAggregateOutputType | null
    _avg: WorkflowStepExecutionAvgAggregateOutputType | null
    _sum: WorkflowStepExecutionSumAggregateOutputType | null
    _min: WorkflowStepExecutionMinAggregateOutputType | null
    _max: WorkflowStepExecutionMaxAggregateOutputType | null
  }

  type GetWorkflowStepExecutionGroupByPayload<T extends WorkflowStepExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepExecutionGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowInstanceId?: boolean
    stepOrder?: boolean
    stepType?: boolean
    status?: boolean
    executedBy?: boolean
    comments?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowInstance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    executedByUser?: boolean | WorkflowStepExecution$executedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStepExecution"]>

  export type WorkflowStepExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowInstanceId?: boolean
    stepOrder?: boolean
    stepType?: boolean
    status?: boolean
    executedBy?: boolean
    comments?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowInstance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    executedByUser?: boolean | WorkflowStepExecution$executedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStepExecution"]>

  export type WorkflowStepExecutionSelectScalar = {
    id?: boolean
    workflowInstanceId?: boolean
    stepOrder?: boolean
    stepType?: boolean
    status?: boolean
    executedBy?: boolean
    comments?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkflowStepExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowInstance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    executedByUser?: boolean | WorkflowStepExecution$executedByUserArgs<ExtArgs>
  }
  export type WorkflowStepExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowInstance?: boolean | WorkflowInstanceDefaultArgs<ExtArgs>
    executedByUser?: boolean | WorkflowStepExecution$executedByUserArgs<ExtArgs>
  }

  export type $WorkflowStepExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStepExecution"
    objects: {
      workflowInstance: Prisma.$WorkflowInstancePayload<ExtArgs>
      executedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowInstanceId: string
      stepOrder: number
      stepType: $Enums.WorkflowStepType
      status: $Enums.WorkflowStatus
      executedBy: string | null
      comments: string | null
      executedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workflowStepExecution"]>
    composites: {}
  }

  type WorkflowStepExecutionGetPayload<S extends boolean | null | undefined | WorkflowStepExecutionDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepExecutionPayload, S>

  type WorkflowStepExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowStepExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowStepExecutionCountAggregateInputType | true
    }

  export interface WorkflowStepExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStepExecution'], meta: { name: 'WorkflowStepExecution' } }
    /**
     * Find zero or one WorkflowStepExecution that matches the filter.
     * @param {WorkflowStepExecutionFindUniqueArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepExecutionFindUniqueArgs>(args: SelectSubset<T, WorkflowStepExecutionFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowStepExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowStepExecutionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowStepExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionFindFirstArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepExecutionFindFirstArgs>(args?: SelectSubset<T, WorkflowStepExecutionFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowStepExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionFindFirstOrThrowArgs} args - Arguments to find a WorkflowStepExecution
     * @example
     * // Get one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowStepExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowStepExecutions
     * const workflowStepExecutions = await prisma.workflowStepExecution.findMany()
     * 
     * // Get first 10 WorkflowStepExecutions
     * const workflowStepExecutions = await prisma.workflowStepExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepExecutionWithIdOnly = await prisma.workflowStepExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepExecutionFindManyArgs>(args?: SelectSubset<T, WorkflowStepExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowStepExecution.
     * @param {WorkflowStepExecutionCreateArgs} args - Arguments to create a WorkflowStepExecution.
     * @example
     * // Create one WorkflowStepExecution
     * const WorkflowStepExecution = await prisma.workflowStepExecution.create({
     *   data: {
     *     // ... data to create a WorkflowStepExecution
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepExecutionCreateArgs>(args: SelectSubset<T, WorkflowStepExecutionCreateArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowStepExecutions.
     * @param {WorkflowStepExecutionCreateManyArgs} args - Arguments to create many WorkflowStepExecutions.
     * @example
     * // Create many WorkflowStepExecutions
     * const workflowStepExecution = await prisma.workflowStepExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepExecutionCreateManyArgs>(args?: SelectSubset<T, WorkflowStepExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowStepExecutions and returns the data saved in the database.
     * @param {WorkflowStepExecutionCreateManyAndReturnArgs} args - Arguments to create many WorkflowStepExecutions.
     * @example
     * // Create many WorkflowStepExecutions
     * const workflowStepExecution = await prisma.workflowStepExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowStepExecutions and only return the `id`
     * const workflowStepExecutionWithIdOnly = await prisma.workflowStepExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowStepExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowStepExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowStepExecution.
     * @param {WorkflowStepExecutionDeleteArgs} args - Arguments to delete one WorkflowStepExecution.
     * @example
     * // Delete one WorkflowStepExecution
     * const WorkflowStepExecution = await prisma.workflowStepExecution.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStepExecution
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepExecutionDeleteArgs>(args: SelectSubset<T, WorkflowStepExecutionDeleteArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowStepExecution.
     * @param {WorkflowStepExecutionUpdateArgs} args - Arguments to update one WorkflowStepExecution.
     * @example
     * // Update one WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepExecutionUpdateArgs>(args: SelectSubset<T, WorkflowStepExecutionUpdateArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowStepExecutions.
     * @param {WorkflowStepExecutionDeleteManyArgs} args - Arguments to filter WorkflowStepExecutions to delete.
     * @example
     * // Delete a few WorkflowStepExecutions
     * const { count } = await prisma.workflowStepExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepExecutionDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowStepExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowStepExecutions
     * const workflowStepExecution = await prisma.workflowStepExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepExecutionUpdateManyArgs>(args: SelectSubset<T, WorkflowStepExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowStepExecution.
     * @param {WorkflowStepExecutionUpsertArgs} args - Arguments to update or create a WorkflowStepExecution.
     * @example
     * // Update or create a WorkflowStepExecution
     * const workflowStepExecution = await prisma.workflowStepExecution.upsert({
     *   create: {
     *     // ... data to create a WorkflowStepExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStepExecution we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepExecutionUpsertArgs>(args: SelectSubset<T, WorkflowStepExecutionUpsertArgs<ExtArgs>>): Prisma__WorkflowStepExecutionClient<$Result.GetResult<Prisma.$WorkflowStepExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowStepExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionCountArgs} args - Arguments to filter WorkflowStepExecutions to count.
     * @example
     * // Count the number of WorkflowStepExecutions
     * const count = await prisma.workflowStepExecution.count({
     *   where: {
     *     // ... the filter for the WorkflowStepExecutions we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepExecutionCountArgs>(
      args?: Subset<T, WorkflowStepExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStepExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepExecutionAggregateArgs>(args: Subset<T, WorkflowStepExecutionAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepExecutionAggregateType<T>>

    /**
     * Group by WorkflowStepExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepExecutionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStepExecution model
   */
  readonly fields: WorkflowStepExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStepExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflowInstance<T extends WorkflowInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowInstanceDefaultArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executedByUser<T extends WorkflowStepExecution$executedByUserArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStepExecution$executedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStepExecution model
   */ 
  interface WorkflowStepExecutionFieldRefs {
    readonly id: FieldRef<"WorkflowStepExecution", 'String'>
    readonly workflowInstanceId: FieldRef<"WorkflowStepExecution", 'String'>
    readonly stepOrder: FieldRef<"WorkflowStepExecution", 'Int'>
    readonly stepType: FieldRef<"WorkflowStepExecution", 'WorkflowStepType'>
    readonly status: FieldRef<"WorkflowStepExecution", 'WorkflowStatus'>
    readonly executedBy: FieldRef<"WorkflowStepExecution", 'String'>
    readonly comments: FieldRef<"WorkflowStepExecution", 'String'>
    readonly executedAt: FieldRef<"WorkflowStepExecution", 'DateTime'>
    readonly createdAt: FieldRef<"WorkflowStepExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowStepExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStepExecution findUnique
   */
  export type WorkflowStepExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution findUniqueOrThrow
   */
  export type WorkflowStepExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution findFirst
   */
  export type WorkflowStepExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowStepExecutions.
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowStepExecutions.
     */
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStepExecution findFirstOrThrow
   */
  export type WorkflowStepExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecution to fetch.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowStepExecutions.
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowStepExecutions.
     */
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStepExecution findMany
   */
  export type WorkflowStepExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStepExecutions to fetch.
     */
    where?: WorkflowStepExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowStepExecutions to fetch.
     */
    orderBy?: WorkflowStepExecutionOrderByWithRelationInput | WorkflowStepExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowStepExecutions.
     */
    cursor?: WorkflowStepExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowStepExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowStepExecutions.
     */
    skip?: number
    distinct?: WorkflowStepExecutionScalarFieldEnum | WorkflowStepExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowStepExecution create
   */
  export type WorkflowStepExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStepExecution.
     */
    data: XOR<WorkflowStepExecutionCreateInput, WorkflowStepExecutionUncheckedCreateInput>
  }

  /**
   * WorkflowStepExecution createMany
   */
  export type WorkflowStepExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowStepExecutions.
     */
    data: WorkflowStepExecutionCreateManyInput | WorkflowStepExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowStepExecution createManyAndReturn
   */
  export type WorkflowStepExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowStepExecutions.
     */
    data: WorkflowStepExecutionCreateManyInput | WorkflowStepExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStepExecution update
   */
  export type WorkflowStepExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStepExecution.
     */
    data: XOR<WorkflowStepExecutionUpdateInput, WorkflowStepExecutionUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStepExecution to update.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution updateMany
   */
  export type WorkflowStepExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowStepExecutions.
     */
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowStepExecutions to update
     */
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowStepExecution upsert
   */
  export type WorkflowStepExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStepExecution to update in case it exists.
     */
    where: WorkflowStepExecutionWhereUniqueInput
    /**
     * In case the WorkflowStepExecution found by the `where` argument doesn't exist, create a new WorkflowStepExecution with this data.
     */
    create: XOR<WorkflowStepExecutionCreateInput, WorkflowStepExecutionUncheckedCreateInput>
    /**
     * In case the WorkflowStepExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepExecutionUpdateInput, WorkflowStepExecutionUncheckedUpdateInput>
  }

  /**
   * WorkflowStepExecution delete
   */
  export type WorkflowStepExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStepExecution to delete.
     */
    where: WorkflowStepExecutionWhereUniqueInput
  }

  /**
   * WorkflowStepExecution deleteMany
   */
  export type WorkflowStepExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStepExecutions to delete
     */
    where?: WorkflowStepExecutionWhereInput
  }

  /**
   * WorkflowStepExecution.executedByUser
   */
  export type WorkflowStepExecution$executedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkflowStepExecution without action
   */
  export type WorkflowStepExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStepExecution
     */
    select?: WorkflowStepExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    status: $Enums.SessionStatus | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    status: $Enums.SessionStatus | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshToken: number
    status: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    status?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    status?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    status?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshToken: string
    status: $Enums.SessionStatus
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    status?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    status?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    status?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshToken: string
      status: $Enums.SessionStatus
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly status: FieldRef<"Session", 'SessionStatus'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    currentVersion: number | null
  }

  export type DocumentSumAggregateOutputType = {
    currentVersion: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    title: string | null
    description: string | null
    category: string | null
    status: $Enums.DocumentStatus | null
    accessLevel: $Enums.DocumentAccessLevel | null
    currentVersion: number | null
    createdBy: string | null
    workflowInstanceId: string | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    title: string | null
    description: string | null
    category: string | null
    status: $Enums.DocumentStatus | null
    accessLevel: $Enums.DocumentAccessLevel | null
    currentVersion: number | null
    createdBy: string | null
    workflowInstanceId: string | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    tenantId: number
    title: number
    description: number
    category: number
    status: number
    accessLevel: number
    currentVersion: number
    createdBy: number
    workflowInstanceId: number
    allowedRoles: number
    allowedUsers: number
    metadata: number
    archivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    currentVersion?: true
  }

  export type DocumentSumAggregateInputType = {
    currentVersion?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    description?: true
    category?: true
    status?: true
    accessLevel?: true
    currentVersion?: true
    createdBy?: true
    workflowInstanceId?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    description?: true
    category?: true
    status?: true
    accessLevel?: true
    currentVersion?: true
    createdBy?: true
    workflowInstanceId?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    description?: true
    category?: true
    status?: true
    accessLevel?: true
    currentVersion?: true
    createdBy?: true
    workflowInstanceId?: true
    allowedRoles?: true
    allowedUsers?: true
    metadata?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    tenantId: string
    title: string
    description: string | null
    category: string | null
    status: $Enums.DocumentStatus
    accessLevel: $Enums.DocumentAccessLevel
    currentVersion: number
    createdBy: string
    workflowInstanceId: string | null
    allowedRoles: JsonValue
    allowedUsers: JsonValue
    metadata: JsonValue | null
    archivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    accessLevel?: boolean
    currentVersion?: boolean
    createdBy?: boolean
    workflowInstanceId?: boolean
    allowedRoles?: boolean
    allowedUsers?: boolean
    metadata?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    versions?: boolean | Document$versionsArgs<ExtArgs>
    tags?: boolean | Document$tagsArgs<ExtArgs>
    workflowInstance?: boolean | Document$workflowInstanceArgs<ExtArgs>
    readConfirmations?: boolean | Document$readConfirmationsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    accessLevel?: boolean
    currentVersion?: boolean
    createdBy?: boolean
    workflowInstanceId?: boolean
    allowedRoles?: boolean
    allowedUsers?: boolean
    metadata?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    workflowInstance?: boolean | Document$workflowInstanceArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    accessLevel?: boolean
    currentVersion?: boolean
    createdBy?: boolean
    workflowInstanceId?: boolean
    allowedRoles?: boolean
    allowedUsers?: boolean
    metadata?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    versions?: boolean | Document$versionsArgs<ExtArgs>
    tags?: boolean | Document$tagsArgs<ExtArgs>
    workflowInstance?: boolean | Document$workflowInstanceArgs<ExtArgs>
    readConfirmations?: boolean | Document$readConfirmationsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    workflowInstance?: boolean | Document$workflowInstanceArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      versions: Prisma.$DocumentVersionPayload<ExtArgs>[]
      tags: Prisma.$DocumentTagPayload<ExtArgs>[]
      workflowInstance: Prisma.$WorkflowInstancePayload<ExtArgs> | null
      readConfirmations: Prisma.$DocumentReadConfirmationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      title: string
      description: string | null
      category: string | null
      status: $Enums.DocumentStatus
      accessLevel: $Enums.DocumentAccessLevel
      currentVersion: number
      createdBy: string
      workflowInstanceId: string | null
      allowedRoles: Prisma.JsonValue
      allowedUsers: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      archivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    versions<T extends Document$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Document$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Document$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Document$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany"> | Null>
    workflowInstance<T extends Document$workflowInstanceArgs<ExtArgs> = {}>(args?: Subset<T, Document$workflowInstanceArgs<ExtArgs>>): Prisma__WorkflowInstanceClient<$Result.GetResult<Prisma.$WorkflowInstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    readConfirmations<T extends Document$readConfirmationsArgs<ExtArgs> = {}>(args?: Subset<T, Document$readConfirmationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly tenantId: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly status: FieldRef<"Document", 'DocumentStatus'>
    readonly accessLevel: FieldRef<"Document", 'DocumentAccessLevel'>
    readonly currentVersion: FieldRef<"Document", 'Int'>
    readonly createdBy: FieldRef<"Document", 'String'>
    readonly workflowInstanceId: FieldRef<"Document", 'String'>
    readonly allowedRoles: FieldRef<"Document", 'Json'>
    readonly allowedUsers: FieldRef<"Document", 'Json'>
    readonly metadata: FieldRef<"Document", 'Json'>
    readonly archivedAt: FieldRef<"Document", 'DateTime'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.versions
   */
  export type Document$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    cursor?: DocumentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * Document.tags
   */
  export type Document$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    cursor?: DocumentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * Document.workflowInstance
   */
  export type Document$workflowInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowInstance
     */
    select?: WorkflowInstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInstanceInclude<ExtArgs> | null
    where?: WorkflowInstanceWhereInput
  }

  /**
   * Document.readConfirmations
   */
  export type Document$readConfirmationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    where?: DocumentReadConfirmationWhereInput
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    cursor?: DocumentReadConfirmationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentReadConfirmationScalarFieldEnum | DocumentReadConfirmationScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentVersion
   */

  export type AggregateDocumentVersion = {
    _count: DocumentVersionCountAggregateOutputType | null
    _avg: DocumentVersionAvgAggregateOutputType | null
    _sum: DocumentVersionSumAggregateOutputType | null
    _min: DocumentVersionMinAggregateOutputType | null
    _max: DocumentVersionMaxAggregateOutputType | null
  }

  export type DocumentVersionAvgAggregateOutputType = {
    version: number | null
    size: number | null
  }

  export type DocumentVersionSumAggregateOutputType = {
    version: number | null
    size: number | null
  }

  export type DocumentVersionMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    tenantId: string | null
    version: number | null
    fileName: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    path: string | null
    checksum: string | null
    changeNotes: string | null
    uploadedBy: string | null
    isCurrent: boolean | null
    createdAt: Date | null
  }

  export type DocumentVersionMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    tenantId: string | null
    version: number | null
    fileName: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    path: string | null
    checksum: string | null
    changeNotes: string | null
    uploadedBy: string | null
    isCurrent: boolean | null
    createdAt: Date | null
  }

  export type DocumentVersionCountAggregateOutputType = {
    id: number
    documentId: number
    tenantId: number
    version: number
    fileName: number
    originalName: number
    mimeType: number
    size: number
    path: number
    checksum: number
    changeNotes: number
    uploadedBy: number
    isCurrent: number
    createdAt: number
    _all: number
  }


  export type DocumentVersionAvgAggregateInputType = {
    version?: true
    size?: true
  }

  export type DocumentVersionSumAggregateInputType = {
    version?: true
    size?: true
  }

  export type DocumentVersionMinAggregateInputType = {
    id?: true
    documentId?: true
    tenantId?: true
    version?: true
    fileName?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    checksum?: true
    changeNotes?: true
    uploadedBy?: true
    isCurrent?: true
    createdAt?: true
  }

  export type DocumentVersionMaxAggregateInputType = {
    id?: true
    documentId?: true
    tenantId?: true
    version?: true
    fileName?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    checksum?: true
    changeNotes?: true
    uploadedBy?: true
    isCurrent?: true
    createdAt?: true
  }

  export type DocumentVersionCountAggregateInputType = {
    id?: true
    documentId?: true
    tenantId?: true
    version?: true
    fileName?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    checksum?: true
    changeNotes?: true
    uploadedBy?: true
    isCurrent?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersion to aggregate.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentVersions
    **/
    _count?: true | DocumentVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentVersionMaxAggregateInputType
  }

  export type GetDocumentVersionAggregateType<T extends DocumentVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentVersion[P]>
      : GetScalarType<T[P], AggregateDocumentVersion[P]>
  }




  export type DocumentVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithAggregationInput | DocumentVersionOrderByWithAggregationInput[]
    by: DocumentVersionScalarFieldEnum[] | DocumentVersionScalarFieldEnum
    having?: DocumentVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentVersionCountAggregateInputType | true
    _avg?: DocumentVersionAvgAggregateInputType
    _sum?: DocumentVersionSumAggregateInputType
    _min?: DocumentVersionMinAggregateInputType
    _max?: DocumentVersionMaxAggregateInputType
  }

  export type DocumentVersionGroupByOutputType = {
    id: string
    documentId: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum: string | null
    changeNotes: string | null
    uploadedBy: string
    isCurrent: boolean
    createdAt: Date
    _count: DocumentVersionCountAggregateOutputType | null
    _avg: DocumentVersionAvgAggregateOutputType | null
    _sum: DocumentVersionSumAggregateOutputType | null
    _min: DocumentVersionMinAggregateOutputType | null
    _max: DocumentVersionMaxAggregateOutputType | null
  }

  type GetDocumentVersionGroupByPayload<T extends DocumentVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentVersionGroupByOutputType[P]>
        }
      >
    >


  export type DocumentVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    tenantId?: boolean
    version?: boolean
    fileName?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    checksum?: boolean
    changeNotes?: boolean
    uploadedBy?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersion"]>

  export type DocumentVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    tenantId?: boolean
    version?: boolean
    fileName?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    checksum?: boolean
    changeNotes?: boolean
    uploadedBy?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersion"]>

  export type DocumentVersionSelectScalar = {
    id?: boolean
    documentId?: boolean
    tenantId?: boolean
    version?: boolean
    fileName?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    checksum?: boolean
    changeNotes?: boolean
    uploadedBy?: boolean
    isCurrent?: boolean
    createdAt?: boolean
  }

  export type DocumentVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentVersion"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      tenantId: string
      version: number
      fileName: string
      originalName: string
      mimeType: string
      size: number
      path: string
      checksum: string | null
      changeNotes: string | null
      uploadedBy: string
      isCurrent: boolean
      createdAt: Date
    }, ExtArgs["result"]["documentVersion"]>
    composites: {}
  }

  type DocumentVersionGetPayload<S extends boolean | null | undefined | DocumentVersionDefaultArgs> = $Result.GetResult<Prisma.$DocumentVersionPayload, S>

  type DocumentVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentVersionCountAggregateInputType | true
    }

  export interface DocumentVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentVersion'], meta: { name: 'DocumentVersion' } }
    /**
     * Find zero or one DocumentVersion that matches the filter.
     * @param {DocumentVersionFindUniqueArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentVersionFindUniqueArgs>(args: SelectSubset<T, DocumentVersionFindUniqueArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentVersionFindUniqueOrThrowArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindFirstArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentVersionFindFirstArgs>(args?: SelectSubset<T, DocumentVersionFindFirstArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindFirstOrThrowArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentVersions
     * const documentVersions = await prisma.documentVersion.findMany()
     * 
     * // Get first 10 DocumentVersions
     * const documentVersions = await prisma.documentVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentVersionWithIdOnly = await prisma.documentVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentVersionFindManyArgs>(args?: SelectSubset<T, DocumentVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentVersion.
     * @param {DocumentVersionCreateArgs} args - Arguments to create a DocumentVersion.
     * @example
     * // Create one DocumentVersion
     * const DocumentVersion = await prisma.documentVersion.create({
     *   data: {
     *     // ... data to create a DocumentVersion
     *   }
     * })
     * 
     */
    create<T extends DocumentVersionCreateArgs>(args: SelectSubset<T, DocumentVersionCreateArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentVersions.
     * @param {DocumentVersionCreateManyArgs} args - Arguments to create many DocumentVersions.
     * @example
     * // Create many DocumentVersions
     * const documentVersion = await prisma.documentVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentVersionCreateManyArgs>(args?: SelectSubset<T, DocumentVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentVersions and returns the data saved in the database.
     * @param {DocumentVersionCreateManyAndReturnArgs} args - Arguments to create many DocumentVersions.
     * @example
     * // Create many DocumentVersions
     * const documentVersion = await prisma.documentVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentVersions and only return the `id`
     * const documentVersionWithIdOnly = await prisma.documentVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocumentVersion.
     * @param {DocumentVersionDeleteArgs} args - Arguments to delete one DocumentVersion.
     * @example
     * // Delete one DocumentVersion
     * const DocumentVersion = await prisma.documentVersion.delete({
     *   where: {
     *     // ... filter to delete one DocumentVersion
     *   }
     * })
     * 
     */
    delete<T extends DocumentVersionDeleteArgs>(args: SelectSubset<T, DocumentVersionDeleteArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentVersion.
     * @param {DocumentVersionUpdateArgs} args - Arguments to update one DocumentVersion.
     * @example
     * // Update one DocumentVersion
     * const documentVersion = await prisma.documentVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentVersionUpdateArgs>(args: SelectSubset<T, DocumentVersionUpdateArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentVersions.
     * @param {DocumentVersionDeleteManyArgs} args - Arguments to filter DocumentVersions to delete.
     * @example
     * // Delete a few DocumentVersions
     * const { count } = await prisma.documentVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentVersionDeleteManyArgs>(args?: SelectSubset<T, DocumentVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentVersions
     * const documentVersion = await prisma.documentVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentVersionUpdateManyArgs>(args: SelectSubset<T, DocumentVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentVersion.
     * @param {DocumentVersionUpsertArgs} args - Arguments to update or create a DocumentVersion.
     * @example
     * // Update or create a DocumentVersion
     * const documentVersion = await prisma.documentVersion.upsert({
     *   create: {
     *     // ... data to create a DocumentVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentVersion we want to update
     *   }
     * })
     */
    upsert<T extends DocumentVersionUpsertArgs>(args: SelectSubset<T, DocumentVersionUpsertArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionCountArgs} args - Arguments to filter DocumentVersions to count.
     * @example
     * // Count the number of DocumentVersions
     * const count = await prisma.documentVersion.count({
     *   where: {
     *     // ... the filter for the DocumentVersions we want to count
     *   }
     * })
    **/
    count<T extends DocumentVersionCountArgs>(
      args?: Subset<T, DocumentVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentVersionAggregateArgs>(args: Subset<T, DocumentVersionAggregateArgs>): Prisma.PrismaPromise<GetDocumentVersionAggregateType<T>>

    /**
     * Group by DocumentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentVersionGroupByArgs['orderBy'] }
        : { orderBy?: DocumentVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentVersion model
   */
  readonly fields: DocumentVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentVersion model
   */ 
  interface DocumentVersionFieldRefs {
    readonly id: FieldRef<"DocumentVersion", 'String'>
    readonly documentId: FieldRef<"DocumentVersion", 'String'>
    readonly tenantId: FieldRef<"DocumentVersion", 'String'>
    readonly version: FieldRef<"DocumentVersion", 'Int'>
    readonly fileName: FieldRef<"DocumentVersion", 'String'>
    readonly originalName: FieldRef<"DocumentVersion", 'String'>
    readonly mimeType: FieldRef<"DocumentVersion", 'String'>
    readonly size: FieldRef<"DocumentVersion", 'Int'>
    readonly path: FieldRef<"DocumentVersion", 'String'>
    readonly checksum: FieldRef<"DocumentVersion", 'String'>
    readonly changeNotes: FieldRef<"DocumentVersion", 'String'>
    readonly uploadedBy: FieldRef<"DocumentVersion", 'String'>
    readonly isCurrent: FieldRef<"DocumentVersion", 'Boolean'>
    readonly createdAt: FieldRef<"DocumentVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentVersion findUnique
   */
  export type DocumentVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion findUniqueOrThrow
   */
  export type DocumentVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion findFirst
   */
  export type DocumentVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * DocumentVersion findFirstOrThrow
   */
  export type DocumentVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * DocumentVersion findMany
   */
  export type DocumentVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * DocumentVersion create
   */
  export type DocumentVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentVersion.
     */
    data: XOR<DocumentVersionCreateInput, DocumentVersionUncheckedCreateInput>
  }

  /**
   * DocumentVersion createMany
   */
  export type DocumentVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentVersions.
     */
    data: DocumentVersionCreateManyInput | DocumentVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentVersion createManyAndReturn
   */
  export type DocumentVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocumentVersions.
     */
    data: DocumentVersionCreateManyInput | DocumentVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentVersion update
   */
  export type DocumentVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentVersion.
     */
    data: XOR<DocumentVersionUpdateInput, DocumentVersionUncheckedUpdateInput>
    /**
     * Choose, which DocumentVersion to update.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion updateMany
   */
  export type DocumentVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentVersions.
     */
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVersions to update
     */
    where?: DocumentVersionWhereInput
  }

  /**
   * DocumentVersion upsert
   */
  export type DocumentVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentVersion to update in case it exists.
     */
    where: DocumentVersionWhereUniqueInput
    /**
     * In case the DocumentVersion found by the `where` argument doesn't exist, create a new DocumentVersion with this data.
     */
    create: XOR<DocumentVersionCreateInput, DocumentVersionUncheckedCreateInput>
    /**
     * In case the DocumentVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentVersionUpdateInput, DocumentVersionUncheckedUpdateInput>
  }

  /**
   * DocumentVersion delete
   */
  export type DocumentVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter which DocumentVersion to delete.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion deleteMany
   */
  export type DocumentVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersions to delete
     */
    where?: DocumentVersionWhereInput
  }

  /**
   * DocumentVersion without action
   */
  export type DocumentVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
  }


  /**
   * Model DocumentTag
   */

  export type AggregateDocumentTag = {
    _count: DocumentTagCountAggregateOutputType | null
    _min: DocumentTagMinAggregateOutputType | null
    _max: DocumentTagMaxAggregateOutputType | null
  }

  export type DocumentTagMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    documentId: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type DocumentTagMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    documentId: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
  }

  export type DocumentTagCountAggregateOutputType = {
    id: number
    tenantId: number
    documentId: number
    name: number
    color: number
    createdAt: number
    _all: number
  }


  export type DocumentTagMinAggregateInputType = {
    id?: true
    tenantId?: true
    documentId?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type DocumentTagMaxAggregateInputType = {
    id?: true
    tenantId?: true
    documentId?: true
    name?: true
    color?: true
    createdAt?: true
  }

  export type DocumentTagCountAggregateInputType = {
    id?: true
    tenantId?: true
    documentId?: true
    name?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTag to aggregate.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTags
    **/
    _count?: true | DocumentTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTagMaxAggregateInputType
  }

  export type GetDocumentTagAggregateType<T extends DocumentTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentTag[P]>
      : GetScalarType<T[P], AggregateDocumentTag[P]>
  }




  export type DocumentTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithAggregationInput | DocumentTagOrderByWithAggregationInput[]
    by: DocumentTagScalarFieldEnum[] | DocumentTagScalarFieldEnum
    having?: DocumentTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTagCountAggregateInputType | true
    _min?: DocumentTagMinAggregateInputType
    _max?: DocumentTagMaxAggregateInputType
  }

  export type DocumentTagGroupByOutputType = {
    id: string
    tenantId: string
    documentId: string
    name: string
    color: string | null
    createdAt: Date
    _count: DocumentTagCountAggregateOutputType | null
    _min: DocumentTagMinAggregateOutputType | null
    _max: DocumentTagMaxAggregateOutputType | null
  }

  type GetDocumentTagGroupByPayload<T extends DocumentTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTagGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTagGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    documentId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    documentId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectScalar = {
    id?: boolean
    tenantId?: boolean
    documentId?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type DocumentTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $DocumentTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentTag"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      documentId: string
      name: string
      color: string | null
      createdAt: Date
    }, ExtArgs["result"]["documentTag"]>
    composites: {}
  }

  type DocumentTagGetPayload<S extends boolean | null | undefined | DocumentTagDefaultArgs> = $Result.GetResult<Prisma.$DocumentTagPayload, S>

  type DocumentTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentTagCountAggregateInputType | true
    }

  export interface DocumentTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentTag'], meta: { name: 'DocumentTag' } }
    /**
     * Find zero or one DocumentTag that matches the filter.
     * @param {DocumentTagFindUniqueArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentTagFindUniqueArgs>(args: SelectSubset<T, DocumentTagFindUniqueArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentTagFindUniqueOrThrowArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindFirstArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentTagFindFirstArgs>(args?: SelectSubset<T, DocumentTagFindFirstArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindFirstOrThrowArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTags
     * const documentTags = await prisma.documentTag.findMany()
     * 
     * // Get first 10 DocumentTags
     * const documentTags = await prisma.documentTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentTagFindManyArgs>(args?: SelectSubset<T, DocumentTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentTag.
     * @param {DocumentTagCreateArgs} args - Arguments to create a DocumentTag.
     * @example
     * // Create one DocumentTag
     * const DocumentTag = await prisma.documentTag.create({
     *   data: {
     *     // ... data to create a DocumentTag
     *   }
     * })
     * 
     */
    create<T extends DocumentTagCreateArgs>(args: SelectSubset<T, DocumentTagCreateArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentTags.
     * @param {DocumentTagCreateManyArgs} args - Arguments to create many DocumentTags.
     * @example
     * // Create many DocumentTags
     * const documentTag = await prisma.documentTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentTagCreateManyArgs>(args?: SelectSubset<T, DocumentTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentTags and returns the data saved in the database.
     * @param {DocumentTagCreateManyAndReturnArgs} args - Arguments to create many DocumentTags.
     * @example
     * // Create many DocumentTags
     * const documentTag = await prisma.documentTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentTags and only return the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocumentTag.
     * @param {DocumentTagDeleteArgs} args - Arguments to delete one DocumentTag.
     * @example
     * // Delete one DocumentTag
     * const DocumentTag = await prisma.documentTag.delete({
     *   where: {
     *     // ... filter to delete one DocumentTag
     *   }
     * })
     * 
     */
    delete<T extends DocumentTagDeleteArgs>(args: SelectSubset<T, DocumentTagDeleteArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentTag.
     * @param {DocumentTagUpdateArgs} args - Arguments to update one DocumentTag.
     * @example
     * // Update one DocumentTag
     * const documentTag = await prisma.documentTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentTagUpdateArgs>(args: SelectSubset<T, DocumentTagUpdateArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentTags.
     * @param {DocumentTagDeleteManyArgs} args - Arguments to filter DocumentTags to delete.
     * @example
     * // Delete a few DocumentTags
     * const { count } = await prisma.documentTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentTagDeleteManyArgs>(args?: SelectSubset<T, DocumentTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTags
     * const documentTag = await prisma.documentTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentTagUpdateManyArgs>(args: SelectSubset<T, DocumentTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentTag.
     * @param {DocumentTagUpsertArgs} args - Arguments to update or create a DocumentTag.
     * @example
     * // Update or create a DocumentTag
     * const documentTag = await prisma.documentTag.upsert({
     *   create: {
     *     // ... data to create a DocumentTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentTag we want to update
     *   }
     * })
     */
    upsert<T extends DocumentTagUpsertArgs>(args: SelectSubset<T, DocumentTagUpsertArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagCountArgs} args - Arguments to filter DocumentTags to count.
     * @example
     * // Count the number of DocumentTags
     * const count = await prisma.documentTag.count({
     *   where: {
     *     // ... the filter for the DocumentTags we want to count
     *   }
     * })
    **/
    count<T extends DocumentTagCountArgs>(
      args?: Subset<T, DocumentTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTagAggregateArgs>(args: Subset<T, DocumentTagAggregateArgs>): Prisma.PrismaPromise<GetDocumentTagAggregateType<T>>

    /**
     * Group by DocumentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTagGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentTag model
   */
  readonly fields: DocumentTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentTag model
   */ 
  interface DocumentTagFieldRefs {
    readonly id: FieldRef<"DocumentTag", 'String'>
    readonly tenantId: FieldRef<"DocumentTag", 'String'>
    readonly documentId: FieldRef<"DocumentTag", 'String'>
    readonly name: FieldRef<"DocumentTag", 'String'>
    readonly color: FieldRef<"DocumentTag", 'String'>
    readonly createdAt: FieldRef<"DocumentTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentTag findUnique
   */
  export type DocumentTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag findUniqueOrThrow
   */
  export type DocumentTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag findFirst
   */
  export type DocumentTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTags.
     */
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag findFirstOrThrow
   */
  export type DocumentTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTags.
     */
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag findMany
   */
  export type DocumentTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTags to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag create
   */
  export type DocumentTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentTag.
     */
    data: XOR<DocumentTagCreateInput, DocumentTagUncheckedCreateInput>
  }

  /**
   * DocumentTag createMany
   */
  export type DocumentTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentTags.
     */
    data: DocumentTagCreateManyInput | DocumentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentTag createManyAndReturn
   */
  export type DocumentTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocumentTags.
     */
    data: DocumentTagCreateManyInput | DocumentTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentTag update
   */
  export type DocumentTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentTag.
     */
    data: XOR<DocumentTagUpdateInput, DocumentTagUncheckedUpdateInput>
    /**
     * Choose, which DocumentTag to update.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag updateMany
   */
  export type DocumentTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentTags.
     */
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTags to update
     */
    where?: DocumentTagWhereInput
  }

  /**
   * DocumentTag upsert
   */
  export type DocumentTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentTag to update in case it exists.
     */
    where: DocumentTagWhereUniqueInput
    /**
     * In case the DocumentTag found by the `where` argument doesn't exist, create a new DocumentTag with this data.
     */
    create: XOR<DocumentTagCreateInput, DocumentTagUncheckedCreateInput>
    /**
     * In case the DocumentTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTagUpdateInput, DocumentTagUncheckedUpdateInput>
  }

  /**
   * DocumentTag delete
   */
  export type DocumentTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter which DocumentTag to delete.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag deleteMany
   */
  export type DocumentTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTags to delete
     */
    where?: DocumentTagWhereInput
  }

  /**
   * DocumentTag without action
   */
  export type DocumentTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
  }


  /**
   * Model DocumentReadConfirmation
   */

  export type AggregateDocumentReadConfirmation = {
    _count: DocumentReadConfirmationCountAggregateOutputType | null
    _min: DocumentReadConfirmationMinAggregateOutputType | null
    _max: DocumentReadConfirmationMaxAggregateOutputType | null
  }

  export type DocumentReadConfirmationMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    tenantId: string | null
    userId: string | null
    confirmedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type DocumentReadConfirmationMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    tenantId: string | null
    userId: string | null
    confirmedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type DocumentReadConfirmationCountAggregateOutputType = {
    id: number
    documentId: number
    tenantId: number
    userId: number
    confirmedAt: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type DocumentReadConfirmationMinAggregateInputType = {
    id?: true
    documentId?: true
    tenantId?: true
    userId?: true
    confirmedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type DocumentReadConfirmationMaxAggregateInputType = {
    id?: true
    documentId?: true
    tenantId?: true
    userId?: true
    confirmedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type DocumentReadConfirmationCountAggregateInputType = {
    id?: true
    documentId?: true
    tenantId?: true
    userId?: true
    confirmedAt?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type DocumentReadConfirmationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentReadConfirmation to aggregate.
     */
    where?: DocumentReadConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReadConfirmations to fetch.
     */
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentReadConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReadConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReadConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentReadConfirmations
    **/
    _count?: true | DocumentReadConfirmationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentReadConfirmationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentReadConfirmationMaxAggregateInputType
  }

  export type GetDocumentReadConfirmationAggregateType<T extends DocumentReadConfirmationAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentReadConfirmation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentReadConfirmation[P]>
      : GetScalarType<T[P], AggregateDocumentReadConfirmation[P]>
  }




  export type DocumentReadConfirmationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentReadConfirmationWhereInput
    orderBy?: DocumentReadConfirmationOrderByWithAggregationInput | DocumentReadConfirmationOrderByWithAggregationInput[]
    by: DocumentReadConfirmationScalarFieldEnum[] | DocumentReadConfirmationScalarFieldEnum
    having?: DocumentReadConfirmationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentReadConfirmationCountAggregateInputType | true
    _min?: DocumentReadConfirmationMinAggregateInputType
    _max?: DocumentReadConfirmationMaxAggregateInputType
  }

  export type DocumentReadConfirmationGroupByOutputType = {
    id: string
    documentId: string
    tenantId: string
    userId: string
    confirmedAt: Date
    ipAddress: string | null
    userAgent: string | null
    _count: DocumentReadConfirmationCountAggregateOutputType | null
    _min: DocumentReadConfirmationMinAggregateOutputType | null
    _max: DocumentReadConfirmationMaxAggregateOutputType | null
  }

  type GetDocumentReadConfirmationGroupByPayload<T extends DocumentReadConfirmationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentReadConfirmationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentReadConfirmationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentReadConfirmationGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentReadConfirmationGroupByOutputType[P]>
        }
      >
    >


  export type DocumentReadConfirmationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    tenantId?: boolean
    userId?: boolean
    confirmedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentReadConfirmation"]>

  export type DocumentReadConfirmationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    tenantId?: boolean
    userId?: boolean
    confirmedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentReadConfirmation"]>

  export type DocumentReadConfirmationSelectScalar = {
    id?: boolean
    documentId?: boolean
    tenantId?: boolean
    userId?: boolean
    confirmedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type DocumentReadConfirmationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentReadConfirmationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentReadConfirmationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentReadConfirmation"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      tenantId: string
      userId: string
      confirmedAt: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["documentReadConfirmation"]>
    composites: {}
  }

  type DocumentReadConfirmationGetPayload<S extends boolean | null | undefined | DocumentReadConfirmationDefaultArgs> = $Result.GetResult<Prisma.$DocumentReadConfirmationPayload, S>

  type DocumentReadConfirmationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentReadConfirmationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentReadConfirmationCountAggregateInputType | true
    }

  export interface DocumentReadConfirmationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentReadConfirmation'], meta: { name: 'DocumentReadConfirmation' } }
    /**
     * Find zero or one DocumentReadConfirmation that matches the filter.
     * @param {DocumentReadConfirmationFindUniqueArgs} args - Arguments to find a DocumentReadConfirmation
     * @example
     * // Get one DocumentReadConfirmation
     * const documentReadConfirmation = await prisma.documentReadConfirmation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentReadConfirmationFindUniqueArgs>(args: SelectSubset<T, DocumentReadConfirmationFindUniqueArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DocumentReadConfirmation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentReadConfirmationFindUniqueOrThrowArgs} args - Arguments to find a DocumentReadConfirmation
     * @example
     * // Get one DocumentReadConfirmation
     * const documentReadConfirmation = await prisma.documentReadConfirmation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentReadConfirmationFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentReadConfirmationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DocumentReadConfirmation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationFindFirstArgs} args - Arguments to find a DocumentReadConfirmation
     * @example
     * // Get one DocumentReadConfirmation
     * const documentReadConfirmation = await prisma.documentReadConfirmation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentReadConfirmationFindFirstArgs>(args?: SelectSubset<T, DocumentReadConfirmationFindFirstArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DocumentReadConfirmation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationFindFirstOrThrowArgs} args - Arguments to find a DocumentReadConfirmation
     * @example
     * // Get one DocumentReadConfirmation
     * const documentReadConfirmation = await prisma.documentReadConfirmation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentReadConfirmationFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentReadConfirmationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DocumentReadConfirmations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentReadConfirmations
     * const documentReadConfirmations = await prisma.documentReadConfirmation.findMany()
     * 
     * // Get first 10 DocumentReadConfirmations
     * const documentReadConfirmations = await prisma.documentReadConfirmation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentReadConfirmationWithIdOnly = await prisma.documentReadConfirmation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentReadConfirmationFindManyArgs>(args?: SelectSubset<T, DocumentReadConfirmationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DocumentReadConfirmation.
     * @param {DocumentReadConfirmationCreateArgs} args - Arguments to create a DocumentReadConfirmation.
     * @example
     * // Create one DocumentReadConfirmation
     * const DocumentReadConfirmation = await prisma.documentReadConfirmation.create({
     *   data: {
     *     // ... data to create a DocumentReadConfirmation
     *   }
     * })
     * 
     */
    create<T extends DocumentReadConfirmationCreateArgs>(args: SelectSubset<T, DocumentReadConfirmationCreateArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DocumentReadConfirmations.
     * @param {DocumentReadConfirmationCreateManyArgs} args - Arguments to create many DocumentReadConfirmations.
     * @example
     * // Create many DocumentReadConfirmations
     * const documentReadConfirmation = await prisma.documentReadConfirmation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentReadConfirmationCreateManyArgs>(args?: SelectSubset<T, DocumentReadConfirmationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentReadConfirmations and returns the data saved in the database.
     * @param {DocumentReadConfirmationCreateManyAndReturnArgs} args - Arguments to create many DocumentReadConfirmations.
     * @example
     * // Create many DocumentReadConfirmations
     * const documentReadConfirmation = await prisma.documentReadConfirmation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentReadConfirmations and only return the `id`
     * const documentReadConfirmationWithIdOnly = await prisma.documentReadConfirmation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentReadConfirmationCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentReadConfirmationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DocumentReadConfirmation.
     * @param {DocumentReadConfirmationDeleteArgs} args - Arguments to delete one DocumentReadConfirmation.
     * @example
     * // Delete one DocumentReadConfirmation
     * const DocumentReadConfirmation = await prisma.documentReadConfirmation.delete({
     *   where: {
     *     // ... filter to delete one DocumentReadConfirmation
     *   }
     * })
     * 
     */
    delete<T extends DocumentReadConfirmationDeleteArgs>(args: SelectSubset<T, DocumentReadConfirmationDeleteArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DocumentReadConfirmation.
     * @param {DocumentReadConfirmationUpdateArgs} args - Arguments to update one DocumentReadConfirmation.
     * @example
     * // Update one DocumentReadConfirmation
     * const documentReadConfirmation = await prisma.documentReadConfirmation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentReadConfirmationUpdateArgs>(args: SelectSubset<T, DocumentReadConfirmationUpdateArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DocumentReadConfirmations.
     * @param {DocumentReadConfirmationDeleteManyArgs} args - Arguments to filter DocumentReadConfirmations to delete.
     * @example
     * // Delete a few DocumentReadConfirmations
     * const { count } = await prisma.documentReadConfirmation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentReadConfirmationDeleteManyArgs>(args?: SelectSubset<T, DocumentReadConfirmationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentReadConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentReadConfirmations
     * const documentReadConfirmation = await prisma.documentReadConfirmation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentReadConfirmationUpdateManyArgs>(args: SelectSubset<T, DocumentReadConfirmationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentReadConfirmation.
     * @param {DocumentReadConfirmationUpsertArgs} args - Arguments to update or create a DocumentReadConfirmation.
     * @example
     * // Update or create a DocumentReadConfirmation
     * const documentReadConfirmation = await prisma.documentReadConfirmation.upsert({
     *   create: {
     *     // ... data to create a DocumentReadConfirmation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentReadConfirmation we want to update
     *   }
     * })
     */
    upsert<T extends DocumentReadConfirmationUpsertArgs>(args: SelectSubset<T, DocumentReadConfirmationUpsertArgs<ExtArgs>>): Prisma__DocumentReadConfirmationClient<$Result.GetResult<Prisma.$DocumentReadConfirmationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DocumentReadConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationCountArgs} args - Arguments to filter DocumentReadConfirmations to count.
     * @example
     * // Count the number of DocumentReadConfirmations
     * const count = await prisma.documentReadConfirmation.count({
     *   where: {
     *     // ... the filter for the DocumentReadConfirmations we want to count
     *   }
     * })
    **/
    count<T extends DocumentReadConfirmationCountArgs>(
      args?: Subset<T, DocumentReadConfirmationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentReadConfirmationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentReadConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentReadConfirmationAggregateArgs>(args: Subset<T, DocumentReadConfirmationAggregateArgs>): Prisma.PrismaPromise<GetDocumentReadConfirmationAggregateType<T>>

    /**
     * Group by DocumentReadConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentReadConfirmationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentReadConfirmationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentReadConfirmationGroupByArgs['orderBy'] }
        : { orderBy?: DocumentReadConfirmationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentReadConfirmationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentReadConfirmationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentReadConfirmation model
   */
  readonly fields: DocumentReadConfirmationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentReadConfirmation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentReadConfirmationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentReadConfirmation model
   */ 
  interface DocumentReadConfirmationFieldRefs {
    readonly id: FieldRef<"DocumentReadConfirmation", 'String'>
    readonly documentId: FieldRef<"DocumentReadConfirmation", 'String'>
    readonly tenantId: FieldRef<"DocumentReadConfirmation", 'String'>
    readonly userId: FieldRef<"DocumentReadConfirmation", 'String'>
    readonly confirmedAt: FieldRef<"DocumentReadConfirmation", 'DateTime'>
    readonly ipAddress: FieldRef<"DocumentReadConfirmation", 'String'>
    readonly userAgent: FieldRef<"DocumentReadConfirmation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentReadConfirmation findUnique
   */
  export type DocumentReadConfirmationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReadConfirmation to fetch.
     */
    where: DocumentReadConfirmationWhereUniqueInput
  }

  /**
   * DocumentReadConfirmation findUniqueOrThrow
   */
  export type DocumentReadConfirmationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReadConfirmation to fetch.
     */
    where: DocumentReadConfirmationWhereUniqueInput
  }

  /**
   * DocumentReadConfirmation findFirst
   */
  export type DocumentReadConfirmationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReadConfirmation to fetch.
     */
    where?: DocumentReadConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReadConfirmations to fetch.
     */
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentReadConfirmations.
     */
    cursor?: DocumentReadConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReadConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReadConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentReadConfirmations.
     */
    distinct?: DocumentReadConfirmationScalarFieldEnum | DocumentReadConfirmationScalarFieldEnum[]
  }

  /**
   * DocumentReadConfirmation findFirstOrThrow
   */
  export type DocumentReadConfirmationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReadConfirmation to fetch.
     */
    where?: DocumentReadConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReadConfirmations to fetch.
     */
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentReadConfirmations.
     */
    cursor?: DocumentReadConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReadConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReadConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentReadConfirmations.
     */
    distinct?: DocumentReadConfirmationScalarFieldEnum | DocumentReadConfirmationScalarFieldEnum[]
  }

  /**
   * DocumentReadConfirmation findMany
   */
  export type DocumentReadConfirmationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentReadConfirmations to fetch.
     */
    where?: DocumentReadConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentReadConfirmations to fetch.
     */
    orderBy?: DocumentReadConfirmationOrderByWithRelationInput | DocumentReadConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentReadConfirmations.
     */
    cursor?: DocumentReadConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentReadConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentReadConfirmations.
     */
    skip?: number
    distinct?: DocumentReadConfirmationScalarFieldEnum | DocumentReadConfirmationScalarFieldEnum[]
  }

  /**
   * DocumentReadConfirmation create
   */
  export type DocumentReadConfirmationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentReadConfirmation.
     */
    data: XOR<DocumentReadConfirmationCreateInput, DocumentReadConfirmationUncheckedCreateInput>
  }

  /**
   * DocumentReadConfirmation createMany
   */
  export type DocumentReadConfirmationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentReadConfirmations.
     */
    data: DocumentReadConfirmationCreateManyInput | DocumentReadConfirmationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentReadConfirmation createManyAndReturn
   */
  export type DocumentReadConfirmationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DocumentReadConfirmations.
     */
    data: DocumentReadConfirmationCreateManyInput | DocumentReadConfirmationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentReadConfirmation update
   */
  export type DocumentReadConfirmationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentReadConfirmation.
     */
    data: XOR<DocumentReadConfirmationUpdateInput, DocumentReadConfirmationUncheckedUpdateInput>
    /**
     * Choose, which DocumentReadConfirmation to update.
     */
    where: DocumentReadConfirmationWhereUniqueInput
  }

  /**
   * DocumentReadConfirmation updateMany
   */
  export type DocumentReadConfirmationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentReadConfirmations.
     */
    data: XOR<DocumentReadConfirmationUpdateManyMutationInput, DocumentReadConfirmationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentReadConfirmations to update
     */
    where?: DocumentReadConfirmationWhereInput
  }

  /**
   * DocumentReadConfirmation upsert
   */
  export type DocumentReadConfirmationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentReadConfirmation to update in case it exists.
     */
    where: DocumentReadConfirmationWhereUniqueInput
    /**
     * In case the DocumentReadConfirmation found by the `where` argument doesn't exist, create a new DocumentReadConfirmation with this data.
     */
    create: XOR<DocumentReadConfirmationCreateInput, DocumentReadConfirmationUncheckedCreateInput>
    /**
     * In case the DocumentReadConfirmation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentReadConfirmationUpdateInput, DocumentReadConfirmationUncheckedUpdateInput>
  }

  /**
   * DocumentReadConfirmation delete
   */
  export type DocumentReadConfirmationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
    /**
     * Filter which DocumentReadConfirmation to delete.
     */
    where: DocumentReadConfirmationWhereUniqueInput
  }

  /**
   * DocumentReadConfirmation deleteMany
   */
  export type DocumentReadConfirmationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentReadConfirmations to delete
     */
    where?: DocumentReadConfirmationWhereInput
  }

  /**
   * DocumentReadConfirmation without action
   */
  export type DocumentReadConfirmationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentReadConfirmation
     */
    select?: DocumentReadConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentReadConfirmationInclude<ExtArgs> | null
  }


  /**
   * Model ReportTemplate
   */

  export type AggregateReportTemplate = {
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  export type ReportTemplateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    reportType: $Enums.ReportType | null
    status: $Enums.ReportStatus | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    reportType: $Enums.ReportType | null
    status: $Enums.ReportStatus | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    reportType: number
    status: number
    isPublic: number
    createdBy: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportTemplateMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    reportType?: true
    status?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    reportType?: true
    status?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    reportType?: true
    status?: true
    isPublic?: true
    createdBy?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplate to aggregate.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportTemplates
    **/
    _count?: true | ReportTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type GetReportTemplateAggregateType<T extends ReportTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateReportTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportTemplate[P]>
      : GetScalarType<T[P], AggregateReportTemplate[P]>
  }




  export type ReportTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithAggregationInput | ReportTemplateOrderByWithAggregationInput[]
    by: ReportTemplateScalarFieldEnum[] | ReportTemplateScalarFieldEnum
    having?: ReportTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportTemplateCountAggregateInputType | true
    _min?: ReportTemplateMinAggregateInputType
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type ReportTemplateGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    reportType: $Enums.ReportType
    status: $Enums.ReportStatus
    isPublic: boolean
    createdBy: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  type GetReportTemplateGroupByPayload<T extends ReportTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ReportTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    status?: boolean
    isPublic?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    components?: boolean | ReportTemplate$componentsArgs<ExtArgs>
    instances?: boolean | ReportTemplate$instancesArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    status?: boolean
    isPublic?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    reportType?: boolean
    status?: boolean
    isPublic?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    components?: boolean | ReportTemplate$componentsArgs<ExtArgs>
    instances?: boolean | ReportTemplate$instancesArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      components: Prisma.$ReportComponentPayload<ExtArgs>[]
      instances: Prisma.$ScheduledReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      reportType: $Enums.ReportType
      status: $Enums.ReportStatus
      isPublic: boolean
      createdBy: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportTemplate"]>
    composites: {}
  }

  type ReportTemplateGetPayload<S extends boolean | null | undefined | ReportTemplateDefaultArgs> = $Result.GetResult<Prisma.$ReportTemplatePayload, S>

  type ReportTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportTemplateCountAggregateInputType | true
    }

  export interface ReportTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportTemplate'], meta: { name: 'ReportTemplate' } }
    /**
     * Find zero or one ReportTemplate that matches the filter.
     * @param {ReportTemplateFindUniqueArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportTemplateFindUniqueArgs>(args: SelectSubset<T, ReportTemplateFindUniqueArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportTemplateFindUniqueOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportTemplateFindFirstArgs>(args?: SelectSubset<T, ReportTemplateFindFirstArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany()
     * 
     * // Get first 10 ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportTemplateFindManyArgs>(args?: SelectSubset<T, ReportTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportTemplate.
     * @param {ReportTemplateCreateArgs} args - Arguments to create a ReportTemplate.
     * @example
     * // Create one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.create({
     *   data: {
     *     // ... data to create a ReportTemplate
     *   }
     * })
     * 
     */
    create<T extends ReportTemplateCreateArgs>(args: SelectSubset<T, ReportTemplateCreateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportTemplates.
     * @param {ReportTemplateCreateManyArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportTemplateCreateManyArgs>(args?: SelectSubset<T, ReportTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportTemplates and returns the data saved in the database.
     * @param {ReportTemplateCreateManyAndReturnArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportTemplate.
     * @param {ReportTemplateDeleteArgs} args - Arguments to delete one ReportTemplate.
     * @example
     * // Delete one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.delete({
     *   where: {
     *     // ... filter to delete one ReportTemplate
     *   }
     * })
     * 
     */
    delete<T extends ReportTemplateDeleteArgs>(args: SelectSubset<T, ReportTemplateDeleteArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportTemplate.
     * @param {ReportTemplateUpdateArgs} args - Arguments to update one ReportTemplate.
     * @example
     * // Update one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportTemplateUpdateArgs>(args: SelectSubset<T, ReportTemplateUpdateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportTemplates.
     * @param {ReportTemplateDeleteManyArgs} args - Arguments to filter ReportTemplates to delete.
     * @example
     * // Delete a few ReportTemplates
     * const { count } = await prisma.reportTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportTemplateDeleteManyArgs>(args?: SelectSubset<T, ReportTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportTemplateUpdateManyArgs>(args: SelectSubset<T, ReportTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportTemplate.
     * @param {ReportTemplateUpsertArgs} args - Arguments to update or create a ReportTemplate.
     * @example
     * // Update or create a ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.upsert({
     *   create: {
     *     // ... data to create a ReportTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ReportTemplateUpsertArgs>(args: SelectSubset<T, ReportTemplateUpsertArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateCountArgs} args - Arguments to filter ReportTemplates to count.
     * @example
     * // Count the number of ReportTemplates
     * const count = await prisma.reportTemplate.count({
     *   where: {
     *     // ... the filter for the ReportTemplates we want to count
     *   }
     * })
    **/
    count<T extends ReportTemplateCountArgs>(
      args?: Subset<T, ReportTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportTemplateAggregateArgs>(args: Subset<T, ReportTemplateAggregateArgs>): Prisma.PrismaPromise<GetReportTemplateAggregateType<T>>

    /**
     * Group by ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ReportTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportTemplate model
   */
  readonly fields: ReportTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    components<T extends ReportTemplate$componentsArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "findMany"> | Null>
    instances<T extends ReportTemplate$instancesArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportTemplate model
   */ 
  interface ReportTemplateFieldRefs {
    readonly id: FieldRef<"ReportTemplate", 'String'>
    readonly tenantId: FieldRef<"ReportTemplate", 'String'>
    readonly name: FieldRef<"ReportTemplate", 'String'>
    readonly description: FieldRef<"ReportTemplate", 'String'>
    readonly reportType: FieldRef<"ReportTemplate", 'ReportType'>
    readonly status: FieldRef<"ReportTemplate", 'ReportStatus'>
    readonly isPublic: FieldRef<"ReportTemplate", 'Boolean'>
    readonly createdBy: FieldRef<"ReportTemplate", 'String'>
    readonly metadata: FieldRef<"ReportTemplate", 'Json'>
    readonly createdAt: FieldRef<"ReportTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportTemplate findUnique
   */
  export type ReportTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findUniqueOrThrow
   */
  export type ReportTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findFirst
   */
  export type ReportTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findFirstOrThrow
   */
  export type ReportTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findMany
   */
  export type ReportTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplates to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate create
   */
  export type ReportTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportTemplate.
     */
    data: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
  }

  /**
   * ReportTemplate createMany
   */
  export type ReportTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate createManyAndReturn
   */
  export type ReportTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportTemplate update
   */
  export type ReportTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportTemplate.
     */
    data: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
    /**
     * Choose, which ReportTemplate to update.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate updateMany
   */
  export type ReportTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
  }

  /**
   * ReportTemplate upsert
   */
  export type ReportTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportTemplate to update in case it exists.
     */
    where: ReportTemplateWhereUniqueInput
    /**
     * In case the ReportTemplate found by the `where` argument doesn't exist, create a new ReportTemplate with this data.
     */
    create: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
    /**
     * In case the ReportTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
  }

  /**
   * ReportTemplate delete
   */
  export type ReportTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter which ReportTemplate to delete.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate deleteMany
   */
  export type ReportTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplates to delete
     */
    where?: ReportTemplateWhereInput
  }

  /**
   * ReportTemplate.components
   */
  export type ReportTemplate$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    where?: ReportComponentWhereInput
    orderBy?: ReportComponentOrderByWithRelationInput | ReportComponentOrderByWithRelationInput[]
    cursor?: ReportComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportComponentScalarFieldEnum | ReportComponentScalarFieldEnum[]
  }

  /**
   * ReportTemplate.instances
   */
  export type ReportTemplate$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    cursor?: ScheduledReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ReportTemplate without action
   */
  export type ReportTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ReportComponent
   */

  export type AggregateReportComponent = {
    _count: ReportComponentCountAggregateOutputType | null
    _avg: ReportComponentAvgAggregateOutputType | null
    _sum: ReportComponentSumAggregateOutputType | null
    _min: ReportComponentMinAggregateOutputType | null
    _max: ReportComponentMaxAggregateOutputType | null
  }

  export type ReportComponentAvgAggregateOutputType = {
    order: number | null
  }

  export type ReportComponentSumAggregateOutputType = {
    order: number | null
  }

  export type ReportComponentMinAggregateOutputType = {
    id: string | null
    reportTemplateId: string | null
    componentType: $Enums.ReportComponentType | null
    order: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportComponentMaxAggregateOutputType = {
    id: string | null
    reportTemplateId: string | null
    componentType: $Enums.ReportComponentType | null
    order: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportComponentCountAggregateOutputType = {
    id: number
    reportTemplateId: number
    componentType: number
    order: number
    title: number
    configuration: number
    dataSource: number
    style: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportComponentAvgAggregateInputType = {
    order?: true
  }

  export type ReportComponentSumAggregateInputType = {
    order?: true
  }

  export type ReportComponentMinAggregateInputType = {
    id?: true
    reportTemplateId?: true
    componentType?: true
    order?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportComponentMaxAggregateInputType = {
    id?: true
    reportTemplateId?: true
    componentType?: true
    order?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportComponentCountAggregateInputType = {
    id?: true
    reportTemplateId?: true
    componentType?: true
    order?: true
    title?: true
    configuration?: true
    dataSource?: true
    style?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportComponent to aggregate.
     */
    where?: ReportComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComponents to fetch.
     */
    orderBy?: ReportComponentOrderByWithRelationInput | ReportComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportComponents
    **/
    _count?: true | ReportComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportComponentMaxAggregateInputType
  }

  export type GetReportComponentAggregateType<T extends ReportComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateReportComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportComponent[P]>
      : GetScalarType<T[P], AggregateReportComponent[P]>
  }




  export type ReportComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportComponentWhereInput
    orderBy?: ReportComponentOrderByWithAggregationInput | ReportComponentOrderByWithAggregationInput[]
    by: ReportComponentScalarFieldEnum[] | ReportComponentScalarFieldEnum
    having?: ReportComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportComponentCountAggregateInputType | true
    _avg?: ReportComponentAvgAggregateInputType
    _sum?: ReportComponentSumAggregateInputType
    _min?: ReportComponentMinAggregateInputType
    _max?: ReportComponentMaxAggregateInputType
  }

  export type ReportComponentGroupByOutputType = {
    id: string
    reportTemplateId: string
    componentType: $Enums.ReportComponentType
    order: number
    title: string | null
    configuration: JsonValue
    dataSource: JsonValue | null
    style: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ReportComponentCountAggregateOutputType | null
    _avg: ReportComponentAvgAggregateOutputType | null
    _sum: ReportComponentSumAggregateOutputType | null
    _min: ReportComponentMinAggregateOutputType | null
    _max: ReportComponentMaxAggregateOutputType | null
  }

  type GetReportComponentGroupByPayload<T extends ReportComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ReportComponentGroupByOutputType[P]>
        }
      >
    >


  export type ReportComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportTemplateId?: boolean
    componentType?: boolean
    order?: boolean
    title?: boolean
    configuration?: boolean
    dataSource?: boolean
    style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportComponent"]>

  export type ReportComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportTemplateId?: boolean
    componentType?: boolean
    order?: boolean
    title?: boolean
    configuration?: boolean
    dataSource?: boolean
    style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportComponent"]>

  export type ReportComponentSelectScalar = {
    id?: boolean
    reportTemplateId?: boolean
    componentType?: boolean
    order?: boolean
    title?: boolean
    configuration?: boolean
    dataSource?: boolean
    style?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
  }
  export type ReportComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
  }

  export type $ReportComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportComponent"
    objects: {
      reportTemplate: Prisma.$ReportTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportTemplateId: string
      componentType: $Enums.ReportComponentType
      order: number
      title: string | null
      configuration: Prisma.JsonValue
      dataSource: Prisma.JsonValue | null
      style: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportComponent"]>
    composites: {}
  }

  type ReportComponentGetPayload<S extends boolean | null | undefined | ReportComponentDefaultArgs> = $Result.GetResult<Prisma.$ReportComponentPayload, S>

  type ReportComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportComponentCountAggregateInputType | true
    }

  export interface ReportComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportComponent'], meta: { name: 'ReportComponent' } }
    /**
     * Find zero or one ReportComponent that matches the filter.
     * @param {ReportComponentFindUniqueArgs} args - Arguments to find a ReportComponent
     * @example
     * // Get one ReportComponent
     * const reportComponent = await prisma.reportComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportComponentFindUniqueArgs>(args: SelectSubset<T, ReportComponentFindUniqueArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportComponent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportComponentFindUniqueOrThrowArgs} args - Arguments to find a ReportComponent
     * @example
     * // Get one ReportComponent
     * const reportComponent = await prisma.reportComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentFindFirstArgs} args - Arguments to find a ReportComponent
     * @example
     * // Get one ReportComponent
     * const reportComponent = await prisma.reportComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportComponentFindFirstArgs>(args?: SelectSubset<T, ReportComponentFindFirstArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportComponent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentFindFirstOrThrowArgs} args - Arguments to find a ReportComponent
     * @example
     * // Get one ReportComponent
     * const reportComponent = await prisma.reportComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportComponents
     * const reportComponents = await prisma.reportComponent.findMany()
     * 
     * // Get first 10 ReportComponents
     * const reportComponents = await prisma.reportComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportComponentWithIdOnly = await prisma.reportComponent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportComponentFindManyArgs>(args?: SelectSubset<T, ReportComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportComponent.
     * @param {ReportComponentCreateArgs} args - Arguments to create a ReportComponent.
     * @example
     * // Create one ReportComponent
     * const ReportComponent = await prisma.reportComponent.create({
     *   data: {
     *     // ... data to create a ReportComponent
     *   }
     * })
     * 
     */
    create<T extends ReportComponentCreateArgs>(args: SelectSubset<T, ReportComponentCreateArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportComponents.
     * @param {ReportComponentCreateManyArgs} args - Arguments to create many ReportComponents.
     * @example
     * // Create many ReportComponents
     * const reportComponent = await prisma.reportComponent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportComponentCreateManyArgs>(args?: SelectSubset<T, ReportComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportComponents and returns the data saved in the database.
     * @param {ReportComponentCreateManyAndReturnArgs} args - Arguments to create many ReportComponents.
     * @example
     * // Create many ReportComponents
     * const reportComponent = await prisma.reportComponent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportComponents and only return the `id`
     * const reportComponentWithIdOnly = await prisma.reportComponent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportComponent.
     * @param {ReportComponentDeleteArgs} args - Arguments to delete one ReportComponent.
     * @example
     * // Delete one ReportComponent
     * const ReportComponent = await prisma.reportComponent.delete({
     *   where: {
     *     // ... filter to delete one ReportComponent
     *   }
     * })
     * 
     */
    delete<T extends ReportComponentDeleteArgs>(args: SelectSubset<T, ReportComponentDeleteArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportComponent.
     * @param {ReportComponentUpdateArgs} args - Arguments to update one ReportComponent.
     * @example
     * // Update one ReportComponent
     * const reportComponent = await prisma.reportComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportComponentUpdateArgs>(args: SelectSubset<T, ReportComponentUpdateArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportComponents.
     * @param {ReportComponentDeleteManyArgs} args - Arguments to filter ReportComponents to delete.
     * @example
     * // Delete a few ReportComponents
     * const { count } = await prisma.reportComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportComponentDeleteManyArgs>(args?: SelectSubset<T, ReportComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportComponents
     * const reportComponent = await prisma.reportComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportComponentUpdateManyArgs>(args: SelectSubset<T, ReportComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportComponent.
     * @param {ReportComponentUpsertArgs} args - Arguments to update or create a ReportComponent.
     * @example
     * // Update or create a ReportComponent
     * const reportComponent = await prisma.reportComponent.upsert({
     *   create: {
     *     // ... data to create a ReportComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportComponent we want to update
     *   }
     * })
     */
    upsert<T extends ReportComponentUpsertArgs>(args: SelectSubset<T, ReportComponentUpsertArgs<ExtArgs>>): Prisma__ReportComponentClient<$Result.GetResult<Prisma.$ReportComponentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentCountArgs} args - Arguments to filter ReportComponents to count.
     * @example
     * // Count the number of ReportComponents
     * const count = await prisma.reportComponent.count({
     *   where: {
     *     // ... the filter for the ReportComponents we want to count
     *   }
     * })
    **/
    count<T extends ReportComponentCountArgs>(
      args?: Subset<T, ReportComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportComponentAggregateArgs>(args: Subset<T, ReportComponentAggregateArgs>): Prisma.PrismaPromise<GetReportComponentAggregateType<T>>

    /**
     * Group by ReportComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportComponentGroupByArgs['orderBy'] }
        : { orderBy?: ReportComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportComponent model
   */
  readonly fields: ReportComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reportTemplate<T extends ReportTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplateDefaultArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportComponent model
   */ 
  interface ReportComponentFieldRefs {
    readonly id: FieldRef<"ReportComponent", 'String'>
    readonly reportTemplateId: FieldRef<"ReportComponent", 'String'>
    readonly componentType: FieldRef<"ReportComponent", 'ReportComponentType'>
    readonly order: FieldRef<"ReportComponent", 'Int'>
    readonly title: FieldRef<"ReportComponent", 'String'>
    readonly configuration: FieldRef<"ReportComponent", 'Json'>
    readonly dataSource: FieldRef<"ReportComponent", 'Json'>
    readonly style: FieldRef<"ReportComponent", 'Json'>
    readonly createdAt: FieldRef<"ReportComponent", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportComponent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportComponent findUnique
   */
  export type ReportComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * Filter, which ReportComponent to fetch.
     */
    where: ReportComponentWhereUniqueInput
  }

  /**
   * ReportComponent findUniqueOrThrow
   */
  export type ReportComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * Filter, which ReportComponent to fetch.
     */
    where: ReportComponentWhereUniqueInput
  }

  /**
   * ReportComponent findFirst
   */
  export type ReportComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * Filter, which ReportComponent to fetch.
     */
    where?: ReportComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComponents to fetch.
     */
    orderBy?: ReportComponentOrderByWithRelationInput | ReportComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportComponents.
     */
    cursor?: ReportComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportComponents.
     */
    distinct?: ReportComponentScalarFieldEnum | ReportComponentScalarFieldEnum[]
  }

  /**
   * ReportComponent findFirstOrThrow
   */
  export type ReportComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * Filter, which ReportComponent to fetch.
     */
    where?: ReportComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComponents to fetch.
     */
    orderBy?: ReportComponentOrderByWithRelationInput | ReportComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportComponents.
     */
    cursor?: ReportComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportComponents.
     */
    distinct?: ReportComponentScalarFieldEnum | ReportComponentScalarFieldEnum[]
  }

  /**
   * ReportComponent findMany
   */
  export type ReportComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * Filter, which ReportComponents to fetch.
     */
    where?: ReportComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportComponents to fetch.
     */
    orderBy?: ReportComponentOrderByWithRelationInput | ReportComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportComponents.
     */
    cursor?: ReportComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportComponents.
     */
    skip?: number
    distinct?: ReportComponentScalarFieldEnum | ReportComponentScalarFieldEnum[]
  }

  /**
   * ReportComponent create
   */
  export type ReportComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportComponent.
     */
    data: XOR<ReportComponentCreateInput, ReportComponentUncheckedCreateInput>
  }

  /**
   * ReportComponent createMany
   */
  export type ReportComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportComponents.
     */
    data: ReportComponentCreateManyInput | ReportComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportComponent createManyAndReturn
   */
  export type ReportComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportComponents.
     */
    data: ReportComponentCreateManyInput | ReportComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportComponent update
   */
  export type ReportComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportComponent.
     */
    data: XOR<ReportComponentUpdateInput, ReportComponentUncheckedUpdateInput>
    /**
     * Choose, which ReportComponent to update.
     */
    where: ReportComponentWhereUniqueInput
  }

  /**
   * ReportComponent updateMany
   */
  export type ReportComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportComponents.
     */
    data: XOR<ReportComponentUpdateManyMutationInput, ReportComponentUncheckedUpdateManyInput>
    /**
     * Filter which ReportComponents to update
     */
    where?: ReportComponentWhereInput
  }

  /**
   * ReportComponent upsert
   */
  export type ReportComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportComponent to update in case it exists.
     */
    where: ReportComponentWhereUniqueInput
    /**
     * In case the ReportComponent found by the `where` argument doesn't exist, create a new ReportComponent with this data.
     */
    create: XOR<ReportComponentCreateInput, ReportComponentUncheckedCreateInput>
    /**
     * In case the ReportComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportComponentUpdateInput, ReportComponentUncheckedUpdateInput>
  }

  /**
   * ReportComponent delete
   */
  export type ReportComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
    /**
     * Filter which ReportComponent to delete.
     */
    where: ReportComponentWhereUniqueInput
  }

  /**
   * ReportComponent deleteMany
   */
  export type ReportComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportComponents to delete
     */
    where?: ReportComponentWhereInput
  }

  /**
   * ReportComponent without action
   */
  export type ReportComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportComponent
     */
    select?: ReportComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportComponentInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledReport
   */

  export type AggregateScheduledReport = {
    _count: ScheduledReportCountAggregateOutputType | null
    _min: ScheduledReportMinAggregateOutputType | null
    _max: ScheduledReportMaxAggregateOutputType | null
  }

  export type ScheduledReportMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    reportTemplateId: string | null
    name: string | null
    description: string | null
    frequency: $Enums.ReportFrequency | null
    schedule: string | null
    status: $Enums.ReportStatus | null
    enabled: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledReportMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    reportTemplateId: string | null
    name: string | null
    description: string | null
    frequency: $Enums.ReportFrequency | null
    schedule: string | null
    status: $Enums.ReportStatus | null
    enabled: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledReportCountAggregateOutputType = {
    id: number
    tenantId: number
    reportTemplateId: number
    name: number
    description: number
    frequency: number
    schedule: number
    recipients: number
    format: number
    filters: number
    status: number
    enabled: number
    lastRunAt: number
    nextRunAt: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledReportMinAggregateInputType = {
    id?: true
    tenantId?: true
    reportTemplateId?: true
    name?: true
    description?: true
    frequency?: true
    schedule?: true
    status?: true
    enabled?: true
    lastRunAt?: true
    nextRunAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledReportMaxAggregateInputType = {
    id?: true
    tenantId?: true
    reportTemplateId?: true
    name?: true
    description?: true
    frequency?: true
    schedule?: true
    status?: true
    enabled?: true
    lastRunAt?: true
    nextRunAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledReportCountAggregateInputType = {
    id?: true
    tenantId?: true
    reportTemplateId?: true
    name?: true
    description?: true
    frequency?: true
    schedule?: true
    recipients?: true
    format?: true
    filters?: true
    status?: true
    enabled?: true
    lastRunAt?: true
    nextRunAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReport to aggregate.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledReports
    **/
    _count?: true | ScheduledReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledReportMaxAggregateInputType
  }

  export type GetScheduledReportAggregateType<T extends ScheduledReportAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledReport[P]>
      : GetScalarType<T[P], AggregateScheduledReport[P]>
  }




  export type ScheduledReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReportWhereInput
    orderBy?: ScheduledReportOrderByWithAggregationInput | ScheduledReportOrderByWithAggregationInput[]
    by: ScheduledReportScalarFieldEnum[] | ScheduledReportScalarFieldEnum
    having?: ScheduledReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledReportCountAggregateInputType | true
    _min?: ScheduledReportMinAggregateInputType
    _max?: ScheduledReportMaxAggregateInputType
  }

  export type ScheduledReportGroupByOutputType = {
    id: string
    tenantId: string
    reportTemplateId: string
    name: string
    description: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients: JsonValue
    format: JsonValue
    filters: JsonValue | null
    status: $Enums.ReportStatus
    enabled: boolean
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ScheduledReportCountAggregateOutputType | null
    _min: ScheduledReportMinAggregateOutputType | null
    _max: ScheduledReportMaxAggregateOutputType | null
  }

  type GetScheduledReportGroupByPayload<T extends ScheduledReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledReportGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledReportGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    reportTemplateId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    schedule?: boolean
    recipients?: boolean
    format?: boolean
    filters?: boolean
    status?: boolean
    enabled?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | ScheduledReport$executionsArgs<ExtArgs>
    _count?: boolean | ScheduledReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    reportTemplateId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    schedule?: boolean
    recipients?: boolean
    format?: boolean
    filters?: boolean
    status?: boolean
    enabled?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReport"]>

  export type ScheduledReportSelectScalar = {
    id?: boolean
    tenantId?: boolean
    reportTemplateId?: boolean
    name?: boolean
    description?: boolean
    frequency?: boolean
    schedule?: boolean
    recipients?: boolean
    format?: boolean
    filters?: boolean
    status?: boolean
    enabled?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | ScheduledReport$executionsArgs<ExtArgs>
    _count?: boolean | ScheduledReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduledReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | ReportTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScheduledReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledReport"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      reportTemplate: Prisma.$ReportTemplatePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$ReportExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      reportTemplateId: string
      name: string
      description: string | null
      frequency: $Enums.ReportFrequency
      schedule: string
      recipients: Prisma.JsonValue
      format: Prisma.JsonValue
      filters: Prisma.JsonValue | null
      status: $Enums.ReportStatus
      enabled: boolean
      lastRunAt: Date | null
      nextRunAt: Date | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledReport"]>
    composites: {}
  }

  type ScheduledReportGetPayload<S extends boolean | null | undefined | ScheduledReportDefaultArgs> = $Result.GetResult<Prisma.$ScheduledReportPayload, S>

  type ScheduledReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledReportCountAggregateInputType | true
    }

  export interface ScheduledReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledReport'], meta: { name: 'ScheduledReport' } }
    /**
     * Find zero or one ScheduledReport that matches the filter.
     * @param {ScheduledReportFindUniqueArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledReportFindUniqueArgs>(args: SelectSubset<T, ScheduledReportFindUniqueArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledReportFindUniqueOrThrowArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindFirstArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledReportFindFirstArgs>(args?: SelectSubset<T, ScheduledReportFindFirstArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindFirstOrThrowArgs} args - Arguments to find a ScheduledReport
     * @example
     * // Get one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledReports
     * const scheduledReports = await prisma.scheduledReport.findMany()
     * 
     * // Get first 10 ScheduledReports
     * const scheduledReports = await prisma.scheduledReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledReportFindManyArgs>(args?: SelectSubset<T, ScheduledReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledReport.
     * @param {ScheduledReportCreateArgs} args - Arguments to create a ScheduledReport.
     * @example
     * // Create one ScheduledReport
     * const ScheduledReport = await prisma.scheduledReport.create({
     *   data: {
     *     // ... data to create a ScheduledReport
     *   }
     * })
     * 
     */
    create<T extends ScheduledReportCreateArgs>(args: SelectSubset<T, ScheduledReportCreateArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledReports.
     * @param {ScheduledReportCreateManyArgs} args - Arguments to create many ScheduledReports.
     * @example
     * // Create many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledReportCreateManyArgs>(args?: SelectSubset<T, ScheduledReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledReports and returns the data saved in the database.
     * @param {ScheduledReportCreateManyAndReturnArgs} args - Arguments to create many ScheduledReports.
     * @example
     * // Create many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledReports and only return the `id`
     * const scheduledReportWithIdOnly = await prisma.scheduledReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledReport.
     * @param {ScheduledReportDeleteArgs} args - Arguments to delete one ScheduledReport.
     * @example
     * // Delete one ScheduledReport
     * const ScheduledReport = await prisma.scheduledReport.delete({
     *   where: {
     *     // ... filter to delete one ScheduledReport
     *   }
     * })
     * 
     */
    delete<T extends ScheduledReportDeleteArgs>(args: SelectSubset<T, ScheduledReportDeleteArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledReport.
     * @param {ScheduledReportUpdateArgs} args - Arguments to update one ScheduledReport.
     * @example
     * // Update one ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledReportUpdateArgs>(args: SelectSubset<T, ScheduledReportUpdateArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledReports.
     * @param {ScheduledReportDeleteManyArgs} args - Arguments to filter ScheduledReports to delete.
     * @example
     * // Delete a few ScheduledReports
     * const { count } = await prisma.scheduledReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledReportDeleteManyArgs>(args?: SelectSubset<T, ScheduledReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledReports
     * const scheduledReport = await prisma.scheduledReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledReportUpdateManyArgs>(args: SelectSubset<T, ScheduledReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledReport.
     * @param {ScheduledReportUpsertArgs} args - Arguments to update or create a ScheduledReport.
     * @example
     * // Update or create a ScheduledReport
     * const scheduledReport = await prisma.scheduledReport.upsert({
     *   create: {
     *     // ... data to create a ScheduledReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledReport we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledReportUpsertArgs>(args: SelectSubset<T, ScheduledReportUpsertArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportCountArgs} args - Arguments to filter ScheduledReports to count.
     * @example
     * // Count the number of ScheduledReports
     * const count = await prisma.scheduledReport.count({
     *   where: {
     *     // ... the filter for the ScheduledReports we want to count
     *   }
     * })
    **/
    count<T extends ScheduledReportCountArgs>(
      args?: Subset<T, ScheduledReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledReportAggregateArgs>(args: Subset<T, ScheduledReportAggregateArgs>): Prisma.PrismaPromise<GetScheduledReportAggregateType<T>>

    /**
     * Group by ScheduledReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledReportGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledReport model
   */
  readonly fields: ScheduledReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reportTemplate<T extends ReportTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplateDefaultArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends ScheduledReport$executionsArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledReport$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledReport model
   */ 
  interface ScheduledReportFieldRefs {
    readonly id: FieldRef<"ScheduledReport", 'String'>
    readonly tenantId: FieldRef<"ScheduledReport", 'String'>
    readonly reportTemplateId: FieldRef<"ScheduledReport", 'String'>
    readonly name: FieldRef<"ScheduledReport", 'String'>
    readonly description: FieldRef<"ScheduledReport", 'String'>
    readonly frequency: FieldRef<"ScheduledReport", 'ReportFrequency'>
    readonly schedule: FieldRef<"ScheduledReport", 'String'>
    readonly recipients: FieldRef<"ScheduledReport", 'Json'>
    readonly format: FieldRef<"ScheduledReport", 'Json'>
    readonly filters: FieldRef<"ScheduledReport", 'Json'>
    readonly status: FieldRef<"ScheduledReport", 'ReportStatus'>
    readonly enabled: FieldRef<"ScheduledReport", 'Boolean'>
    readonly lastRunAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly nextRunAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly createdBy: FieldRef<"ScheduledReport", 'String'>
    readonly createdAt: FieldRef<"ScheduledReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledReport findUnique
   */
  export type ScheduledReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport findUniqueOrThrow
   */
  export type ScheduledReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport findFirst
   */
  export type ScheduledReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReports.
     */
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport findFirstOrThrow
   */
  export type ScheduledReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReport to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReports.
     */
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport findMany
   */
  export type ScheduledReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReports to fetch.
     */
    where?: ScheduledReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReports to fetch.
     */
    orderBy?: ScheduledReportOrderByWithRelationInput | ScheduledReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledReports.
     */
    cursor?: ScheduledReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReports.
     */
    skip?: number
    distinct?: ScheduledReportScalarFieldEnum | ScheduledReportScalarFieldEnum[]
  }

  /**
   * ScheduledReport create
   */
  export type ScheduledReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledReport.
     */
    data: XOR<ScheduledReportCreateInput, ScheduledReportUncheckedCreateInput>
  }

  /**
   * ScheduledReport createMany
   */
  export type ScheduledReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledReports.
     */
    data: ScheduledReportCreateManyInput | ScheduledReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledReport createManyAndReturn
   */
  export type ScheduledReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledReports.
     */
    data: ScheduledReportCreateManyInput | ScheduledReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReport update
   */
  export type ScheduledReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledReport.
     */
    data: XOR<ScheduledReportUpdateInput, ScheduledReportUncheckedUpdateInput>
    /**
     * Choose, which ScheduledReport to update.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport updateMany
   */
  export type ScheduledReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledReports.
     */
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReports to update
     */
    where?: ScheduledReportWhereInput
  }

  /**
   * ScheduledReport upsert
   */
  export type ScheduledReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledReport to update in case it exists.
     */
    where: ScheduledReportWhereUniqueInput
    /**
     * In case the ScheduledReport found by the `where` argument doesn't exist, create a new ScheduledReport with this data.
     */
    create: XOR<ScheduledReportCreateInput, ScheduledReportUncheckedCreateInput>
    /**
     * In case the ScheduledReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledReportUpdateInput, ScheduledReportUncheckedUpdateInput>
  }

  /**
   * ScheduledReport delete
   */
  export type ScheduledReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
    /**
     * Filter which ScheduledReport to delete.
     */
    where: ScheduledReportWhereUniqueInput
  }

  /**
   * ScheduledReport deleteMany
   */
  export type ScheduledReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReports to delete
     */
    where?: ScheduledReportWhereInput
  }

  /**
   * ScheduledReport.executions
   */
  export type ScheduledReport$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    where?: ReportExecutionWhereInput
    orderBy?: ReportExecutionOrderByWithRelationInput | ReportExecutionOrderByWithRelationInput[]
    cursor?: ReportExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportExecutionScalarFieldEnum | ReportExecutionScalarFieldEnum[]
  }

  /**
   * ScheduledReport without action
   */
  export type ScheduledReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReport
     */
    select?: ScheduledReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportExecution
   */

  export type AggregateReportExecution = {
    _count: ReportExecutionCountAggregateOutputType | null
    _avg: ReportExecutionAvgAggregateOutputType | null
    _sum: ReportExecutionSumAggregateOutputType | null
    _min: ReportExecutionMinAggregateOutputType | null
    _max: ReportExecutionMaxAggregateOutputType | null
  }

  export type ReportExecutionAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ReportExecutionSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ReportExecutionMinAggregateOutputType = {
    id: string | null
    scheduledReportId: string | null
    status: string | null
    errorMessage: string | null
    filePath: string | null
    fileSize: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ReportExecutionMaxAggregateOutputType = {
    id: string | null
    scheduledReportId: string | null
    status: string | null
    errorMessage: string | null
    filePath: string | null
    fileSize: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ReportExecutionCountAggregateOutputType = {
    id: number
    scheduledReportId: number
    status: number
    errorMessage: number
    filePath: number
    fileSize: number
    startedAt: number
    completedAt: number
    metadata: number
    _all: number
  }


  export type ReportExecutionAvgAggregateInputType = {
    fileSize?: true
  }

  export type ReportExecutionSumAggregateInputType = {
    fileSize?: true
  }

  export type ReportExecutionMinAggregateInputType = {
    id?: true
    scheduledReportId?: true
    status?: true
    errorMessage?: true
    filePath?: true
    fileSize?: true
    startedAt?: true
    completedAt?: true
  }

  export type ReportExecutionMaxAggregateInputType = {
    id?: true
    scheduledReportId?: true
    status?: true
    errorMessage?: true
    filePath?: true
    fileSize?: true
    startedAt?: true
    completedAt?: true
  }

  export type ReportExecutionCountAggregateInputType = {
    id?: true
    scheduledReportId?: true
    status?: true
    errorMessage?: true
    filePath?: true
    fileSize?: true
    startedAt?: true
    completedAt?: true
    metadata?: true
    _all?: true
  }

  export type ReportExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportExecution to aggregate.
     */
    where?: ReportExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportExecutions to fetch.
     */
    orderBy?: ReportExecutionOrderByWithRelationInput | ReportExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportExecutions
    **/
    _count?: true | ReportExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportExecutionMaxAggregateInputType
  }

  export type GetReportExecutionAggregateType<T extends ReportExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateReportExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportExecution[P]>
      : GetScalarType<T[P], AggregateReportExecution[P]>
  }




  export type ReportExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportExecutionWhereInput
    orderBy?: ReportExecutionOrderByWithAggregationInput | ReportExecutionOrderByWithAggregationInput[]
    by: ReportExecutionScalarFieldEnum[] | ReportExecutionScalarFieldEnum
    having?: ReportExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportExecutionCountAggregateInputType | true
    _avg?: ReportExecutionAvgAggregateInputType
    _sum?: ReportExecutionSumAggregateInputType
    _min?: ReportExecutionMinAggregateInputType
    _max?: ReportExecutionMaxAggregateInputType
  }

  export type ReportExecutionGroupByOutputType = {
    id: string
    scheduledReportId: string
    status: string
    errorMessage: string | null
    filePath: string | null
    fileSize: number | null
    startedAt: Date
    completedAt: Date | null
    metadata: JsonValue | null
    _count: ReportExecutionCountAggregateOutputType | null
    _avg: ReportExecutionAvgAggregateOutputType | null
    _sum: ReportExecutionSumAggregateOutputType | null
    _min: ReportExecutionMinAggregateOutputType | null
    _max: ReportExecutionMaxAggregateOutputType | null
  }

  type GetReportExecutionGroupByPayload<T extends ReportExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], ReportExecutionGroupByOutputType[P]>
        }
      >
    >


  export type ReportExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledReportId?: boolean
    status?: boolean
    errorMessage?: boolean
    filePath?: boolean
    fileSize?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    scheduledReport?: boolean | ScheduledReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportExecution"]>

  export type ReportExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledReportId?: boolean
    status?: boolean
    errorMessage?: boolean
    filePath?: boolean
    fileSize?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    scheduledReport?: boolean | ScheduledReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportExecution"]>

  export type ReportExecutionSelectScalar = {
    id?: boolean
    scheduledReportId?: boolean
    status?: boolean
    errorMessage?: boolean
    filePath?: boolean
    fileSize?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
  }

  export type ReportExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledReport?: boolean | ScheduledReportDefaultArgs<ExtArgs>
  }
  export type ReportExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduledReport?: boolean | ScheduledReportDefaultArgs<ExtArgs>
  }

  export type $ReportExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportExecution"
    objects: {
      scheduledReport: Prisma.$ScheduledReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduledReportId: string
      status: string
      errorMessage: string | null
      filePath: string | null
      fileSize: number | null
      startedAt: Date
      completedAt: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["reportExecution"]>
    composites: {}
  }

  type ReportExecutionGetPayload<S extends boolean | null | undefined | ReportExecutionDefaultArgs> = $Result.GetResult<Prisma.$ReportExecutionPayload, S>

  type ReportExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportExecutionCountAggregateInputType | true
    }

  export interface ReportExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportExecution'], meta: { name: 'ReportExecution' } }
    /**
     * Find zero or one ReportExecution that matches the filter.
     * @param {ReportExecutionFindUniqueArgs} args - Arguments to find a ReportExecution
     * @example
     * // Get one ReportExecution
     * const reportExecution = await prisma.reportExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportExecutionFindUniqueArgs>(args: SelectSubset<T, ReportExecutionFindUniqueArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportExecutionFindUniqueOrThrowArgs} args - Arguments to find a ReportExecution
     * @example
     * // Get one ReportExecution
     * const reportExecution = await prisma.reportExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionFindFirstArgs} args - Arguments to find a ReportExecution
     * @example
     * // Get one ReportExecution
     * const reportExecution = await prisma.reportExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportExecutionFindFirstArgs>(args?: SelectSubset<T, ReportExecutionFindFirstArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionFindFirstOrThrowArgs} args - Arguments to find a ReportExecution
     * @example
     * // Get one ReportExecution
     * const reportExecution = await prisma.reportExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportExecutions
     * const reportExecutions = await prisma.reportExecution.findMany()
     * 
     * // Get first 10 ReportExecutions
     * const reportExecutions = await prisma.reportExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportExecutionWithIdOnly = await prisma.reportExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportExecutionFindManyArgs>(args?: SelectSubset<T, ReportExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportExecution.
     * @param {ReportExecutionCreateArgs} args - Arguments to create a ReportExecution.
     * @example
     * // Create one ReportExecution
     * const ReportExecution = await prisma.reportExecution.create({
     *   data: {
     *     // ... data to create a ReportExecution
     *   }
     * })
     * 
     */
    create<T extends ReportExecutionCreateArgs>(args: SelectSubset<T, ReportExecutionCreateArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportExecutions.
     * @param {ReportExecutionCreateManyArgs} args - Arguments to create many ReportExecutions.
     * @example
     * // Create many ReportExecutions
     * const reportExecution = await prisma.reportExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportExecutionCreateManyArgs>(args?: SelectSubset<T, ReportExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportExecutions and returns the data saved in the database.
     * @param {ReportExecutionCreateManyAndReturnArgs} args - Arguments to create many ReportExecutions.
     * @example
     * // Create many ReportExecutions
     * const reportExecution = await prisma.reportExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportExecutions and only return the `id`
     * const reportExecutionWithIdOnly = await prisma.reportExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportExecution.
     * @param {ReportExecutionDeleteArgs} args - Arguments to delete one ReportExecution.
     * @example
     * // Delete one ReportExecution
     * const ReportExecution = await prisma.reportExecution.delete({
     *   where: {
     *     // ... filter to delete one ReportExecution
     *   }
     * })
     * 
     */
    delete<T extends ReportExecutionDeleteArgs>(args: SelectSubset<T, ReportExecutionDeleteArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportExecution.
     * @param {ReportExecutionUpdateArgs} args - Arguments to update one ReportExecution.
     * @example
     * // Update one ReportExecution
     * const reportExecution = await prisma.reportExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportExecutionUpdateArgs>(args: SelectSubset<T, ReportExecutionUpdateArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportExecutions.
     * @param {ReportExecutionDeleteManyArgs} args - Arguments to filter ReportExecutions to delete.
     * @example
     * // Delete a few ReportExecutions
     * const { count } = await prisma.reportExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportExecutionDeleteManyArgs>(args?: SelectSubset<T, ReportExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportExecutions
     * const reportExecution = await prisma.reportExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportExecutionUpdateManyArgs>(args: SelectSubset<T, ReportExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportExecution.
     * @param {ReportExecutionUpsertArgs} args - Arguments to update or create a ReportExecution.
     * @example
     * // Update or create a ReportExecution
     * const reportExecution = await prisma.reportExecution.upsert({
     *   create: {
     *     // ... data to create a ReportExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportExecution we want to update
     *   }
     * })
     */
    upsert<T extends ReportExecutionUpsertArgs>(args: SelectSubset<T, ReportExecutionUpsertArgs<ExtArgs>>): Prisma__ReportExecutionClient<$Result.GetResult<Prisma.$ReportExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionCountArgs} args - Arguments to filter ReportExecutions to count.
     * @example
     * // Count the number of ReportExecutions
     * const count = await prisma.reportExecution.count({
     *   where: {
     *     // ... the filter for the ReportExecutions we want to count
     *   }
     * })
    **/
    count<T extends ReportExecutionCountArgs>(
      args?: Subset<T, ReportExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportExecutionAggregateArgs>(args: Subset<T, ReportExecutionAggregateArgs>): Prisma.PrismaPromise<GetReportExecutionAggregateType<T>>

    /**
     * Group by ReportExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportExecutionGroupByArgs['orderBy'] }
        : { orderBy?: ReportExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportExecution model
   */
  readonly fields: ReportExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scheduledReport<T extends ScheduledReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledReportDefaultArgs<ExtArgs>>): Prisma__ScheduledReportClient<$Result.GetResult<Prisma.$ScheduledReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportExecution model
   */ 
  interface ReportExecutionFieldRefs {
    readonly id: FieldRef<"ReportExecution", 'String'>
    readonly scheduledReportId: FieldRef<"ReportExecution", 'String'>
    readonly status: FieldRef<"ReportExecution", 'String'>
    readonly errorMessage: FieldRef<"ReportExecution", 'String'>
    readonly filePath: FieldRef<"ReportExecution", 'String'>
    readonly fileSize: FieldRef<"ReportExecution", 'Int'>
    readonly startedAt: FieldRef<"ReportExecution", 'DateTime'>
    readonly completedAt: FieldRef<"ReportExecution", 'DateTime'>
    readonly metadata: FieldRef<"ReportExecution", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ReportExecution findUnique
   */
  export type ReportExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ReportExecution to fetch.
     */
    where: ReportExecutionWhereUniqueInput
  }

  /**
   * ReportExecution findUniqueOrThrow
   */
  export type ReportExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ReportExecution to fetch.
     */
    where: ReportExecutionWhereUniqueInput
  }

  /**
   * ReportExecution findFirst
   */
  export type ReportExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ReportExecution to fetch.
     */
    where?: ReportExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportExecutions to fetch.
     */
    orderBy?: ReportExecutionOrderByWithRelationInput | ReportExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportExecutions.
     */
    cursor?: ReportExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportExecutions.
     */
    distinct?: ReportExecutionScalarFieldEnum | ReportExecutionScalarFieldEnum[]
  }

  /**
   * ReportExecution findFirstOrThrow
   */
  export type ReportExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ReportExecution to fetch.
     */
    where?: ReportExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportExecutions to fetch.
     */
    orderBy?: ReportExecutionOrderByWithRelationInput | ReportExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportExecutions.
     */
    cursor?: ReportExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportExecutions.
     */
    distinct?: ReportExecutionScalarFieldEnum | ReportExecutionScalarFieldEnum[]
  }

  /**
   * ReportExecution findMany
   */
  export type ReportExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ReportExecutions to fetch.
     */
    where?: ReportExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportExecutions to fetch.
     */
    orderBy?: ReportExecutionOrderByWithRelationInput | ReportExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportExecutions.
     */
    cursor?: ReportExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportExecutions.
     */
    skip?: number
    distinct?: ReportExecutionScalarFieldEnum | ReportExecutionScalarFieldEnum[]
  }

  /**
   * ReportExecution create
   */
  export type ReportExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportExecution.
     */
    data: XOR<ReportExecutionCreateInput, ReportExecutionUncheckedCreateInput>
  }

  /**
   * ReportExecution createMany
   */
  export type ReportExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportExecutions.
     */
    data: ReportExecutionCreateManyInput | ReportExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportExecution createManyAndReturn
   */
  export type ReportExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportExecutions.
     */
    data: ReportExecutionCreateManyInput | ReportExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportExecution update
   */
  export type ReportExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportExecution.
     */
    data: XOR<ReportExecutionUpdateInput, ReportExecutionUncheckedUpdateInput>
    /**
     * Choose, which ReportExecution to update.
     */
    where: ReportExecutionWhereUniqueInput
  }

  /**
   * ReportExecution updateMany
   */
  export type ReportExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportExecutions.
     */
    data: XOR<ReportExecutionUpdateManyMutationInput, ReportExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ReportExecutions to update
     */
    where?: ReportExecutionWhereInput
  }

  /**
   * ReportExecution upsert
   */
  export type ReportExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportExecution to update in case it exists.
     */
    where: ReportExecutionWhereUniqueInput
    /**
     * In case the ReportExecution found by the `where` argument doesn't exist, create a new ReportExecution with this data.
     */
    create: XOR<ReportExecutionCreateInput, ReportExecutionUncheckedCreateInput>
    /**
     * In case the ReportExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportExecutionUpdateInput, ReportExecutionUncheckedUpdateInput>
  }

  /**
   * ReportExecution delete
   */
  export type ReportExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
    /**
     * Filter which ReportExecution to delete.
     */
    where: ReportExecutionWhereUniqueInput
  }

  /**
   * ReportExecution deleteMany
   */
  export type ReportExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportExecutions to delete
     */
    where?: ReportExecutionWhereInput
  }

  /**
   * ReportExecution without action
   */
  export type ReportExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportExecution
     */
    select?: ReportExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportExecutionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    link: 'link',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InternalAuditScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    auditProgramId: 'auditProgramId',
    ano: 'ano',
    entidadeAuditora: 'entidadeAuditora',
    iso: 'iso',
    inicio: 'inicio',
    termino: 'termino',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InternalAuditScalarFieldEnum = (typeof InternalAuditScalarFieldEnum)[keyof typeof InternalAuditScalarFieldEnum]


  export const ExternalAuditScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    auditProgramId: 'auditProgramId',
    ano: 'ano',
    entidadeAuditora: 'entidadeAuditora',
    iso: 'iso',
    inicio: 'inicio',
    termino: 'termino',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalAuditScalarFieldEnum = (typeof ExternalAuditScalarFieldEnum)[keyof typeof ExternalAuditScalarFieldEnum]


  export const AuditProgramScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    standard: 'standard',
    version: 'version',
    isTemplate: 'isTemplate',
    templateId: 'templateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditProgramScalarFieldEnum = (typeof AuditProgramScalarFieldEnum)[keyof typeof AuditProgramScalarFieldEnum]


  export const AuditChecklistScalarFieldEnum: {
    id: 'id',
    auditProgramId: 'auditProgramId',
    clause: 'clause',
    item: 'item',
    requirement: 'requirement',
    evidenceType: 'evidenceType',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditChecklistScalarFieldEnum = (typeof AuditChecklistScalarFieldEnum)[keyof typeof AuditChecklistScalarFieldEnum]


  export const ActionItemScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    origem: 'origem',
    acaoRelacionada: 'acaoRelacionada',
    conformidade: 'conformidade',
    numeroAssociado: 'numeroAssociado',
    ambito: 'ambito',
    descricao: 'descricao',
    causaRaizIdentificada: 'causaRaizIdentificada',
    acaoCorretiva: 'acaoCorretiva',
    local: 'local',
    responsavel: 'responsavel',
    inicio: 'inicio',
    termino: 'termino',
    conclusao: 'conclusao',
    status: 'status',
    mes: 'mes',
    evidencia: 'evidencia',
    avaliacaoEficacia: 'avaliacaoEficacia',
    setor: 'setor',
    dataAbertura: 'dataAbertura',
    dataLimite: 'dataLimite',
    dataConclusao: 'dataConclusao',
    impacto: 'impacto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionItemScalarFieldEnum = (typeof ActionItemScalarFieldEnum)[keyof typeof ActionItemScalarFieldEnum]


  export const RootCauseAnalysisScalarFieldEnum: {
    id: 'id',
    actionItemId: 'actionItemId',
    tenantId: 'tenantId',
    analysisType: 'analysisType',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RootCauseAnalysisScalarFieldEnum = (typeof RootCauseAnalysisScalarFieldEnum)[keyof typeof RootCauseAnalysisScalarFieldEnum]


  export const OccurrenceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tipo: 'tipo',
    setor: 'setor',
    departamentosAtingidos: 'departamentosAtingidos',
    responsavel: 'responsavel',
    data: 'data',
    descricao: 'descricao',
    resolucao: 'resolucao',
    gravidade: 'gravidade',
    acaoGerada: 'acaoGerada',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OccurrenceScalarFieldEnum = (typeof OccurrenceScalarFieldEnum)[keyof typeof OccurrenceScalarFieldEnum]


  export const SectorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    nome: 'nome',
    responsavel: 'responsavel',
    email: 'email',
    telefone: 'telefone',
    descricao: 'descricao',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectorScalarFieldEnum = (typeof SectorScalarFieldEnum)[keyof typeof SectorScalarFieldEnum]


  export const ImportLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    fileName: 'fileName',
    mode: 'mode',
    entity: 'entity',
    status: 'status',
    totalRecords: 'totalRecords',
    createdAt: 'createdAt',
    finishedAt: 'finishedAt',
    errorMessage: 'errorMessage'
  };

  export type ImportLogScalarFieldEnum = (typeof ImportLogScalarFieldEnum)[keyof typeof ImportLogScalarFieldEnum]


  export const AuditTrailScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditTrailScalarFieldEnum = (typeof AuditTrailScalarFieldEnum)[keyof typeof AuditTrailScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    entityType: 'entityType',
    entityId: 'entityId',
    fileName: 'fileName',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    path: 'path',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    entityType: 'entityType',
    entityId: 'entityId',
    content: 'content',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    entityType: 'entityType',
    entityId: 'entityId',
    status: 'status',
    requestedBy: 'requestedBy',
    approvedBy: 'approvedBy',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    approvedAt: 'approvedAt'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const WorkflowDefinitionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    entityType: 'entityType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowDefinitionScalarFieldEnum = (typeof WorkflowDefinitionScalarFieldEnum)[keyof typeof WorkflowDefinitionScalarFieldEnum]


  export const WorkflowStepScalarFieldEnum: {
    id: 'id',
    workflowDefinitionId: 'workflowDefinitionId',
    stepOrder: 'stepOrder',
    stepType: 'stepType',
    name: 'name',
    description: 'description',
    requiredRoles: 'requiredRoles',
    requiredUsers: 'requiredUsers',
    conditionExpression: 'conditionExpression',
    notificationTemplate: 'notificationTemplate',
    autoAdvance: 'autoAdvance',
    timeoutDays: 'timeoutDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowStepScalarFieldEnum = (typeof WorkflowStepScalarFieldEnum)[keyof typeof WorkflowStepScalarFieldEnum]


  export const WorkflowInstanceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    workflowDefinitionId: 'workflowDefinitionId',
    entityType: 'entityType',
    entityId: 'entityId',
    status: 'status',
    startedBy: 'startedBy',
    currentStepOrder: 'currentStepOrder',
    completedAt: 'completedAt',
    cancelledAt: 'cancelledAt',
    cancelledBy: 'cancelledBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowInstanceScalarFieldEnum = (typeof WorkflowInstanceScalarFieldEnum)[keyof typeof WorkflowInstanceScalarFieldEnum]


  export const WorkflowStepExecutionScalarFieldEnum: {
    id: 'id',
    workflowInstanceId: 'workflowInstanceId',
    stepOrder: 'stepOrder',
    stepType: 'stepType',
    status: 'status',
    executedBy: 'executedBy',
    comments: 'comments',
    executedAt: 'executedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkflowStepExecutionScalarFieldEnum = (typeof WorkflowStepExecutionScalarFieldEnum)[keyof typeof WorkflowStepExecutionScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshToken: 'refreshToken',
    status: 'status',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    title: 'title',
    description: 'description',
    category: 'category',
    status: 'status',
    accessLevel: 'accessLevel',
    currentVersion: 'currentVersion',
    createdBy: 'createdBy',
    workflowInstanceId: 'workflowInstanceId',
    allowedRoles: 'allowedRoles',
    allowedUsers: 'allowedUsers',
    metadata: 'metadata',
    archivedAt: 'archivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentVersionScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    tenantId: 'tenantId',
    version: 'version',
    fileName: 'fileName',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    path: 'path',
    checksum: 'checksum',
    changeNotes: 'changeNotes',
    uploadedBy: 'uploadedBy',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt'
  };

  export type DocumentVersionScalarFieldEnum = (typeof DocumentVersionScalarFieldEnum)[keyof typeof DocumentVersionScalarFieldEnum]


  export const DocumentTagScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    documentId: 'documentId',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type DocumentTagScalarFieldEnum = (typeof DocumentTagScalarFieldEnum)[keyof typeof DocumentTagScalarFieldEnum]


  export const DocumentReadConfirmationScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    tenantId: 'tenantId',
    userId: 'userId',
    confirmedAt: 'confirmedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type DocumentReadConfirmationScalarFieldEnum = (typeof DocumentReadConfirmationScalarFieldEnum)[keyof typeof DocumentReadConfirmationScalarFieldEnum]


  export const ReportTemplateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    reportType: 'reportType',
    status: 'status',
    isPublic: 'isPublic',
    createdBy: 'createdBy',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportTemplateScalarFieldEnum = (typeof ReportTemplateScalarFieldEnum)[keyof typeof ReportTemplateScalarFieldEnum]


  export const ReportComponentScalarFieldEnum: {
    id: 'id',
    reportTemplateId: 'reportTemplateId',
    componentType: 'componentType',
    order: 'order',
    title: 'title',
    configuration: 'configuration',
    dataSource: 'dataSource',
    style: 'style',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportComponentScalarFieldEnum = (typeof ReportComponentScalarFieldEnum)[keyof typeof ReportComponentScalarFieldEnum]


  export const ScheduledReportScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    reportTemplateId: 'reportTemplateId',
    name: 'name',
    description: 'description',
    frequency: 'frequency',
    schedule: 'schedule',
    recipients: 'recipients',
    format: 'format',
    filters: 'filters',
    status: 'status',
    enabled: 'enabled',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledReportScalarFieldEnum = (typeof ScheduledReportScalarFieldEnum)[keyof typeof ScheduledReportScalarFieldEnum]


  export const ReportExecutionScalarFieldEnum: {
    id: 'id',
    scheduledReportId: 'scheduledReportId',
    status: 'status',
    errorMessage: 'errorMessage',
    filePath: 'filePath',
    fileSize: 'fileSize',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    metadata: 'metadata'
  };

  export type ReportExecutionScalarFieldEnum = (typeof ReportExecutionScalarFieldEnum)[keyof typeof ReportExecutionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ActionOrigin'
   */
  export type EnumActionOriginFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionOrigin'>
    


  /**
   * Reference to a field of type 'ActionOrigin[]'
   */
  export type ListEnumActionOriginFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionOrigin[]'>
    


  /**
   * Reference to a field of type 'Conformidade'
   */
  export type EnumConformidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Conformidade'>
    


  /**
   * Reference to a field of type 'Conformidade[]'
   */
  export type ListEnumConformidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Conformidade[]'>
    


  /**
   * Reference to a field of type 'ActionStatus'
   */
  export type EnumActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionStatus'>
    


  /**
   * Reference to a field of type 'ActionStatus[]'
   */
  export type ListEnumActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionStatus[]'>
    


  /**
   * Reference to a field of type 'Impact'
   */
  export type EnumImpactFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Impact'>
    


  /**
   * Reference to a field of type 'Impact[]'
   */
  export type ListEnumImpactFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Impact[]'>
    


  /**
   * Reference to a field of type 'RootCauseAnalysisType'
   */
  export type EnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RootCauseAnalysisType'>
    


  /**
   * Reference to a field of type 'RootCauseAnalysisType[]'
   */
  export type ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RootCauseAnalysisType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'OccurrenceType'
   */
  export type EnumOccurrenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceType'>
    


  /**
   * Reference to a field of type 'OccurrenceType[]'
   */
  export type ListEnumOccurrenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceType[]'>
    


  /**
   * Reference to a field of type 'OccurrenceSeverity'
   */
  export type EnumOccurrenceSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceSeverity'>
    


  /**
   * Reference to a field of type 'OccurrenceSeverity[]'
   */
  export type ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceSeverity[]'>
    


  /**
   * Reference to a field of type 'OccurrenceStatus'
   */
  export type EnumOccurrenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceStatus'>
    


  /**
   * Reference to a field of type 'OccurrenceStatus[]'
   */
  export type ListEnumOccurrenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccurrenceStatus[]'>
    


  /**
   * Reference to a field of type 'ImportStatus'
   */
  export type EnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus'>
    


  /**
   * Reference to a field of type 'ImportStatus[]'
   */
  export type ListEnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'WorkflowStepType'
   */
  export type EnumWorkflowStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStepType'>
    


  /**
   * Reference to a field of type 'WorkflowStepType[]'
   */
  export type ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStepType[]'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus[]'
   */
  export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentAccessLevel'
   */
  export type EnumDocumentAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentAccessLevel'>
    


  /**
   * Reference to a field of type 'DocumentAccessLevel[]'
   */
  export type ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentAccessLevel[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'ReportComponentType'
   */
  export type EnumReportComponentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportComponentType'>
    


  /**
   * Reference to a field of type 'ReportComponentType[]'
   */
  export type ListEnumReportComponentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportComponentType[]'>
    


  /**
   * Reference to a field of type 'ReportFrequency'
   */
  export type EnumReportFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFrequency'>
    


  /**
   * Reference to a field of type 'ReportFrequency[]'
   */
  export type ListEnumReportFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportFrequency[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    internalAudits?: InternalAuditListRelationFilter
    externalAudits?: ExternalAuditListRelationFilter
    actionItems?: ActionItemListRelationFilter
    rootCauseAnalyses?: RootCauseAnalysisListRelationFilter
    occurrences?: OccurrenceListRelationFilter
    sectors?: SectorListRelationFilter
    importLogs?: ImportLogListRelationFilter
    auditTrails?: AuditTrailListRelationFilter
    auditPrograms?: AuditProgramListRelationFilter
    attachments?: AttachmentListRelationFilter
    comments?: CommentListRelationFilter
    approvals?: ApprovalListRelationFilter
    workflowDefinitions?: WorkflowDefinitionListRelationFilter
    workflowInstances?: WorkflowInstanceListRelationFilter
    documents?: DocumentListRelationFilter
    documentVersions?: DocumentVersionListRelationFilter
    documentTags?: DocumentTagListRelationFilter
    documentReadConfirmations?: DocumentReadConfirmationListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    internalAudits?: InternalAuditOrderByRelationAggregateInput
    externalAudits?: ExternalAuditOrderByRelationAggregateInput
    actionItems?: ActionItemOrderByRelationAggregateInput
    rootCauseAnalyses?: RootCauseAnalysisOrderByRelationAggregateInput
    occurrences?: OccurrenceOrderByRelationAggregateInput
    sectors?: SectorOrderByRelationAggregateInput
    importLogs?: ImportLogOrderByRelationAggregateInput
    auditTrails?: AuditTrailOrderByRelationAggregateInput
    auditPrograms?: AuditProgramOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
    workflowDefinitions?: WorkflowDefinitionOrderByRelationAggregateInput
    workflowInstances?: WorkflowInstanceOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    documentVersions?: DocumentVersionOrderByRelationAggregateInput
    documentTags?: DocumentTagOrderByRelationAggregateInput
    documentReadConfirmations?: DocumentReadConfirmationOrderByRelationAggregateInput
    reportTemplates?: ReportTemplateOrderByRelationAggregateInput
    scheduledReports?: ScheduledReportOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    internalAudits?: InternalAuditListRelationFilter
    externalAudits?: ExternalAuditListRelationFilter
    actionItems?: ActionItemListRelationFilter
    rootCauseAnalyses?: RootCauseAnalysisListRelationFilter
    occurrences?: OccurrenceListRelationFilter
    sectors?: SectorListRelationFilter
    importLogs?: ImportLogListRelationFilter
    auditTrails?: AuditTrailListRelationFilter
    auditPrograms?: AuditProgramListRelationFilter
    attachments?: AttachmentListRelationFilter
    comments?: CommentListRelationFilter
    approvals?: ApprovalListRelationFilter
    workflowDefinitions?: WorkflowDefinitionListRelationFilter
    workflowInstances?: WorkflowInstanceListRelationFilter
    documents?: DocumentListRelationFilter
    documentVersions?: DocumentVersionListRelationFilter
    documentTags?: DocumentTagListRelationFilter
    documentReadConfirmations?: DocumentReadConfirmationListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    scheduledReports?: ScheduledReportListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    auditTrails?: AuditTrailListRelationFilter
    attachments?: AttachmentListRelationFilter
    comments?: CommentListRelationFilter
    approvalRequests?: ApprovalListRelationFilter
    approvalApprovals?: ApprovalListRelationFilter
    workflowInstances?: WorkflowInstanceListRelationFilter
    workflowCancelled?: WorkflowInstanceListRelationFilter
    workflowStepExecutions?: WorkflowStepExecutionListRelationFilter
    sessions?: SessionListRelationFilter
    createdDocuments?: DocumentListRelationFilter
    updatedDocumentVersions?: DocumentVersionListRelationFilter
    createdReportTemplates?: ReportTemplateListRelationFilter
    createdScheduledReports?: ScheduledReportListRelationFilter
    documentReadConfirmations?: DocumentReadConfirmationListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    auditTrails?: AuditTrailOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    approvalRequests?: ApprovalOrderByRelationAggregateInput
    approvalApprovals?: ApprovalOrderByRelationAggregateInput
    workflowInstances?: WorkflowInstanceOrderByRelationAggregateInput
    workflowCancelled?: WorkflowInstanceOrderByRelationAggregateInput
    workflowStepExecutions?: WorkflowStepExecutionOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    createdDocuments?: DocumentOrderByRelationAggregateInput
    updatedDocumentVersions?: DocumentVersionOrderByRelationAggregateInput
    createdReportTemplates?: ReportTemplateOrderByRelationAggregateInput
    createdScheduledReports?: ScheduledReportOrderByRelationAggregateInput
    documentReadConfirmations?: DocumentReadConfirmationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    auditTrails?: AuditTrailListRelationFilter
    attachments?: AttachmentListRelationFilter
    comments?: CommentListRelationFilter
    approvalRequests?: ApprovalListRelationFilter
    approvalApprovals?: ApprovalListRelationFilter
    workflowInstances?: WorkflowInstanceListRelationFilter
    workflowCancelled?: WorkflowInstanceListRelationFilter
    workflowStepExecutions?: WorkflowStepExecutionListRelationFilter
    sessions?: SessionListRelationFilter
    createdDocuments?: DocumentListRelationFilter
    updatedDocumentVersions?: DocumentVersionListRelationFilter
    createdReportTemplates?: ReportTemplateListRelationFilter
    createdScheduledReports?: ScheduledReportListRelationFilter
    documentReadConfirmations?: DocumentReadConfirmationListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    tenantId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InternalAuditWhereInput = {
    AND?: InternalAuditWhereInput | InternalAuditWhereInput[]
    OR?: InternalAuditWhereInput[]
    NOT?: InternalAuditWhereInput | InternalAuditWhereInput[]
    id?: StringFilter<"InternalAudit"> | string
    tenantId?: StringFilter<"InternalAudit"> | string
    auditProgramId?: StringNullableFilter<"InternalAudit"> | string | null
    ano?: IntFilter<"InternalAudit"> | number
    entidadeAuditora?: StringNullableFilter<"InternalAudit"> | string | null
    iso?: StringNullableFilter<"InternalAudit"> | string | null
    inicio?: DateTimeNullableFilter<"InternalAudit"> | Date | string | null
    termino?: DateTimeNullableFilter<"InternalAudit"> | Date | string | null
    createdAt?: DateTimeFilter<"InternalAudit"> | Date | string
    updatedAt?: DateTimeFilter<"InternalAudit"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    auditProgram?: XOR<AuditProgramNullableRelationFilter, AuditProgramWhereInput> | null
  }

  export type InternalAuditOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrderInput | SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrderInput | SortOrder
    iso?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    termino?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    auditProgram?: AuditProgramOrderByWithRelationInput
  }

  export type InternalAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InternalAuditWhereInput | InternalAuditWhereInput[]
    OR?: InternalAuditWhereInput[]
    NOT?: InternalAuditWhereInput | InternalAuditWhereInput[]
    tenantId?: StringFilter<"InternalAudit"> | string
    auditProgramId?: StringNullableFilter<"InternalAudit"> | string | null
    ano?: IntFilter<"InternalAudit"> | number
    entidadeAuditora?: StringNullableFilter<"InternalAudit"> | string | null
    iso?: StringNullableFilter<"InternalAudit"> | string | null
    inicio?: DateTimeNullableFilter<"InternalAudit"> | Date | string | null
    termino?: DateTimeNullableFilter<"InternalAudit"> | Date | string | null
    createdAt?: DateTimeFilter<"InternalAudit"> | Date | string
    updatedAt?: DateTimeFilter<"InternalAudit"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    auditProgram?: XOR<AuditProgramNullableRelationFilter, AuditProgramWhereInput> | null
  }, "id">

  export type InternalAuditOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrderInput | SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrderInput | SortOrder
    iso?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    termino?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InternalAuditCountOrderByAggregateInput
    _avg?: InternalAuditAvgOrderByAggregateInput
    _max?: InternalAuditMaxOrderByAggregateInput
    _min?: InternalAuditMinOrderByAggregateInput
    _sum?: InternalAuditSumOrderByAggregateInput
  }

  export type InternalAuditScalarWhereWithAggregatesInput = {
    AND?: InternalAuditScalarWhereWithAggregatesInput | InternalAuditScalarWhereWithAggregatesInput[]
    OR?: InternalAuditScalarWhereWithAggregatesInput[]
    NOT?: InternalAuditScalarWhereWithAggregatesInput | InternalAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InternalAudit"> | string
    tenantId?: StringWithAggregatesFilter<"InternalAudit"> | string
    auditProgramId?: StringNullableWithAggregatesFilter<"InternalAudit"> | string | null
    ano?: IntWithAggregatesFilter<"InternalAudit"> | number
    entidadeAuditora?: StringNullableWithAggregatesFilter<"InternalAudit"> | string | null
    iso?: StringNullableWithAggregatesFilter<"InternalAudit"> | string | null
    inicio?: DateTimeNullableWithAggregatesFilter<"InternalAudit"> | Date | string | null
    termino?: DateTimeNullableWithAggregatesFilter<"InternalAudit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InternalAudit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InternalAudit"> | Date | string
  }

  export type ExternalAuditWhereInput = {
    AND?: ExternalAuditWhereInput | ExternalAuditWhereInput[]
    OR?: ExternalAuditWhereInput[]
    NOT?: ExternalAuditWhereInput | ExternalAuditWhereInput[]
    id?: StringFilter<"ExternalAudit"> | string
    tenantId?: StringFilter<"ExternalAudit"> | string
    auditProgramId?: StringNullableFilter<"ExternalAudit"> | string | null
    ano?: IntFilter<"ExternalAudit"> | number
    entidadeAuditora?: StringFilter<"ExternalAudit"> | string
    iso?: StringNullableFilter<"ExternalAudit"> | string | null
    inicio?: DateTimeNullableFilter<"ExternalAudit"> | Date | string | null
    termino?: DateTimeNullableFilter<"ExternalAudit"> | Date | string | null
    createdAt?: DateTimeFilter<"ExternalAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalAudit"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    auditProgram?: XOR<AuditProgramNullableRelationFilter, AuditProgramWhereInput> | null
  }

  export type ExternalAuditOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrderInput | SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    termino?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    auditProgram?: AuditProgramOrderByWithRelationInput
  }

  export type ExternalAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExternalAuditWhereInput | ExternalAuditWhereInput[]
    OR?: ExternalAuditWhereInput[]
    NOT?: ExternalAuditWhereInput | ExternalAuditWhereInput[]
    tenantId?: StringFilter<"ExternalAudit"> | string
    auditProgramId?: StringNullableFilter<"ExternalAudit"> | string | null
    ano?: IntFilter<"ExternalAudit"> | number
    entidadeAuditora?: StringFilter<"ExternalAudit"> | string
    iso?: StringNullableFilter<"ExternalAudit"> | string | null
    inicio?: DateTimeNullableFilter<"ExternalAudit"> | Date | string | null
    termino?: DateTimeNullableFilter<"ExternalAudit"> | Date | string | null
    createdAt?: DateTimeFilter<"ExternalAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalAudit"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    auditProgram?: XOR<AuditProgramNullableRelationFilter, AuditProgramWhereInput> | null
  }, "id">

  export type ExternalAuditOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrderInput | SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    termino?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalAuditCountOrderByAggregateInput
    _avg?: ExternalAuditAvgOrderByAggregateInput
    _max?: ExternalAuditMaxOrderByAggregateInput
    _min?: ExternalAuditMinOrderByAggregateInput
    _sum?: ExternalAuditSumOrderByAggregateInput
  }

  export type ExternalAuditScalarWhereWithAggregatesInput = {
    AND?: ExternalAuditScalarWhereWithAggregatesInput | ExternalAuditScalarWhereWithAggregatesInput[]
    OR?: ExternalAuditScalarWhereWithAggregatesInput[]
    NOT?: ExternalAuditScalarWhereWithAggregatesInput | ExternalAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalAudit"> | string
    tenantId?: StringWithAggregatesFilter<"ExternalAudit"> | string
    auditProgramId?: StringNullableWithAggregatesFilter<"ExternalAudit"> | string | null
    ano?: IntWithAggregatesFilter<"ExternalAudit"> | number
    entidadeAuditora?: StringWithAggregatesFilter<"ExternalAudit"> | string
    iso?: StringNullableWithAggregatesFilter<"ExternalAudit"> | string | null
    inicio?: DateTimeNullableWithAggregatesFilter<"ExternalAudit"> | Date | string | null
    termino?: DateTimeNullableWithAggregatesFilter<"ExternalAudit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExternalAudit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalAudit"> | Date | string
  }

  export type AuditProgramWhereInput = {
    AND?: AuditProgramWhereInput | AuditProgramWhereInput[]
    OR?: AuditProgramWhereInput[]
    NOT?: AuditProgramWhereInput | AuditProgramWhereInput[]
    id?: StringFilter<"AuditProgram"> | string
    tenantId?: StringFilter<"AuditProgram"> | string
    name?: StringFilter<"AuditProgram"> | string
    description?: StringNullableFilter<"AuditProgram"> | string | null
    standard?: StringFilter<"AuditProgram"> | string
    version?: StringFilter<"AuditProgram"> | string
    isTemplate?: BoolFilter<"AuditProgram"> | boolean
    templateId?: StringNullableFilter<"AuditProgram"> | string | null
    createdAt?: DateTimeFilter<"AuditProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AuditProgram"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    template?: XOR<AuditProgramNullableRelationFilter, AuditProgramWhereInput> | null
    derivatives?: AuditProgramListRelationFilter
    checklists?: AuditChecklistListRelationFilter
    internalAudits?: InternalAuditListRelationFilter
    externalAudits?: ExternalAuditListRelationFilter
  }

  export type AuditProgramOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    standard?: SortOrder
    version?: SortOrder
    isTemplate?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    template?: AuditProgramOrderByWithRelationInput
    derivatives?: AuditProgramOrderByRelationAggregateInput
    checklists?: AuditChecklistOrderByRelationAggregateInput
    internalAudits?: InternalAuditOrderByRelationAggregateInput
    externalAudits?: ExternalAuditOrderByRelationAggregateInput
  }

  export type AuditProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditProgramWhereInput | AuditProgramWhereInput[]
    OR?: AuditProgramWhereInput[]
    NOT?: AuditProgramWhereInput | AuditProgramWhereInput[]
    tenantId?: StringFilter<"AuditProgram"> | string
    name?: StringFilter<"AuditProgram"> | string
    description?: StringNullableFilter<"AuditProgram"> | string | null
    standard?: StringFilter<"AuditProgram"> | string
    version?: StringFilter<"AuditProgram"> | string
    isTemplate?: BoolFilter<"AuditProgram"> | boolean
    templateId?: StringNullableFilter<"AuditProgram"> | string | null
    createdAt?: DateTimeFilter<"AuditProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AuditProgram"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    template?: XOR<AuditProgramNullableRelationFilter, AuditProgramWhereInput> | null
    derivatives?: AuditProgramListRelationFilter
    checklists?: AuditChecklistListRelationFilter
    internalAudits?: InternalAuditListRelationFilter
    externalAudits?: ExternalAuditListRelationFilter
  }, "id">

  export type AuditProgramOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    standard?: SortOrder
    version?: SortOrder
    isTemplate?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditProgramCountOrderByAggregateInput
    _max?: AuditProgramMaxOrderByAggregateInput
    _min?: AuditProgramMinOrderByAggregateInput
  }

  export type AuditProgramScalarWhereWithAggregatesInput = {
    AND?: AuditProgramScalarWhereWithAggregatesInput | AuditProgramScalarWhereWithAggregatesInput[]
    OR?: AuditProgramScalarWhereWithAggregatesInput[]
    NOT?: AuditProgramScalarWhereWithAggregatesInput | AuditProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditProgram"> | string
    tenantId?: StringWithAggregatesFilter<"AuditProgram"> | string
    name?: StringWithAggregatesFilter<"AuditProgram"> | string
    description?: StringNullableWithAggregatesFilter<"AuditProgram"> | string | null
    standard?: StringWithAggregatesFilter<"AuditProgram"> | string
    version?: StringWithAggregatesFilter<"AuditProgram"> | string
    isTemplate?: BoolWithAggregatesFilter<"AuditProgram"> | boolean
    templateId?: StringNullableWithAggregatesFilter<"AuditProgram"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditProgram"> | Date | string
  }

  export type AuditChecklistWhereInput = {
    AND?: AuditChecklistWhereInput | AuditChecklistWhereInput[]
    OR?: AuditChecklistWhereInput[]
    NOT?: AuditChecklistWhereInput | AuditChecklistWhereInput[]
    id?: StringFilter<"AuditChecklist"> | string
    auditProgramId?: StringFilter<"AuditChecklist"> | string
    clause?: StringFilter<"AuditChecklist"> | string
    item?: StringFilter<"AuditChecklist"> | string
    requirement?: StringNullableFilter<"AuditChecklist"> | string | null
    evidenceType?: StringNullableFilter<"AuditChecklist"> | string | null
    order?: IntFilter<"AuditChecklist"> | number
    createdAt?: DateTimeFilter<"AuditChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"AuditChecklist"> | Date | string
    auditProgram?: XOR<AuditProgramRelationFilter, AuditProgramWhereInput>
  }

  export type AuditChecklistOrderByWithRelationInput = {
    id?: SortOrder
    auditProgramId?: SortOrder
    clause?: SortOrder
    item?: SortOrder
    requirement?: SortOrderInput | SortOrder
    evidenceType?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditProgram?: AuditProgramOrderByWithRelationInput
  }

  export type AuditChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditChecklistWhereInput | AuditChecklistWhereInput[]
    OR?: AuditChecklistWhereInput[]
    NOT?: AuditChecklistWhereInput | AuditChecklistWhereInput[]
    auditProgramId?: StringFilter<"AuditChecklist"> | string
    clause?: StringFilter<"AuditChecklist"> | string
    item?: StringFilter<"AuditChecklist"> | string
    requirement?: StringNullableFilter<"AuditChecklist"> | string | null
    evidenceType?: StringNullableFilter<"AuditChecklist"> | string | null
    order?: IntFilter<"AuditChecklist"> | number
    createdAt?: DateTimeFilter<"AuditChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"AuditChecklist"> | Date | string
    auditProgram?: XOR<AuditProgramRelationFilter, AuditProgramWhereInput>
  }, "id">

  export type AuditChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    auditProgramId?: SortOrder
    clause?: SortOrder
    item?: SortOrder
    requirement?: SortOrderInput | SortOrder
    evidenceType?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditChecklistCountOrderByAggregateInput
    _avg?: AuditChecklistAvgOrderByAggregateInput
    _max?: AuditChecklistMaxOrderByAggregateInput
    _min?: AuditChecklistMinOrderByAggregateInput
    _sum?: AuditChecklistSumOrderByAggregateInput
  }

  export type AuditChecklistScalarWhereWithAggregatesInput = {
    AND?: AuditChecklistScalarWhereWithAggregatesInput | AuditChecklistScalarWhereWithAggregatesInput[]
    OR?: AuditChecklistScalarWhereWithAggregatesInput[]
    NOT?: AuditChecklistScalarWhereWithAggregatesInput | AuditChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditChecklist"> | string
    auditProgramId?: StringWithAggregatesFilter<"AuditChecklist"> | string
    clause?: StringWithAggregatesFilter<"AuditChecklist"> | string
    item?: StringWithAggregatesFilter<"AuditChecklist"> | string
    requirement?: StringNullableWithAggregatesFilter<"AuditChecklist"> | string | null
    evidenceType?: StringNullableWithAggregatesFilter<"AuditChecklist"> | string | null
    order?: IntWithAggregatesFilter<"AuditChecklist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AuditChecklist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditChecklist"> | Date | string
  }

  export type ActionItemWhereInput = {
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    id?: StringFilter<"ActionItem"> | string
    tenantId?: StringFilter<"ActionItem"> | string
    origem?: EnumActionOriginFilter<"ActionItem"> | $Enums.ActionOrigin
    acaoRelacionada?: StringFilter<"ActionItem"> | string
    conformidade?: EnumConformidadeNullableFilter<"ActionItem"> | $Enums.Conformidade | null
    numeroAssociado?: StringNullableFilter<"ActionItem"> | string | null
    ambito?: StringNullableFilter<"ActionItem"> | string | null
    descricao?: StringFilter<"ActionItem"> | string
    causaRaizIdentificada?: StringNullableFilter<"ActionItem"> | string | null
    acaoCorretiva?: StringNullableFilter<"ActionItem"> | string | null
    local?: StringNullableFilter<"ActionItem"> | string | null
    responsavel?: StringNullableFilter<"ActionItem"> | string | null
    inicio?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    termino?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    conclusao?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    status?: EnumActionStatusFilter<"ActionItem"> | $Enums.ActionStatus
    mes?: StringNullableFilter<"ActionItem"> | string | null
    evidencia?: StringNullableFilter<"ActionItem"> | string | null
    avaliacaoEficacia?: StringNullableFilter<"ActionItem"> | string | null
    setor?: StringFilter<"ActionItem"> | string
    dataAbertura?: DateTimeFilter<"ActionItem"> | Date | string
    dataLimite?: DateTimeFilter<"ActionItem"> | Date | string
    dataConclusao?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    impacto?: EnumImpactFilter<"ActionItem"> | $Enums.Impact
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ActionItem"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    rootCauseAnalysis?: XOR<RootCauseAnalysisNullableRelationFilter, RootCauseAnalysisWhereInput> | null
  }

  export type ActionItemOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    origem?: SortOrder
    acaoRelacionada?: SortOrder
    conformidade?: SortOrderInput | SortOrder
    numeroAssociado?: SortOrderInput | SortOrder
    ambito?: SortOrderInput | SortOrder
    descricao?: SortOrder
    causaRaizIdentificada?: SortOrderInput | SortOrder
    acaoCorretiva?: SortOrderInput | SortOrder
    local?: SortOrderInput | SortOrder
    responsavel?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    termino?: SortOrderInput | SortOrder
    conclusao?: SortOrderInput | SortOrder
    status?: SortOrder
    mes?: SortOrderInput | SortOrder
    evidencia?: SortOrderInput | SortOrder
    avaliacaoEficacia?: SortOrderInput | SortOrder
    setor?: SortOrder
    dataAbertura?: SortOrder
    dataLimite?: SortOrder
    dataConclusao?: SortOrderInput | SortOrder
    impacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    rootCauseAnalysis?: RootCauseAnalysisOrderByWithRelationInput
  }

  export type ActionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    tenantId?: StringFilter<"ActionItem"> | string
    origem?: EnumActionOriginFilter<"ActionItem"> | $Enums.ActionOrigin
    acaoRelacionada?: StringFilter<"ActionItem"> | string
    conformidade?: EnumConformidadeNullableFilter<"ActionItem"> | $Enums.Conformidade | null
    numeroAssociado?: StringNullableFilter<"ActionItem"> | string | null
    ambito?: StringNullableFilter<"ActionItem"> | string | null
    descricao?: StringFilter<"ActionItem"> | string
    causaRaizIdentificada?: StringNullableFilter<"ActionItem"> | string | null
    acaoCorretiva?: StringNullableFilter<"ActionItem"> | string | null
    local?: StringNullableFilter<"ActionItem"> | string | null
    responsavel?: StringNullableFilter<"ActionItem"> | string | null
    inicio?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    termino?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    conclusao?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    status?: EnumActionStatusFilter<"ActionItem"> | $Enums.ActionStatus
    mes?: StringNullableFilter<"ActionItem"> | string | null
    evidencia?: StringNullableFilter<"ActionItem"> | string | null
    avaliacaoEficacia?: StringNullableFilter<"ActionItem"> | string | null
    setor?: StringFilter<"ActionItem"> | string
    dataAbertura?: DateTimeFilter<"ActionItem"> | Date | string
    dataLimite?: DateTimeFilter<"ActionItem"> | Date | string
    dataConclusao?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    impacto?: EnumImpactFilter<"ActionItem"> | $Enums.Impact
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ActionItem"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    rootCauseAnalysis?: XOR<RootCauseAnalysisNullableRelationFilter, RootCauseAnalysisWhereInput> | null
  }, "id">

  export type ActionItemOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    origem?: SortOrder
    acaoRelacionada?: SortOrder
    conformidade?: SortOrderInput | SortOrder
    numeroAssociado?: SortOrderInput | SortOrder
    ambito?: SortOrderInput | SortOrder
    descricao?: SortOrder
    causaRaizIdentificada?: SortOrderInput | SortOrder
    acaoCorretiva?: SortOrderInput | SortOrder
    local?: SortOrderInput | SortOrder
    responsavel?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    termino?: SortOrderInput | SortOrder
    conclusao?: SortOrderInput | SortOrder
    status?: SortOrder
    mes?: SortOrderInput | SortOrder
    evidencia?: SortOrderInput | SortOrder
    avaliacaoEficacia?: SortOrderInput | SortOrder
    setor?: SortOrder
    dataAbertura?: SortOrder
    dataLimite?: SortOrder
    dataConclusao?: SortOrderInput | SortOrder
    impacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionItemCountOrderByAggregateInput
    _max?: ActionItemMaxOrderByAggregateInput
    _min?: ActionItemMinOrderByAggregateInput
  }

  export type ActionItemScalarWhereWithAggregatesInput = {
    AND?: ActionItemScalarWhereWithAggregatesInput | ActionItemScalarWhereWithAggregatesInput[]
    OR?: ActionItemScalarWhereWithAggregatesInput[]
    NOT?: ActionItemScalarWhereWithAggregatesInput | ActionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionItem"> | string
    tenantId?: StringWithAggregatesFilter<"ActionItem"> | string
    origem?: EnumActionOriginWithAggregatesFilter<"ActionItem"> | $Enums.ActionOrigin
    acaoRelacionada?: StringWithAggregatesFilter<"ActionItem"> | string
    conformidade?: EnumConformidadeNullableWithAggregatesFilter<"ActionItem"> | $Enums.Conformidade | null
    numeroAssociado?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    ambito?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    descricao?: StringWithAggregatesFilter<"ActionItem"> | string
    causaRaizIdentificada?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    acaoCorretiva?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    local?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    responsavel?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    inicio?: DateTimeNullableWithAggregatesFilter<"ActionItem"> | Date | string | null
    termino?: DateTimeNullableWithAggregatesFilter<"ActionItem"> | Date | string | null
    conclusao?: DateTimeNullableWithAggregatesFilter<"ActionItem"> | Date | string | null
    status?: EnumActionStatusWithAggregatesFilter<"ActionItem"> | $Enums.ActionStatus
    mes?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    evidencia?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    avaliacaoEficacia?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    setor?: StringWithAggregatesFilter<"ActionItem"> | string
    dataAbertura?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
    dataLimite?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
    dataConclusao?: DateTimeNullableWithAggregatesFilter<"ActionItem"> | Date | string | null
    impacto?: EnumImpactWithAggregatesFilter<"ActionItem"> | $Enums.Impact
    createdAt?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
  }

  export type RootCauseAnalysisWhereInput = {
    AND?: RootCauseAnalysisWhereInput | RootCauseAnalysisWhereInput[]
    OR?: RootCauseAnalysisWhereInput[]
    NOT?: RootCauseAnalysisWhereInput | RootCauseAnalysisWhereInput[]
    id?: StringFilter<"RootCauseAnalysis"> | string
    actionItemId?: StringFilter<"RootCauseAnalysis"> | string
    tenantId?: StringFilter<"RootCauseAnalysis"> | string
    analysisType?: EnumRootCauseAnalysisTypeFilter<"RootCauseAnalysis"> | $Enums.RootCauseAnalysisType
    data?: JsonFilter<"RootCauseAnalysis">
    createdAt?: DateTimeFilter<"RootCauseAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"RootCauseAnalysis"> | Date | string
    actionItem?: XOR<ActionItemRelationFilter, ActionItemWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type RootCauseAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    actionItemId?: SortOrder
    tenantId?: SortOrder
    analysisType?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    actionItem?: ActionItemOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type RootCauseAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    actionItemId?: string
    AND?: RootCauseAnalysisWhereInput | RootCauseAnalysisWhereInput[]
    OR?: RootCauseAnalysisWhereInput[]
    NOT?: RootCauseAnalysisWhereInput | RootCauseAnalysisWhereInput[]
    tenantId?: StringFilter<"RootCauseAnalysis"> | string
    analysisType?: EnumRootCauseAnalysisTypeFilter<"RootCauseAnalysis"> | $Enums.RootCauseAnalysisType
    data?: JsonFilter<"RootCauseAnalysis">
    createdAt?: DateTimeFilter<"RootCauseAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"RootCauseAnalysis"> | Date | string
    actionItem?: XOR<ActionItemRelationFilter, ActionItemWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "actionItemId">

  export type RootCauseAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    actionItemId?: SortOrder
    tenantId?: SortOrder
    analysisType?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RootCauseAnalysisCountOrderByAggregateInput
    _max?: RootCauseAnalysisMaxOrderByAggregateInput
    _min?: RootCauseAnalysisMinOrderByAggregateInput
  }

  export type RootCauseAnalysisScalarWhereWithAggregatesInput = {
    AND?: RootCauseAnalysisScalarWhereWithAggregatesInput | RootCauseAnalysisScalarWhereWithAggregatesInput[]
    OR?: RootCauseAnalysisScalarWhereWithAggregatesInput[]
    NOT?: RootCauseAnalysisScalarWhereWithAggregatesInput | RootCauseAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RootCauseAnalysis"> | string
    actionItemId?: StringWithAggregatesFilter<"RootCauseAnalysis"> | string
    tenantId?: StringWithAggregatesFilter<"RootCauseAnalysis"> | string
    analysisType?: EnumRootCauseAnalysisTypeWithAggregatesFilter<"RootCauseAnalysis"> | $Enums.RootCauseAnalysisType
    data?: JsonWithAggregatesFilter<"RootCauseAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"RootCauseAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RootCauseAnalysis"> | Date | string
  }

  export type OccurrenceWhereInput = {
    AND?: OccurrenceWhereInput | OccurrenceWhereInput[]
    OR?: OccurrenceWhereInput[]
    NOT?: OccurrenceWhereInput | OccurrenceWhereInput[]
    id?: StringFilter<"Occurrence"> | string
    tenantId?: StringFilter<"Occurrence"> | string
    tipo?: EnumOccurrenceTypeFilter<"Occurrence"> | $Enums.OccurrenceType
    setor?: StringFilter<"Occurrence"> | string
    departamentosAtingidos?: JsonFilter<"Occurrence">
    responsavel?: StringFilter<"Occurrence"> | string
    data?: DateTimeFilter<"Occurrence"> | Date | string
    descricao?: StringFilter<"Occurrence"> | string
    resolucao?: StringNullableFilter<"Occurrence"> | string | null
    gravidade?: EnumOccurrenceSeverityFilter<"Occurrence"> | $Enums.OccurrenceSeverity
    acaoGerada?: StringNullableFilter<"Occurrence"> | string | null
    status?: EnumOccurrenceStatusFilter<"Occurrence"> | $Enums.OccurrenceStatus
    createdAt?: DateTimeFilter<"Occurrence"> | Date | string
    updatedAt?: DateTimeFilter<"Occurrence"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type OccurrenceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tipo?: SortOrder
    setor?: SortOrder
    departamentosAtingidos?: SortOrder
    responsavel?: SortOrder
    data?: SortOrder
    descricao?: SortOrder
    resolucao?: SortOrderInput | SortOrder
    gravidade?: SortOrder
    acaoGerada?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type OccurrenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OccurrenceWhereInput | OccurrenceWhereInput[]
    OR?: OccurrenceWhereInput[]
    NOT?: OccurrenceWhereInput | OccurrenceWhereInput[]
    tenantId?: StringFilter<"Occurrence"> | string
    tipo?: EnumOccurrenceTypeFilter<"Occurrence"> | $Enums.OccurrenceType
    setor?: StringFilter<"Occurrence"> | string
    departamentosAtingidos?: JsonFilter<"Occurrence">
    responsavel?: StringFilter<"Occurrence"> | string
    data?: DateTimeFilter<"Occurrence"> | Date | string
    descricao?: StringFilter<"Occurrence"> | string
    resolucao?: StringNullableFilter<"Occurrence"> | string | null
    gravidade?: EnumOccurrenceSeverityFilter<"Occurrence"> | $Enums.OccurrenceSeverity
    acaoGerada?: StringNullableFilter<"Occurrence"> | string | null
    status?: EnumOccurrenceStatusFilter<"Occurrence"> | $Enums.OccurrenceStatus
    createdAt?: DateTimeFilter<"Occurrence"> | Date | string
    updatedAt?: DateTimeFilter<"Occurrence"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type OccurrenceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tipo?: SortOrder
    setor?: SortOrder
    departamentosAtingidos?: SortOrder
    responsavel?: SortOrder
    data?: SortOrder
    descricao?: SortOrder
    resolucao?: SortOrderInput | SortOrder
    gravidade?: SortOrder
    acaoGerada?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OccurrenceCountOrderByAggregateInput
    _max?: OccurrenceMaxOrderByAggregateInput
    _min?: OccurrenceMinOrderByAggregateInput
  }

  export type OccurrenceScalarWhereWithAggregatesInput = {
    AND?: OccurrenceScalarWhereWithAggregatesInput | OccurrenceScalarWhereWithAggregatesInput[]
    OR?: OccurrenceScalarWhereWithAggregatesInput[]
    NOT?: OccurrenceScalarWhereWithAggregatesInput | OccurrenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Occurrence"> | string
    tenantId?: StringWithAggregatesFilter<"Occurrence"> | string
    tipo?: EnumOccurrenceTypeWithAggregatesFilter<"Occurrence"> | $Enums.OccurrenceType
    setor?: StringWithAggregatesFilter<"Occurrence"> | string
    departamentosAtingidos?: JsonWithAggregatesFilter<"Occurrence">
    responsavel?: StringWithAggregatesFilter<"Occurrence"> | string
    data?: DateTimeWithAggregatesFilter<"Occurrence"> | Date | string
    descricao?: StringWithAggregatesFilter<"Occurrence"> | string
    resolucao?: StringNullableWithAggregatesFilter<"Occurrence"> | string | null
    gravidade?: EnumOccurrenceSeverityWithAggregatesFilter<"Occurrence"> | $Enums.OccurrenceSeverity
    acaoGerada?: StringNullableWithAggregatesFilter<"Occurrence"> | string | null
    status?: EnumOccurrenceStatusWithAggregatesFilter<"Occurrence"> | $Enums.OccurrenceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Occurrence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Occurrence"> | Date | string
  }

  export type SectorWhereInput = {
    AND?: SectorWhereInput | SectorWhereInput[]
    OR?: SectorWhereInput[]
    NOT?: SectorWhereInput | SectorWhereInput[]
    id?: StringFilter<"Sector"> | string
    tenantId?: StringFilter<"Sector"> | string
    nome?: StringFilter<"Sector"> | string
    responsavel?: StringFilter<"Sector"> | string
    email?: StringNullableFilter<"Sector"> | string | null
    telefone?: StringNullableFilter<"Sector"> | string | null
    descricao?: StringNullableFilter<"Sector"> | string | null
    ativo?: BoolFilter<"Sector"> | boolean
    createdAt?: DateTimeFilter<"Sector"> | Date | string
    updatedAt?: DateTimeFilter<"Sector"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type SectorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type SectorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SectorWhereInput | SectorWhereInput[]
    OR?: SectorWhereInput[]
    NOT?: SectorWhereInput | SectorWhereInput[]
    tenantId?: StringFilter<"Sector"> | string
    nome?: StringFilter<"Sector"> | string
    responsavel?: StringFilter<"Sector"> | string
    email?: StringNullableFilter<"Sector"> | string | null
    telefone?: StringNullableFilter<"Sector"> | string | null
    descricao?: StringNullableFilter<"Sector"> | string | null
    ativo?: BoolFilter<"Sector"> | boolean
    createdAt?: DateTimeFilter<"Sector"> | Date | string
    updatedAt?: DateTimeFilter<"Sector"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type SectorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectorCountOrderByAggregateInput
    _max?: SectorMaxOrderByAggregateInput
    _min?: SectorMinOrderByAggregateInput
  }

  export type SectorScalarWhereWithAggregatesInput = {
    AND?: SectorScalarWhereWithAggregatesInput | SectorScalarWhereWithAggregatesInput[]
    OR?: SectorScalarWhereWithAggregatesInput[]
    NOT?: SectorScalarWhereWithAggregatesInput | SectorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sector"> | string
    tenantId?: StringWithAggregatesFilter<"Sector"> | string
    nome?: StringWithAggregatesFilter<"Sector"> | string
    responsavel?: StringWithAggregatesFilter<"Sector"> | string
    email?: StringNullableWithAggregatesFilter<"Sector"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Sector"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"Sector"> | string | null
    ativo?: BoolWithAggregatesFilter<"Sector"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Sector"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sector"> | Date | string
  }

  export type ImportLogWhereInput = {
    AND?: ImportLogWhereInput | ImportLogWhereInput[]
    OR?: ImportLogWhereInput[]
    NOT?: ImportLogWhereInput | ImportLogWhereInput[]
    id?: StringFilter<"ImportLog"> | string
    tenantId?: StringFilter<"ImportLog"> | string
    fileName?: StringFilter<"ImportLog"> | string
    mode?: StringFilter<"ImportLog"> | string
    entity?: StringFilter<"ImportLog"> | string
    status?: EnumImportStatusFilter<"ImportLog"> | $Enums.ImportStatus
    totalRecords?: IntFilter<"ImportLog"> | number
    createdAt?: DateTimeFilter<"ImportLog"> | Date | string
    finishedAt?: DateTimeNullableFilter<"ImportLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ImportLog"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type ImportLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fileName?: SortOrder
    mode?: SortOrder
    entity?: SortOrder
    status?: SortOrder
    totalRecords?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ImportLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportLogWhereInput | ImportLogWhereInput[]
    OR?: ImportLogWhereInput[]
    NOT?: ImportLogWhereInput | ImportLogWhereInput[]
    tenantId?: StringFilter<"ImportLog"> | string
    fileName?: StringFilter<"ImportLog"> | string
    mode?: StringFilter<"ImportLog"> | string
    entity?: StringFilter<"ImportLog"> | string
    status?: EnumImportStatusFilter<"ImportLog"> | $Enums.ImportStatus
    totalRecords?: IntFilter<"ImportLog"> | number
    createdAt?: DateTimeFilter<"ImportLog"> | Date | string
    finishedAt?: DateTimeNullableFilter<"ImportLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ImportLog"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type ImportLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fileName?: SortOrder
    mode?: SortOrder
    entity?: SortOrder
    status?: SortOrder
    totalRecords?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: ImportLogCountOrderByAggregateInput
    _avg?: ImportLogAvgOrderByAggregateInput
    _max?: ImportLogMaxOrderByAggregateInput
    _min?: ImportLogMinOrderByAggregateInput
    _sum?: ImportLogSumOrderByAggregateInput
  }

  export type ImportLogScalarWhereWithAggregatesInput = {
    AND?: ImportLogScalarWhereWithAggregatesInput | ImportLogScalarWhereWithAggregatesInput[]
    OR?: ImportLogScalarWhereWithAggregatesInput[]
    NOT?: ImportLogScalarWhereWithAggregatesInput | ImportLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportLog"> | string
    tenantId?: StringWithAggregatesFilter<"ImportLog"> | string
    fileName?: StringWithAggregatesFilter<"ImportLog"> | string
    mode?: StringWithAggregatesFilter<"ImportLog"> | string
    entity?: StringWithAggregatesFilter<"ImportLog"> | string
    status?: EnumImportStatusWithAggregatesFilter<"ImportLog"> | $Enums.ImportStatus
    totalRecords?: IntWithAggregatesFilter<"ImportLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ImportLog"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"ImportLog"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ImportLog"> | string | null
  }

  export type AuditTrailWhereInput = {
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    tenantId?: StringFilter<"AuditTrail"> | string
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    action?: EnumAuditActionFilter<"AuditTrail"> | $Enums.AuditAction
    entity?: StringFilter<"AuditTrail"> | string
    entityId?: StringNullableFilter<"AuditTrail"> | string | null
    description?: StringFilter<"AuditTrail"> | string
    metadata?: JsonNullableFilter<"AuditTrail">
    createdAt?: DateTimeFilter<"AuditTrail"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditTrailOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditTrailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    tenantId?: StringFilter<"AuditTrail"> | string
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    action?: EnumAuditActionFilter<"AuditTrail"> | $Enums.AuditAction
    entity?: StringFilter<"AuditTrail"> | string
    entityId?: StringNullableFilter<"AuditTrail"> | string | null
    description?: StringFilter<"AuditTrail"> | string
    metadata?: JsonNullableFilter<"AuditTrail">
    createdAt?: DateTimeFilter<"AuditTrail"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditTrailOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditTrailCountOrderByAggregateInput
    _max?: AuditTrailMaxOrderByAggregateInput
    _min?: AuditTrailMinOrderByAggregateInput
  }

  export type AuditTrailScalarWhereWithAggregatesInput = {
    AND?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    OR?: AuditTrailScalarWhereWithAggregatesInput[]
    NOT?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditTrail"> | string
    tenantId?: StringWithAggregatesFilter<"AuditTrail"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    action?: EnumAuditActionWithAggregatesFilter<"AuditTrail"> | $Enums.AuditAction
    entity?: StringWithAggregatesFilter<"AuditTrail"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    description?: StringWithAggregatesFilter<"AuditTrail"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditTrail">
    createdAt?: DateTimeWithAggregatesFilter<"AuditTrail"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    tenantId?: StringFilter<"Attachment"> | string
    entityType?: StringFilter<"Attachment"> | string
    entityId?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    originalName?: StringFilter<"Attachment"> | string
    mimeType?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    path?: StringFilter<"Attachment"> | string
    uploadedBy?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    tenantId?: StringFilter<"Attachment"> | string
    entityType?: StringFilter<"Attachment"> | string
    entityId?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    originalName?: StringFilter<"Attachment"> | string
    mimeType?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    path?: StringFilter<"Attachment"> | string
    uploadedBy?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    tenantId?: StringWithAggregatesFilter<"Attachment"> | string
    entityType?: StringWithAggregatesFilter<"Attachment"> | string
    entityId?: StringWithAggregatesFilter<"Attachment"> | string
    fileName?: StringWithAggregatesFilter<"Attachment"> | string
    originalName?: StringWithAggregatesFilter<"Attachment"> | string
    mimeType?: StringWithAggregatesFilter<"Attachment"> | string
    size?: IntWithAggregatesFilter<"Attachment"> | number
    path?: StringWithAggregatesFilter<"Attachment"> | string
    uploadedBy?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    tenantId?: StringFilter<"Comment"> | string
    entityType?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    tenantId?: StringFilter<"Comment"> | string
    entityType?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    tenantId?: StringWithAggregatesFilter<"Comment"> | string
    entityType?: StringWithAggregatesFilter<"Comment"> | string
    entityId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type ApprovalWhereInput = {
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    id?: StringFilter<"Approval"> | string
    tenantId?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    requestedBy?: StringFilter<"Approval"> | string
    approvedBy?: StringNullableFilter<"Approval"> | string | null
    comments?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    updatedAt?: DateTimeFilter<"Approval"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ApprovalOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type ApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    tenantId?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    requestedBy?: StringFilter<"Approval"> | string
    approvedBy?: StringNullableFilter<"Approval"> | string | null
    comments?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    updatedAt?: DateTimeFilter<"Approval"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    OR?: ApprovalScalarWhereWithAggregatesInput[]
    NOT?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Approval"> | string
    tenantId?: StringWithAggregatesFilter<"Approval"> | string
    entityType?: StringWithAggregatesFilter<"Approval"> | string
    entityId?: StringWithAggregatesFilter<"Approval"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"Approval"> | $Enums.ApprovalStatus
    requestedBy?: StringWithAggregatesFilter<"Approval"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    comments?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Approval"> | Date | string | null
  }

  export type WorkflowDefinitionWhereInput = {
    AND?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    OR?: WorkflowDefinitionWhereInput[]
    NOT?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    id?: StringFilter<"WorkflowDefinition"> | string
    tenantId?: StringFilter<"WorkflowDefinition"> | string
    name?: StringFilter<"WorkflowDefinition"> | string
    description?: StringNullableFilter<"WorkflowDefinition"> | string | null
    entityType?: StringFilter<"WorkflowDefinition"> | string
    isActive?: BoolFilter<"WorkflowDefinition"> | boolean
    createdAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    steps?: WorkflowStepListRelationFilter
    instances?: WorkflowInstanceListRelationFilter
  }

  export type WorkflowDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entityType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    steps?: WorkflowStepOrderByRelationAggregateInput
    instances?: WorkflowInstanceOrderByRelationAggregateInput
  }

  export type WorkflowDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    OR?: WorkflowDefinitionWhereInput[]
    NOT?: WorkflowDefinitionWhereInput | WorkflowDefinitionWhereInput[]
    tenantId?: StringFilter<"WorkflowDefinition"> | string
    name?: StringFilter<"WorkflowDefinition"> | string
    description?: StringNullableFilter<"WorkflowDefinition"> | string | null
    entityType?: StringFilter<"WorkflowDefinition"> | string
    isActive?: BoolFilter<"WorkflowDefinition"> | boolean
    createdAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    steps?: WorkflowStepListRelationFilter
    instances?: WorkflowInstanceListRelationFilter
  }, "id">

  export type WorkflowDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entityType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowDefinitionCountOrderByAggregateInput
    _max?: WorkflowDefinitionMaxOrderByAggregateInput
    _min?: WorkflowDefinitionMinOrderByAggregateInput
  }

  export type WorkflowDefinitionScalarWhereWithAggregatesInput = {
    AND?: WorkflowDefinitionScalarWhereWithAggregatesInput | WorkflowDefinitionScalarWhereWithAggregatesInput[]
    OR?: WorkflowDefinitionScalarWhereWithAggregatesInput[]
    NOT?: WorkflowDefinitionScalarWhereWithAggregatesInput | WorkflowDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    tenantId?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    name?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowDefinition"> | string | null
    entityType?: StringWithAggregatesFilter<"WorkflowDefinition"> | string
    isActive?: BoolWithAggregatesFilter<"WorkflowDefinition"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowDefinition"> | Date | string
  }

  export type WorkflowStepWhereInput = {
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    workflowDefinitionId?: StringFilter<"WorkflowStep"> | string
    stepOrder?: IntFilter<"WorkflowStep"> | number
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    name?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    requiredRoles?: JsonFilter<"WorkflowStep">
    requiredUsers?: JsonFilter<"WorkflowStep">
    conditionExpression?: JsonNullableFilter<"WorkflowStep">
    notificationTemplate?: StringNullableFilter<"WorkflowStep"> | string | null
    autoAdvance?: BoolFilter<"WorkflowStep"> | boolean
    timeoutDays?: IntNullableFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    workflowDefinition?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
  }

  export type WorkflowStepOrderByWithRelationInput = {
    id?: SortOrder
    workflowDefinitionId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredRoles?: SortOrder
    requiredUsers?: SortOrder
    conditionExpression?: SortOrderInput | SortOrder
    notificationTemplate?: SortOrderInput | SortOrder
    autoAdvance?: SortOrder
    timeoutDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowDefinition?: WorkflowDefinitionOrderByWithRelationInput
  }

  export type WorkflowStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    workflowDefinitionId?: StringFilter<"WorkflowStep"> | string
    stepOrder?: IntFilter<"WorkflowStep"> | number
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    name?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    requiredRoles?: JsonFilter<"WorkflowStep">
    requiredUsers?: JsonFilter<"WorkflowStep">
    conditionExpression?: JsonNullableFilter<"WorkflowStep">
    notificationTemplate?: StringNullableFilter<"WorkflowStep"> | string | null
    autoAdvance?: BoolFilter<"WorkflowStep"> | boolean
    timeoutDays?: IntNullableFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    workflowDefinition?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
  }, "id">

  export type WorkflowStepOrderByWithAggregationInput = {
    id?: SortOrder
    workflowDefinitionId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredRoles?: SortOrder
    requiredUsers?: SortOrder
    conditionExpression?: SortOrderInput | SortOrder
    notificationTemplate?: SortOrderInput | SortOrder
    autoAdvance?: SortOrder
    timeoutDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowStepCountOrderByAggregateInput
    _avg?: WorkflowStepAvgOrderByAggregateInput
    _max?: WorkflowStepMaxOrderByAggregateInput
    _min?: WorkflowStepMinOrderByAggregateInput
    _sum?: WorkflowStepSumOrderByAggregateInput
  }

  export type WorkflowStepScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStep"> | string
    workflowDefinitionId?: StringWithAggregatesFilter<"WorkflowStep"> | string
    stepOrder?: IntWithAggregatesFilter<"WorkflowStep"> | number
    stepType?: EnumWorkflowStepTypeWithAggregatesFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    name?: StringWithAggregatesFilter<"WorkflowStep"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    requiredRoles?: JsonWithAggregatesFilter<"WorkflowStep">
    requiredUsers?: JsonWithAggregatesFilter<"WorkflowStep">
    conditionExpression?: JsonNullableWithAggregatesFilter<"WorkflowStep">
    notificationTemplate?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    autoAdvance?: BoolWithAggregatesFilter<"WorkflowStep"> | boolean
    timeoutDays?: IntNullableWithAggregatesFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
  }

  export type WorkflowInstanceWhereInput = {
    AND?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    OR?: WorkflowInstanceWhereInput[]
    NOT?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    id?: StringFilter<"WorkflowInstance"> | string
    tenantId?: StringFilter<"WorkflowInstance"> | string
    workflowDefinitionId?: StringFilter<"WorkflowInstance"> | string
    entityType?: StringFilter<"WorkflowInstance"> | string
    entityId?: StringFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    startedBy?: StringFilter<"WorkflowInstance"> | string
    currentStepOrder?: IntNullableFilter<"WorkflowInstance"> | number | null
    completedAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    cancelledBy?: StringNullableFilter<"WorkflowInstance"> | string | null
    createdAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    workflowDefinition?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
    startedByUser?: XOR<UserRelationFilter, UserWhereInput>
    cancelledByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    stepExecutions?: WorkflowStepExecutionListRelationFilter
    documents?: DocumentListRelationFilter
  }

  export type WorkflowInstanceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    workflowDefinitionId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    startedBy?: SortOrder
    currentStepOrder?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    workflowDefinition?: WorkflowDefinitionOrderByWithRelationInput
    startedByUser?: UserOrderByWithRelationInput
    cancelledByUser?: UserOrderByWithRelationInput
    stepExecutions?: WorkflowStepExecutionOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type WorkflowInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    OR?: WorkflowInstanceWhereInput[]
    NOT?: WorkflowInstanceWhereInput | WorkflowInstanceWhereInput[]
    tenantId?: StringFilter<"WorkflowInstance"> | string
    workflowDefinitionId?: StringFilter<"WorkflowInstance"> | string
    entityType?: StringFilter<"WorkflowInstance"> | string
    entityId?: StringFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    startedBy?: StringFilter<"WorkflowInstance"> | string
    currentStepOrder?: IntNullableFilter<"WorkflowInstance"> | number | null
    completedAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    cancelledBy?: StringNullableFilter<"WorkflowInstance"> | string | null
    createdAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    workflowDefinition?: XOR<WorkflowDefinitionRelationFilter, WorkflowDefinitionWhereInput>
    startedByUser?: XOR<UserRelationFilter, UserWhereInput>
    cancelledByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    stepExecutions?: WorkflowStepExecutionListRelationFilter
    documents?: DocumentListRelationFilter
  }, "id">

  export type WorkflowInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    workflowDefinitionId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    startedBy?: SortOrder
    currentStepOrder?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowInstanceCountOrderByAggregateInput
    _avg?: WorkflowInstanceAvgOrderByAggregateInput
    _max?: WorkflowInstanceMaxOrderByAggregateInput
    _min?: WorkflowInstanceMinOrderByAggregateInput
    _sum?: WorkflowInstanceSumOrderByAggregateInput
  }

  export type WorkflowInstanceScalarWhereWithAggregatesInput = {
    AND?: WorkflowInstanceScalarWhereWithAggregatesInput | WorkflowInstanceScalarWhereWithAggregatesInput[]
    OR?: WorkflowInstanceScalarWhereWithAggregatesInput[]
    NOT?: WorkflowInstanceScalarWhereWithAggregatesInput | WorkflowInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    tenantId?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    workflowDefinitionId?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    entityType?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    entityId?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusWithAggregatesFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    startedBy?: StringWithAggregatesFilter<"WorkflowInstance"> | string
    currentStepOrder?: IntNullableWithAggregatesFilter<"WorkflowInstance"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowInstance"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"WorkflowInstance"> | Date | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"WorkflowInstance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowInstance"> | Date | string
  }

  export type WorkflowStepExecutionWhereInput = {
    AND?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    OR?: WorkflowStepExecutionWhereInput[]
    NOT?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    id?: StringFilter<"WorkflowStepExecution"> | string
    workflowInstanceId?: StringFilter<"WorkflowStepExecution"> | string
    stepOrder?: IntFilter<"WorkflowStepExecution"> | number
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFilter<"WorkflowStepExecution"> | $Enums.WorkflowStatus
    executedBy?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    comments?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    executedAt?: DateTimeNullableFilter<"WorkflowStepExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    workflowInstance?: XOR<WorkflowInstanceRelationFilter, WorkflowInstanceWhereInput>
    executedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type WorkflowStepExecutionOrderByWithRelationInput = {
    id?: SortOrder
    workflowInstanceId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    status?: SortOrder
    executedBy?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowInstance?: WorkflowInstanceOrderByWithRelationInput
    executedByUser?: UserOrderByWithRelationInput
  }

  export type WorkflowStepExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    OR?: WorkflowStepExecutionWhereInput[]
    NOT?: WorkflowStepExecutionWhereInput | WorkflowStepExecutionWhereInput[]
    workflowInstanceId?: StringFilter<"WorkflowStepExecution"> | string
    stepOrder?: IntFilter<"WorkflowStepExecution"> | number
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFilter<"WorkflowStepExecution"> | $Enums.WorkflowStatus
    executedBy?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    comments?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    executedAt?: DateTimeNullableFilter<"WorkflowStepExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    workflowInstance?: XOR<WorkflowInstanceRelationFilter, WorkflowInstanceWhereInput>
    executedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type WorkflowStepExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    workflowInstanceId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    status?: SortOrder
    executedBy?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkflowStepExecutionCountOrderByAggregateInput
    _avg?: WorkflowStepExecutionAvgOrderByAggregateInput
    _max?: WorkflowStepExecutionMaxOrderByAggregateInput
    _min?: WorkflowStepExecutionMinOrderByAggregateInput
    _sum?: WorkflowStepExecutionSumOrderByAggregateInput
  }

  export type WorkflowStepExecutionScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepExecutionScalarWhereWithAggregatesInput | WorkflowStepExecutionScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepExecutionScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepExecutionScalarWhereWithAggregatesInput | WorkflowStepExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStepExecution"> | string
    workflowInstanceId?: StringWithAggregatesFilter<"WorkflowStepExecution"> | string
    stepOrder?: IntWithAggregatesFilter<"WorkflowStepExecution"> | number
    stepType?: EnumWorkflowStepTypeWithAggregatesFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusWithAggregatesFilter<"WorkflowStepExecution"> | $Enums.WorkflowStatus
    executedBy?: StringNullableWithAggregatesFilter<"WorkflowStepExecution"> | string | null
    comments?: StringNullableWithAggregatesFilter<"WorkflowStepExecution"> | string | null
    executedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowStepExecution"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowStepExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowStepExecution"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    status?: EnumSessionStatusWithAggregatesFilter<"Session"> | $Enums.SessionStatus
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFilter<"Document"> | $Enums.DocumentAccessLevel
    currentVersion?: IntFilter<"Document"> | number
    createdBy?: StringFilter<"Document"> | string
    workflowInstanceId?: StringNullableFilter<"Document"> | string | null
    allowedRoles?: JsonFilter<"Document">
    allowedUsers?: JsonFilter<"Document">
    metadata?: JsonNullableFilter<"Document">
    archivedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    versions?: DocumentVersionListRelationFilter
    tags?: DocumentTagListRelationFilter
    workflowInstance?: XOR<WorkflowInstanceNullableRelationFilter, WorkflowInstanceWhereInput> | null
    readConfirmations?: DocumentReadConfirmationListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    accessLevel?: SortOrder
    currentVersion?: SortOrder
    createdBy?: SortOrder
    workflowInstanceId?: SortOrderInput | SortOrder
    allowedRoles?: SortOrder
    allowedUsers?: SortOrder
    metadata?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    versions?: DocumentVersionOrderByRelationAggregateInput
    tags?: DocumentTagOrderByRelationAggregateInput
    workflowInstance?: WorkflowInstanceOrderByWithRelationInput
    readConfirmations?: DocumentReadConfirmationOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    tenantId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFilter<"Document"> | $Enums.DocumentAccessLevel
    currentVersion?: IntFilter<"Document"> | number
    createdBy?: StringFilter<"Document"> | string
    workflowInstanceId?: StringNullableFilter<"Document"> | string | null
    allowedRoles?: JsonFilter<"Document">
    allowedUsers?: JsonFilter<"Document">
    metadata?: JsonNullableFilter<"Document">
    archivedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    versions?: DocumentVersionListRelationFilter
    tags?: DocumentTagListRelationFilter
    workflowInstance?: XOR<WorkflowInstanceNullableRelationFilter, WorkflowInstanceWhereInput> | null
    readConfirmations?: DocumentReadConfirmationListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    accessLevel?: SortOrder
    currentVersion?: SortOrder
    createdBy?: SortOrder
    workflowInstanceId?: SortOrderInput | SortOrder
    allowedRoles?: SortOrder
    allowedUsers?: SortOrder
    metadata?: SortOrderInput | SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    tenantId?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    category?: StringNullableWithAggregatesFilter<"Document"> | string | null
    status?: EnumDocumentStatusWithAggregatesFilter<"Document"> | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelWithAggregatesFilter<"Document"> | $Enums.DocumentAccessLevel
    currentVersion?: IntWithAggregatesFilter<"Document"> | number
    createdBy?: StringWithAggregatesFilter<"Document"> | string
    workflowInstanceId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    allowedRoles?: JsonWithAggregatesFilter<"Document">
    allowedUsers?: JsonWithAggregatesFilter<"Document">
    metadata?: JsonNullableWithAggregatesFilter<"Document">
    archivedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentVersionWhereInput = {
    AND?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    OR?: DocumentVersionWhereInput[]
    NOT?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    id?: StringFilter<"DocumentVersion"> | string
    documentId?: StringFilter<"DocumentVersion"> | string
    tenantId?: StringFilter<"DocumentVersion"> | string
    version?: IntFilter<"DocumentVersion"> | number
    fileName?: StringFilter<"DocumentVersion"> | string
    originalName?: StringFilter<"DocumentVersion"> | string
    mimeType?: StringFilter<"DocumentVersion"> | string
    size?: IntFilter<"DocumentVersion"> | number
    path?: StringFilter<"DocumentVersion"> | string
    checksum?: StringNullableFilter<"DocumentVersion"> | string | null
    changeNotes?: StringNullableFilter<"DocumentVersion"> | string | null
    uploadedBy?: StringFilter<"DocumentVersion"> | string
    isCurrent?: BoolFilter<"DocumentVersion"> | boolean
    createdAt?: DateTimeFilter<"DocumentVersion"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    uploader?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentVersionOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    version?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    checksum?: SortOrderInput | SortOrder
    changeNotes?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type DocumentVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId_version?: DocumentVersionDocumentIdVersionCompoundUniqueInput
    AND?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    OR?: DocumentVersionWhereInput[]
    NOT?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    documentId?: StringFilter<"DocumentVersion"> | string
    tenantId?: StringFilter<"DocumentVersion"> | string
    version?: IntFilter<"DocumentVersion"> | number
    fileName?: StringFilter<"DocumentVersion"> | string
    originalName?: StringFilter<"DocumentVersion"> | string
    mimeType?: StringFilter<"DocumentVersion"> | string
    size?: IntFilter<"DocumentVersion"> | number
    path?: StringFilter<"DocumentVersion"> | string
    checksum?: StringNullableFilter<"DocumentVersion"> | string | null
    changeNotes?: StringNullableFilter<"DocumentVersion"> | string | null
    uploadedBy?: StringFilter<"DocumentVersion"> | string
    isCurrent?: BoolFilter<"DocumentVersion"> | boolean
    createdAt?: DateTimeFilter<"DocumentVersion"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    uploader?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "documentId_version">

  export type DocumentVersionOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    version?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    checksum?: SortOrderInput | SortOrder
    changeNotes?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentVersionCountOrderByAggregateInput
    _avg?: DocumentVersionAvgOrderByAggregateInput
    _max?: DocumentVersionMaxOrderByAggregateInput
    _min?: DocumentVersionMinOrderByAggregateInput
    _sum?: DocumentVersionSumOrderByAggregateInput
  }

  export type DocumentVersionScalarWhereWithAggregatesInput = {
    AND?: DocumentVersionScalarWhereWithAggregatesInput | DocumentVersionScalarWhereWithAggregatesInput[]
    OR?: DocumentVersionScalarWhereWithAggregatesInput[]
    NOT?: DocumentVersionScalarWhereWithAggregatesInput | DocumentVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentVersion"> | string
    documentId?: StringWithAggregatesFilter<"DocumentVersion"> | string
    tenantId?: StringWithAggregatesFilter<"DocumentVersion"> | string
    version?: IntWithAggregatesFilter<"DocumentVersion"> | number
    fileName?: StringWithAggregatesFilter<"DocumentVersion"> | string
    originalName?: StringWithAggregatesFilter<"DocumentVersion"> | string
    mimeType?: StringWithAggregatesFilter<"DocumentVersion"> | string
    size?: IntWithAggregatesFilter<"DocumentVersion"> | number
    path?: StringWithAggregatesFilter<"DocumentVersion"> | string
    checksum?: StringNullableWithAggregatesFilter<"DocumentVersion"> | string | null
    changeNotes?: StringNullableWithAggregatesFilter<"DocumentVersion"> | string | null
    uploadedBy?: StringWithAggregatesFilter<"DocumentVersion"> | string
    isCurrent?: BoolWithAggregatesFilter<"DocumentVersion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DocumentVersion"> | Date | string
  }

  export type DocumentTagWhereInput = {
    AND?: DocumentTagWhereInput | DocumentTagWhereInput[]
    OR?: DocumentTagWhereInput[]
    NOT?: DocumentTagWhereInput | DocumentTagWhereInput[]
    id?: StringFilter<"DocumentTag"> | string
    tenantId?: StringFilter<"DocumentTag"> | string
    documentId?: StringFilter<"DocumentTag"> | string
    name?: StringFilter<"DocumentTag"> | string
    color?: StringNullableFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeFilter<"DocumentTag"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type DocumentTagOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentTagWhereInput | DocumentTagWhereInput[]
    OR?: DocumentTagWhereInput[]
    NOT?: DocumentTagWhereInput | DocumentTagWhereInput[]
    tenantId?: StringFilter<"DocumentTag"> | string
    documentId?: StringFilter<"DocumentTag"> | string
    name?: StringFilter<"DocumentTag"> | string
    color?: StringNullableFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeFilter<"DocumentTag"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }, "id">

  export type DocumentTagOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentTagCountOrderByAggregateInput
    _max?: DocumentTagMaxOrderByAggregateInput
    _min?: DocumentTagMinOrderByAggregateInput
  }

  export type DocumentTagScalarWhereWithAggregatesInput = {
    AND?: DocumentTagScalarWhereWithAggregatesInput | DocumentTagScalarWhereWithAggregatesInput[]
    OR?: DocumentTagScalarWhereWithAggregatesInput[]
    NOT?: DocumentTagScalarWhereWithAggregatesInput | DocumentTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentTag"> | string
    tenantId?: StringWithAggregatesFilter<"DocumentTag"> | string
    documentId?: StringWithAggregatesFilter<"DocumentTag"> | string
    name?: StringWithAggregatesFilter<"DocumentTag"> | string
    color?: StringNullableWithAggregatesFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentTag"> | Date | string
  }

  export type DocumentReadConfirmationWhereInput = {
    AND?: DocumentReadConfirmationWhereInput | DocumentReadConfirmationWhereInput[]
    OR?: DocumentReadConfirmationWhereInput[]
    NOT?: DocumentReadConfirmationWhereInput | DocumentReadConfirmationWhereInput[]
    id?: StringFilter<"DocumentReadConfirmation"> | string
    documentId?: StringFilter<"DocumentReadConfirmation"> | string
    tenantId?: StringFilter<"DocumentReadConfirmation"> | string
    userId?: StringFilter<"DocumentReadConfirmation"> | string
    confirmedAt?: DateTimeFilter<"DocumentReadConfirmation"> | Date | string
    ipAddress?: StringNullableFilter<"DocumentReadConfirmation"> | string | null
    userAgent?: StringNullableFilter<"DocumentReadConfirmation"> | string | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentReadConfirmationOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    confirmedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    document?: DocumentOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentReadConfirmationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId_userId?: DocumentReadConfirmationDocumentIdUserIdCompoundUniqueInput
    AND?: DocumentReadConfirmationWhereInput | DocumentReadConfirmationWhereInput[]
    OR?: DocumentReadConfirmationWhereInput[]
    NOT?: DocumentReadConfirmationWhereInput | DocumentReadConfirmationWhereInput[]
    documentId?: StringFilter<"DocumentReadConfirmation"> | string
    tenantId?: StringFilter<"DocumentReadConfirmation"> | string
    userId?: StringFilter<"DocumentReadConfirmation"> | string
    confirmedAt?: DateTimeFilter<"DocumentReadConfirmation"> | Date | string
    ipAddress?: StringNullableFilter<"DocumentReadConfirmation"> | string | null
    userAgent?: StringNullableFilter<"DocumentReadConfirmation"> | string | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "documentId_userId">

  export type DocumentReadConfirmationOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    confirmedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: DocumentReadConfirmationCountOrderByAggregateInput
    _max?: DocumentReadConfirmationMaxOrderByAggregateInput
    _min?: DocumentReadConfirmationMinOrderByAggregateInput
  }

  export type DocumentReadConfirmationScalarWhereWithAggregatesInput = {
    AND?: DocumentReadConfirmationScalarWhereWithAggregatesInput | DocumentReadConfirmationScalarWhereWithAggregatesInput[]
    OR?: DocumentReadConfirmationScalarWhereWithAggregatesInput[]
    NOT?: DocumentReadConfirmationScalarWhereWithAggregatesInput | DocumentReadConfirmationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentReadConfirmation"> | string
    documentId?: StringWithAggregatesFilter<"DocumentReadConfirmation"> | string
    tenantId?: StringWithAggregatesFilter<"DocumentReadConfirmation"> | string
    userId?: StringWithAggregatesFilter<"DocumentReadConfirmation"> | string
    confirmedAt?: DateTimeWithAggregatesFilter<"DocumentReadConfirmation"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"DocumentReadConfirmation"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"DocumentReadConfirmation"> | string | null
  }

  export type ReportTemplateWhereInput = {
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    tenantId?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    reportType?: EnumReportTypeFilter<"ReportTemplate"> | $Enums.ReportType
    status?: EnumReportStatusFilter<"ReportTemplate"> | $Enums.ReportStatus
    isPublic?: BoolFilter<"ReportTemplate"> | boolean
    createdBy?: StringFilter<"ReportTemplate"> | string
    metadata?: JsonNullableFilter<"ReportTemplate">
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    components?: ReportComponentListRelationFilter
    instances?: ScheduledReportListRelationFilter
  }

  export type ReportTemplateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    components?: ReportComponentOrderByRelationAggregateInput
    instances?: ScheduledReportOrderByRelationAggregateInput
  }

  export type ReportTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    tenantId?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    reportType?: EnumReportTypeFilter<"ReportTemplate"> | $Enums.ReportType
    status?: EnumReportStatusFilter<"ReportTemplate"> | $Enums.ReportStatus
    isPublic?: BoolFilter<"ReportTemplate"> | boolean
    createdBy?: StringFilter<"ReportTemplate"> | string
    metadata?: JsonNullableFilter<"ReportTemplate">
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    components?: ReportComponentListRelationFilter
    instances?: ScheduledReportListRelationFilter
  }, "id">

  export type ReportTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    reportType?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportTemplateCountOrderByAggregateInput
    _max?: ReportTemplateMaxOrderByAggregateInput
    _min?: ReportTemplateMinOrderByAggregateInput
  }

  export type ReportTemplateScalarWhereWithAggregatesInput = {
    AND?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    OR?: ReportTemplateScalarWhereWithAggregatesInput[]
    NOT?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportTemplate"> | string
    tenantId?: StringWithAggregatesFilter<"ReportTemplate"> | string
    name?: StringWithAggregatesFilter<"ReportTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    reportType?: EnumReportTypeWithAggregatesFilter<"ReportTemplate"> | $Enums.ReportType
    status?: EnumReportStatusWithAggregatesFilter<"ReportTemplate"> | $Enums.ReportStatus
    isPublic?: BoolWithAggregatesFilter<"ReportTemplate"> | boolean
    createdBy?: StringWithAggregatesFilter<"ReportTemplate"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ReportTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
  }

  export type ReportComponentWhereInput = {
    AND?: ReportComponentWhereInput | ReportComponentWhereInput[]
    OR?: ReportComponentWhereInput[]
    NOT?: ReportComponentWhereInput | ReportComponentWhereInput[]
    id?: StringFilter<"ReportComponent"> | string
    reportTemplateId?: StringFilter<"ReportComponent"> | string
    componentType?: EnumReportComponentTypeFilter<"ReportComponent"> | $Enums.ReportComponentType
    order?: IntFilter<"ReportComponent"> | number
    title?: StringNullableFilter<"ReportComponent"> | string | null
    configuration?: JsonFilter<"ReportComponent">
    dataSource?: JsonNullableFilter<"ReportComponent">
    style?: JsonNullableFilter<"ReportComponent">
    createdAt?: DateTimeFilter<"ReportComponent"> | Date | string
    updatedAt?: DateTimeFilter<"ReportComponent"> | Date | string
    reportTemplate?: XOR<ReportTemplateRelationFilter, ReportTemplateWhereInput>
  }

  export type ReportComponentOrderByWithRelationInput = {
    id?: SortOrder
    reportTemplateId?: SortOrder
    componentType?: SortOrder
    order?: SortOrder
    title?: SortOrderInput | SortOrder
    configuration?: SortOrder
    dataSource?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportTemplate?: ReportTemplateOrderByWithRelationInput
  }

  export type ReportComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportComponentWhereInput | ReportComponentWhereInput[]
    OR?: ReportComponentWhereInput[]
    NOT?: ReportComponentWhereInput | ReportComponentWhereInput[]
    reportTemplateId?: StringFilter<"ReportComponent"> | string
    componentType?: EnumReportComponentTypeFilter<"ReportComponent"> | $Enums.ReportComponentType
    order?: IntFilter<"ReportComponent"> | number
    title?: StringNullableFilter<"ReportComponent"> | string | null
    configuration?: JsonFilter<"ReportComponent">
    dataSource?: JsonNullableFilter<"ReportComponent">
    style?: JsonNullableFilter<"ReportComponent">
    createdAt?: DateTimeFilter<"ReportComponent"> | Date | string
    updatedAt?: DateTimeFilter<"ReportComponent"> | Date | string
    reportTemplate?: XOR<ReportTemplateRelationFilter, ReportTemplateWhereInput>
  }, "id">

  export type ReportComponentOrderByWithAggregationInput = {
    id?: SortOrder
    reportTemplateId?: SortOrder
    componentType?: SortOrder
    order?: SortOrder
    title?: SortOrderInput | SortOrder
    configuration?: SortOrder
    dataSource?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportComponentCountOrderByAggregateInput
    _avg?: ReportComponentAvgOrderByAggregateInput
    _max?: ReportComponentMaxOrderByAggregateInput
    _min?: ReportComponentMinOrderByAggregateInput
    _sum?: ReportComponentSumOrderByAggregateInput
  }

  export type ReportComponentScalarWhereWithAggregatesInput = {
    AND?: ReportComponentScalarWhereWithAggregatesInput | ReportComponentScalarWhereWithAggregatesInput[]
    OR?: ReportComponentScalarWhereWithAggregatesInput[]
    NOT?: ReportComponentScalarWhereWithAggregatesInput | ReportComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportComponent"> | string
    reportTemplateId?: StringWithAggregatesFilter<"ReportComponent"> | string
    componentType?: EnumReportComponentTypeWithAggregatesFilter<"ReportComponent"> | $Enums.ReportComponentType
    order?: IntWithAggregatesFilter<"ReportComponent"> | number
    title?: StringNullableWithAggregatesFilter<"ReportComponent"> | string | null
    configuration?: JsonWithAggregatesFilter<"ReportComponent">
    dataSource?: JsonNullableWithAggregatesFilter<"ReportComponent">
    style?: JsonNullableWithAggregatesFilter<"ReportComponent">
    createdAt?: DateTimeWithAggregatesFilter<"ReportComponent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportComponent"> | Date | string
  }

  export type ScheduledReportWhereInput = {
    AND?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    OR?: ScheduledReportWhereInput[]
    NOT?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    id?: StringFilter<"ScheduledReport"> | string
    tenantId?: StringFilter<"ScheduledReport"> | string
    reportTemplateId?: StringFilter<"ScheduledReport"> | string
    name?: StringFilter<"ScheduledReport"> | string
    description?: StringNullableFilter<"ScheduledReport"> | string | null
    frequency?: EnumReportFrequencyFilter<"ScheduledReport"> | $Enums.ReportFrequency
    schedule?: StringFilter<"ScheduledReport"> | string
    recipients?: JsonFilter<"ScheduledReport">
    format?: JsonFilter<"ScheduledReport">
    filters?: JsonNullableFilter<"ScheduledReport">
    status?: EnumReportStatusFilter<"ScheduledReport"> | $Enums.ReportStatus
    enabled?: BoolFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    createdBy?: StringFilter<"ScheduledReport"> | string
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    reportTemplate?: XOR<ReportTemplateRelationFilter, ReportTemplateWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executions?: ReportExecutionListRelationFilter
  }

  export type ScheduledReportOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    reportTemplateId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    recipients?: SortOrder
    format?: SortOrder
    filters?: SortOrderInput | SortOrder
    status?: SortOrder
    enabled?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    reportTemplate?: ReportTemplateOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    executions?: ReportExecutionOrderByRelationAggregateInput
  }

  export type ScheduledReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    OR?: ScheduledReportWhereInput[]
    NOT?: ScheduledReportWhereInput | ScheduledReportWhereInput[]
    tenantId?: StringFilter<"ScheduledReport"> | string
    reportTemplateId?: StringFilter<"ScheduledReport"> | string
    name?: StringFilter<"ScheduledReport"> | string
    description?: StringNullableFilter<"ScheduledReport"> | string | null
    frequency?: EnumReportFrequencyFilter<"ScheduledReport"> | $Enums.ReportFrequency
    schedule?: StringFilter<"ScheduledReport"> | string
    recipients?: JsonFilter<"ScheduledReport">
    format?: JsonFilter<"ScheduledReport">
    filters?: JsonNullableFilter<"ScheduledReport">
    status?: EnumReportStatusFilter<"ScheduledReport"> | $Enums.ReportStatus
    enabled?: BoolFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    createdBy?: StringFilter<"ScheduledReport"> | string
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    reportTemplate?: XOR<ReportTemplateRelationFilter, ReportTemplateWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executions?: ReportExecutionListRelationFilter
  }, "id">

  export type ScheduledReportOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    reportTemplateId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    recipients?: SortOrder
    format?: SortOrder
    filters?: SortOrderInput | SortOrder
    status?: SortOrder
    enabled?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledReportCountOrderByAggregateInput
    _max?: ScheduledReportMaxOrderByAggregateInput
    _min?: ScheduledReportMinOrderByAggregateInput
  }

  export type ScheduledReportScalarWhereWithAggregatesInput = {
    AND?: ScheduledReportScalarWhereWithAggregatesInput | ScheduledReportScalarWhereWithAggregatesInput[]
    OR?: ScheduledReportScalarWhereWithAggregatesInput[]
    NOT?: ScheduledReportScalarWhereWithAggregatesInput | ScheduledReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledReport"> | string
    tenantId?: StringWithAggregatesFilter<"ScheduledReport"> | string
    reportTemplateId?: StringWithAggregatesFilter<"ScheduledReport"> | string
    name?: StringWithAggregatesFilter<"ScheduledReport"> | string
    description?: StringNullableWithAggregatesFilter<"ScheduledReport"> | string | null
    frequency?: EnumReportFrequencyWithAggregatesFilter<"ScheduledReport"> | $Enums.ReportFrequency
    schedule?: StringWithAggregatesFilter<"ScheduledReport"> | string
    recipients?: JsonWithAggregatesFilter<"ScheduledReport">
    format?: JsonWithAggregatesFilter<"ScheduledReport">
    filters?: JsonNullableWithAggregatesFilter<"ScheduledReport">
    status?: EnumReportStatusWithAggregatesFilter<"ScheduledReport"> | $Enums.ReportStatus
    enabled?: BoolWithAggregatesFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableWithAggregatesFilter<"ScheduledReport"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"ScheduledReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledReport"> | Date | string
  }

  export type ReportExecutionWhereInput = {
    AND?: ReportExecutionWhereInput | ReportExecutionWhereInput[]
    OR?: ReportExecutionWhereInput[]
    NOT?: ReportExecutionWhereInput | ReportExecutionWhereInput[]
    id?: StringFilter<"ReportExecution"> | string
    scheduledReportId?: StringFilter<"ReportExecution"> | string
    status?: StringFilter<"ReportExecution"> | string
    errorMessage?: StringNullableFilter<"ReportExecution"> | string | null
    filePath?: StringNullableFilter<"ReportExecution"> | string | null
    fileSize?: IntNullableFilter<"ReportExecution"> | number | null
    startedAt?: DateTimeFilter<"ReportExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"ReportExecution"> | Date | string | null
    metadata?: JsonNullableFilter<"ReportExecution">
    scheduledReport?: XOR<ScheduledReportRelationFilter, ScheduledReportWhereInput>
  }

  export type ReportExecutionOrderByWithRelationInput = {
    id?: SortOrder
    scheduledReportId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledReport?: ScheduledReportOrderByWithRelationInput
  }

  export type ReportExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportExecutionWhereInput | ReportExecutionWhereInput[]
    OR?: ReportExecutionWhereInput[]
    NOT?: ReportExecutionWhereInput | ReportExecutionWhereInput[]
    scheduledReportId?: StringFilter<"ReportExecution"> | string
    status?: StringFilter<"ReportExecution"> | string
    errorMessage?: StringNullableFilter<"ReportExecution"> | string | null
    filePath?: StringNullableFilter<"ReportExecution"> | string | null
    fileSize?: IntNullableFilter<"ReportExecution"> | number | null
    startedAt?: DateTimeFilter<"ReportExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"ReportExecution"> | Date | string | null
    metadata?: JsonNullableFilter<"ReportExecution">
    scheduledReport?: XOR<ScheduledReportRelationFilter, ScheduledReportWhereInput>
  }, "id">

  export type ReportExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    scheduledReportId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ReportExecutionCountOrderByAggregateInput
    _avg?: ReportExecutionAvgOrderByAggregateInput
    _max?: ReportExecutionMaxOrderByAggregateInput
    _min?: ReportExecutionMinOrderByAggregateInput
    _sum?: ReportExecutionSumOrderByAggregateInput
  }

  export type ReportExecutionScalarWhereWithAggregatesInput = {
    AND?: ReportExecutionScalarWhereWithAggregatesInput | ReportExecutionScalarWhereWithAggregatesInput[]
    OR?: ReportExecutionScalarWhereWithAggregatesInput[]
    NOT?: ReportExecutionScalarWhereWithAggregatesInput | ReportExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportExecution"> | string
    scheduledReportId?: StringWithAggregatesFilter<"ReportExecution"> | string
    status?: StringWithAggregatesFilter<"ReportExecution"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ReportExecution"> | string | null
    filePath?: StringNullableWithAggregatesFilter<"ReportExecution"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"ReportExecution"> | number | null
    startedAt?: DateTimeWithAggregatesFilter<"ReportExecution"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ReportExecution"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ReportExecution">
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditCreateInput = {
    id?: string
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInternalAuditsInput
    auditProgram?: AuditProgramCreateNestedOneWithoutInternalAuditsInput
  }

  export type InternalAuditUncheckedCreateInput = {
    id?: string
    tenantId: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInternalAuditsNestedInput
    auditProgram?: AuditProgramUpdateOneWithoutInternalAuditsNestedInput
  }

  export type InternalAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditCreateManyInput = {
    id?: string
    tenantId: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditCreateInput = {
    id?: string
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExternalAuditsInput
    auditProgram?: AuditProgramCreateNestedOneWithoutExternalAuditsInput
  }

  export type ExternalAuditUncheckedCreateInput = {
    id?: string
    tenantId: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExternalAuditsNestedInput
    auditProgram?: AuditProgramUpdateOneWithoutExternalAuditsNestedInput
  }

  export type ExternalAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditCreateManyInput = {
    id?: string
    tenantId: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditProgramCreateInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditProgramsInput
    template?: AuditProgramCreateNestedOneWithoutDerivativesInput
    derivatives?: AuditProgramCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    derivatives?: AuditProgramUncheckedCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditProgramsNestedInput
    template?: AuditProgramUpdateOneWithoutDerivativesNestedInput
    derivatives?: AuditProgramUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    derivatives?: AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditChecklistCreateInput = {
    id?: string
    clause: string
    item: string
    requirement?: string | null
    evidenceType?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auditProgram: AuditProgramCreateNestedOneWithoutChecklistsInput
  }

  export type AuditChecklistUncheckedCreateInput = {
    id?: string
    auditProgramId: string
    clause: string
    item: string
    requirement?: string | null
    evidenceType?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditProgram?: AuditProgramUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type AuditChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditProgramId?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditChecklistCreateManyInput = {
    id?: string
    auditProgramId: string
    clause: string
    item: string
    requirement?: string | null
    evidenceType?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditProgramId?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemCreateInput = {
    id?: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutActionItemsInput
    rootCauseAnalysis?: RootCauseAnalysisCreateNestedOneWithoutActionItemInput
  }

  export type ActionItemUncheckedCreateInput = {
    id?: string
    tenantId: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
    rootCauseAnalysis?: RootCauseAnalysisUncheckedCreateNestedOneWithoutActionItemInput
  }

  export type ActionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutActionItemsNestedInput
    rootCauseAnalysis?: RootCauseAnalysisUpdateOneWithoutActionItemNestedInput
  }

  export type ActionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCauseAnalysis?: RootCauseAnalysisUncheckedUpdateOneWithoutActionItemNestedInput
  }

  export type ActionItemCreateManyInput = {
    id?: string
    tenantId: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RootCauseAnalysisCreateInput = {
    id?: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem: ActionItemCreateNestedOneWithoutRootCauseAnalysisInput
    tenant: TenantCreateNestedOneWithoutRootCauseAnalysesInput
  }

  export type RootCauseAnalysisUncheckedCreateInput = {
    id?: string
    actionItemId: string
    tenantId: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RootCauseAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneRequiredWithoutRootCauseAnalysisNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRootCauseAnalysesNestedInput
  }

  export type RootCauseAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionItemId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RootCauseAnalysisCreateManyInput = {
    id?: string
    actionItemId: string
    tenantId: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RootCauseAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RootCauseAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionItemId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceCreateInput = {
    id?: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel: string
    data: Date | string
    descricao: string
    resolucao?: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada?: string | null
    status: $Enums.OccurrenceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOccurrencesInput
  }

  export type OccurrenceUncheckedCreateInput = {
    id?: string
    tenantId: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel: string
    data: Date | string
    descricao: string
    resolucao?: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada?: string | null
    status: $Enums.OccurrenceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccurrenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOccurrencesNestedInput
  }

  export type OccurrenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceCreateManyInput = {
    id?: string
    tenantId: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel: string
    data: Date | string
    descricao: string
    resolucao?: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada?: string | null
    status: $Enums.OccurrenceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccurrenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorCreateInput = {
    id?: string
    nome: string
    responsavel: string
    email?: string | null
    telefone?: string | null
    descricao?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSectorsInput
  }

  export type SectorUncheckedCreateInput = {
    id?: string
    tenantId: string
    nome: string
    responsavel: string
    email?: string | null
    telefone?: string | null
    descricao?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSectorsNestedInput
  }

  export type SectorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorCreateManyInput = {
    id?: string
    tenantId: string
    nome: string
    responsavel: string
    email?: string | null
    telefone?: string | null
    descricao?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportLogCreateInput = {
    id?: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt?: Date | string
    finishedAt?: Date | string | null
    errorMessage?: string | null
    tenant: TenantCreateNestedOneWithoutImportLogsInput
  }

  export type ImportLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt?: Date | string
    finishedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type ImportLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutImportLogsNestedInput
  }

  export type ImportLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportLogCreateManyInput = {
    id?: string
    tenantId: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt?: Date | string
    finishedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type ImportLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditTrailsInput
    user?: UserCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditTrailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditTrailsNestedInput
    user?: UserUpdateOneWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditTrailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    id?: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAttachmentsInput
    user?: UserCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAttachmentsNestedInput
    user?: UserUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalCreateInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutApprovalsInput
    requester: UserCreateNestedOneWithoutApprovalRequestsInput
    approver?: UserCreateNestedOneWithoutApprovalApprovalsInput
  }

  export type ApprovalUncheckedCreateInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    requestedBy: string
    approvedBy?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutApprovalsNestedInput
    requester?: UserUpdateOneRequiredWithoutApprovalRequestsNestedInput
    approver?: UserUpdateOneWithoutApprovalApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalCreateManyInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    requestedBy: string
    approvedBy?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowDefinitionCreateInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowDefinitionsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowDefinitionInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowDefinitionInput
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowDefinitionsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowDefinitionNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type WorkflowDefinitionCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description?: string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: string | null
    autoAdvance?: boolean
    timeoutDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutStepsInput
  }

  export type WorkflowStepUncheckedCreateInput = {
    id?: string
    workflowDefinitionId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description?: string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: string | null
    autoAdvance?: boolean
    timeoutDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutStepsNestedInput
  }

  export type WorkflowStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateManyInput = {
    id?: string
    workflowDefinitionId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description?: string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: string | null
    autoAdvance?: boolean
    timeoutDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceCreateInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowInstancesInput
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    startedByUser: UserCreateNestedOneWithoutWorkflowInstancesInput
    cancelledByUser?: UserCreateNestedOneWithoutWorkflowCancelledInput
    stepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    startedByUser?: UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    cancelledByUser?: UserUpdateOneWithoutWorkflowCancelledNestedInput
    stepExecutions?: WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceCreateManyInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionCreateInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowInstance: WorkflowInstanceCreateNestedOneWithoutStepExecutionsInput
    executedByUser?: UserCreateNestedOneWithoutWorkflowStepExecutionsInput
  }

  export type WorkflowStepExecutionUncheckedCreateInput = {
    id?: string
    workflowInstanceId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    executedBy?: string | null
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowInstance?: WorkflowInstanceUpdateOneRequiredWithoutStepExecutionsNestedInput
    executedByUser?: UserUpdateOneWithoutWorkflowStepExecutionsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionCreateManyInput = {
    id?: string
    workflowInstanceId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    executedBy?: string | null
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    refreshToken: string
    status?: $Enums.SessionStatus
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshToken: string
    status?: $Enums.SessionStatus
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshToken: string
    status?: $Enums.SessionStatus
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    creator: UserCreateNestedOneWithoutCreatedDocumentsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentInput
    workflowInstance?: WorkflowInstanceCreateNestedOneWithoutDocumentsInput
    readConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentNestedInput
    workflowInstance?: WorkflowInstanceUpdateOneWithoutDocumentsNestedInput
    readConfirmations?: DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionCreateInput = {
    id?: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    isCurrent?: boolean
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutVersionsInput
    tenant: TenantCreateNestedOneWithoutDocumentVersionsInput
    uploader: UserCreateNestedOneWithoutUpdatedDocumentVersionsInput
  }

  export type DocumentVersionUncheckedCreateInput = {
    id?: string
    documentId: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    uploadedBy: string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutVersionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDocumentVersionsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUpdatedDocumentVersionsNestedInput
  }

  export type DocumentVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionCreateManyInput = {
    id?: string
    documentId: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    uploadedBy: string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagCreateInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentTagsInput
    document: DocumentCreateNestedOneWithoutTagsInput
  }

  export type DocumentTagUncheckedCreateInput = {
    id?: string
    tenantId: string
    documentId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type DocumentTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentTagsNestedInput
    document?: DocumentUpdateOneRequiredWithoutTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagCreateManyInput = {
    id?: string
    tenantId: string
    documentId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type DocumentTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentReadConfirmationCreateInput = {
    id?: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    document: DocumentCreateNestedOneWithoutReadConfirmationsInput
    tenant: TenantCreateNestedOneWithoutDocumentReadConfirmationsInput
    user: UserCreateNestedOneWithoutDocumentReadConfirmationsInput
  }

  export type DocumentReadConfirmationUncheckedCreateInput = {
    id?: string
    documentId: string
    tenantId: string
    userId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type DocumentReadConfirmationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentUpdateOneRequiredWithoutReadConfirmationsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput
    user?: UserUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput
  }

  export type DocumentReadConfirmationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentReadConfirmationCreateManyInput = {
    id?: string
    documentId: string
    tenantId: string
    userId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type DocumentReadConfirmationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentReadConfirmationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportTemplatesInput
    creator: UserCreateNestedOneWithoutCreatedReportTemplatesInput
    components?: ReportComponentCreateNestedManyWithoutReportTemplateInput
    instances?: ScheduledReportCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ReportComponentUncheckedCreateNestedManyWithoutReportTemplateInput
    instances?: ScheduledReportUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportTemplatesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedReportTemplatesNestedInput
    components?: ReportComponentUpdateManyWithoutReportTemplateNestedInput
    instances?: ScheduledReportUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ReportComponentUncheckedUpdateManyWithoutReportTemplateNestedInput
    instances?: ScheduledReportUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportComponentCreateInput = {
    id?: string
    componentType: $Enums.ReportComponentType
    order: number
    title?: string | null
    configuration: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reportTemplate: ReportTemplateCreateNestedOneWithoutComponentsInput
  }

  export type ReportComponentUncheckedCreateInput = {
    id?: string
    reportTemplateId: string
    componentType: $Enums.ReportComponentType
    order: number
    title?: string | null
    configuration: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportTemplate?: ReportTemplateUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ReportComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportComponentCreateManyInput = {
    id?: string
    reportTemplateId: string
    componentType: $Enums.ReportComponentType
    order: number
    title?: string | null
    configuration: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportCreateInput = {
    id?: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutScheduledReportsInput
    reportTemplate: ReportTemplateCreateNestedOneWithoutInstancesInput
    creator: UserCreateNestedOneWithoutCreatedScheduledReportsInput
    executions?: ReportExecutionCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportUncheckedCreateInput = {
    id?: string
    tenantId: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: ReportExecutionUncheckedCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScheduledReportsNestedInput
    reportTemplate?: ReportTemplateUpdateOneRequiredWithoutInstancesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedScheduledReportsNestedInput
    executions?: ReportExecutionUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: ReportExecutionUncheckedUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportCreateManyInput = {
    id?: string
    tenantId: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportExecutionCreateInput = {
    id?: string
    status: string
    errorMessage?: string | null
    filePath?: string | null
    fileSize?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledReport: ScheduledReportCreateNestedOneWithoutExecutionsInput
  }

  export type ReportExecutionUncheckedCreateInput = {
    id?: string
    scheduledReportId: string
    status: string
    errorMessage?: string | null
    filePath?: string | null
    fileSize?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledReport?: ScheduledReportUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type ReportExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledReportId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionCreateManyInput = {
    id?: string
    scheduledReportId: string
    status: string
    errorMessage?: string | null
    filePath?: string | null
    fileSize?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledReportId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type InternalAuditListRelationFilter = {
    every?: InternalAuditWhereInput
    some?: InternalAuditWhereInput
    none?: InternalAuditWhereInput
  }

  export type ExternalAuditListRelationFilter = {
    every?: ExternalAuditWhereInput
    some?: ExternalAuditWhereInput
    none?: ExternalAuditWhereInput
  }

  export type ActionItemListRelationFilter = {
    every?: ActionItemWhereInput
    some?: ActionItemWhereInput
    none?: ActionItemWhereInput
  }

  export type RootCauseAnalysisListRelationFilter = {
    every?: RootCauseAnalysisWhereInput
    some?: RootCauseAnalysisWhereInput
    none?: RootCauseAnalysisWhereInput
  }

  export type OccurrenceListRelationFilter = {
    every?: OccurrenceWhereInput
    some?: OccurrenceWhereInput
    none?: OccurrenceWhereInput
  }

  export type SectorListRelationFilter = {
    every?: SectorWhereInput
    some?: SectorWhereInput
    none?: SectorWhereInput
  }

  export type ImportLogListRelationFilter = {
    every?: ImportLogWhereInput
    some?: ImportLogWhereInput
    none?: ImportLogWhereInput
  }

  export type AuditTrailListRelationFilter = {
    every?: AuditTrailWhereInput
    some?: AuditTrailWhereInput
    none?: AuditTrailWhereInput
  }

  export type AuditProgramListRelationFilter = {
    every?: AuditProgramWhereInput
    some?: AuditProgramWhereInput
    none?: AuditProgramWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type WorkflowDefinitionListRelationFilter = {
    every?: WorkflowDefinitionWhereInput
    some?: WorkflowDefinitionWhereInput
    none?: WorkflowDefinitionWhereInput
  }

  export type WorkflowInstanceListRelationFilter = {
    every?: WorkflowInstanceWhereInput
    some?: WorkflowInstanceWhereInput
    none?: WorkflowInstanceWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentVersionListRelationFilter = {
    every?: DocumentVersionWhereInput
    some?: DocumentVersionWhereInput
    none?: DocumentVersionWhereInput
  }

  export type DocumentTagListRelationFilter = {
    every?: DocumentTagWhereInput
    some?: DocumentTagWhereInput
    none?: DocumentTagWhereInput
  }

  export type DocumentReadConfirmationListRelationFilter = {
    every?: DocumentReadConfirmationWhereInput
    some?: DocumentReadConfirmationWhereInput
    none?: DocumentReadConfirmationWhereInput
  }

  export type ReportTemplateListRelationFilter = {
    every?: ReportTemplateWhereInput
    some?: ReportTemplateWhereInput
    none?: ReportTemplateWhereInput
  }

  export type ScheduledReportListRelationFilter = {
    every?: ScheduledReportWhereInput
    some?: ScheduledReportWhereInput
    none?: ScheduledReportWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InternalAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RootCauseAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OccurrenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditTrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentReadConfirmationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type WorkflowStepExecutionListRelationFilter = {
    every?: WorkflowStepExecutionWhereInput
    some?: WorkflowStepExecutionWhereInput
    none?: WorkflowStepExecutionWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type WorkflowStepExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AuditProgramNullableRelationFilter = {
    is?: AuditProgramWhereInput | null
    isNot?: AuditProgramWhereInput | null
  }

  export type InternalAuditCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternalAuditAvgOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type InternalAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternalAuditMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternalAuditSumOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ExternalAuditCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAuditAvgOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type ExternalAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAuditMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    auditProgramId?: SortOrder
    ano?: SortOrder
    entidadeAuditora?: SortOrder
    iso?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAuditSumOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type AuditChecklistListRelationFilter = {
    every?: AuditChecklistWhereInput
    some?: AuditChecklistWhereInput
    none?: AuditChecklistWhereInput
  }

  export type AuditChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditProgramCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    standard?: SortOrder
    version?: SortOrder
    isTemplate?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    standard?: SortOrder
    version?: SortOrder
    isTemplate?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditProgramMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    standard?: SortOrder
    version?: SortOrder
    isTemplate?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditProgramRelationFilter = {
    is?: AuditProgramWhereInput
    isNot?: AuditProgramWhereInput
  }

  export type AuditChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    auditProgramId?: SortOrder
    clause?: SortOrder
    item?: SortOrder
    requirement?: SortOrder
    evidenceType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditChecklistAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AuditChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    auditProgramId?: SortOrder
    clause?: SortOrder
    item?: SortOrder
    requirement?: SortOrder
    evidenceType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    auditProgramId?: SortOrder
    clause?: SortOrder
    item?: SortOrder
    requirement?: SortOrder
    evidenceType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditChecklistSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumActionOriginFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionOrigin | EnumActionOriginFieldRefInput<$PrismaModel>
    in?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    not?: NestedEnumActionOriginFilter<$PrismaModel> | $Enums.ActionOrigin
  }

  export type EnumConformidadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Conformidade | EnumConformidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConformidadeNullableFilter<$PrismaModel> | $Enums.Conformidade | null
  }

  export type EnumActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusFilter<$PrismaModel> | $Enums.ActionStatus
  }

  export type EnumImpactFilter<$PrismaModel = never> = {
    equals?: $Enums.Impact | EnumImpactFieldRefInput<$PrismaModel>
    in?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumImpactFilter<$PrismaModel> | $Enums.Impact
  }

  export type RootCauseAnalysisNullableRelationFilter = {
    is?: RootCauseAnalysisWhereInput | null
    isNot?: RootCauseAnalysisWhereInput | null
  }

  export type ActionItemCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    origem?: SortOrder
    acaoRelacionada?: SortOrder
    conformidade?: SortOrder
    numeroAssociado?: SortOrder
    ambito?: SortOrder
    descricao?: SortOrder
    causaRaizIdentificada?: SortOrder
    acaoCorretiva?: SortOrder
    local?: SortOrder
    responsavel?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    conclusao?: SortOrder
    status?: SortOrder
    mes?: SortOrder
    evidencia?: SortOrder
    avaliacaoEficacia?: SortOrder
    setor?: SortOrder
    dataAbertura?: SortOrder
    dataLimite?: SortOrder
    dataConclusao?: SortOrder
    impacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    origem?: SortOrder
    acaoRelacionada?: SortOrder
    conformidade?: SortOrder
    numeroAssociado?: SortOrder
    ambito?: SortOrder
    descricao?: SortOrder
    causaRaizIdentificada?: SortOrder
    acaoCorretiva?: SortOrder
    local?: SortOrder
    responsavel?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    conclusao?: SortOrder
    status?: SortOrder
    mes?: SortOrder
    evidencia?: SortOrder
    avaliacaoEficacia?: SortOrder
    setor?: SortOrder
    dataAbertura?: SortOrder
    dataLimite?: SortOrder
    dataConclusao?: SortOrder
    impacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionItemMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    origem?: SortOrder
    acaoRelacionada?: SortOrder
    conformidade?: SortOrder
    numeroAssociado?: SortOrder
    ambito?: SortOrder
    descricao?: SortOrder
    causaRaizIdentificada?: SortOrder
    acaoCorretiva?: SortOrder
    local?: SortOrder
    responsavel?: SortOrder
    inicio?: SortOrder
    termino?: SortOrder
    conclusao?: SortOrder
    status?: SortOrder
    mes?: SortOrder
    evidencia?: SortOrder
    avaliacaoEficacia?: SortOrder
    setor?: SortOrder
    dataAbertura?: SortOrder
    dataLimite?: SortOrder
    dataConclusao?: SortOrder
    impacto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActionOriginWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionOrigin | EnumActionOriginFieldRefInput<$PrismaModel>
    in?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    not?: NestedEnumActionOriginWithAggregatesFilter<$PrismaModel> | $Enums.ActionOrigin
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionOriginFilter<$PrismaModel>
    _max?: NestedEnumActionOriginFilter<$PrismaModel>
  }

  export type EnumConformidadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Conformidade | EnumConformidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConformidadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Conformidade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConformidadeNullableFilter<$PrismaModel>
    _max?: NestedEnumConformidadeNullableFilter<$PrismaModel>
  }

  export type EnumActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionStatusFilter<$PrismaModel>
    _max?: NestedEnumActionStatusFilter<$PrismaModel>
  }

  export type EnumImpactWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Impact | EnumImpactFieldRefInput<$PrismaModel>
    in?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumImpactWithAggregatesFilter<$PrismaModel> | $Enums.Impact
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImpactFilter<$PrismaModel>
    _max?: NestedEnumImpactFilter<$PrismaModel>
  }

  export type EnumRootCauseAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RootCauseAnalysisType | EnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel> | $Enums.RootCauseAnalysisType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActionItemRelationFilter = {
    is?: ActionItemWhereInput
    isNot?: ActionItemWhereInput
  }

  export type RootCauseAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    actionItemId?: SortOrder
    tenantId?: SortOrder
    analysisType?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RootCauseAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    actionItemId?: SortOrder
    tenantId?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RootCauseAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    actionItemId?: SortOrder
    tenantId?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRootCauseAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RootCauseAnalysisType | EnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRootCauseAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.RootCauseAnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumOccurrenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceType | EnumOccurrenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceTypeFilter<$PrismaModel> | $Enums.OccurrenceType
  }

  export type EnumOccurrenceSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceSeverity | EnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceSeverityFilter<$PrismaModel> | $Enums.OccurrenceSeverity
  }

  export type EnumOccurrenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusFilter<$PrismaModel> | $Enums.OccurrenceStatus
  }

  export type OccurrenceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tipo?: SortOrder
    setor?: SortOrder
    departamentosAtingidos?: SortOrder
    responsavel?: SortOrder
    data?: SortOrder
    descricao?: SortOrder
    resolucao?: SortOrder
    gravidade?: SortOrder
    acaoGerada?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccurrenceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tipo?: SortOrder
    setor?: SortOrder
    responsavel?: SortOrder
    data?: SortOrder
    descricao?: SortOrder
    resolucao?: SortOrder
    gravidade?: SortOrder
    acaoGerada?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OccurrenceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tipo?: SortOrder
    setor?: SortOrder
    responsavel?: SortOrder
    data?: SortOrder
    descricao?: SortOrder
    resolucao?: SortOrder
    gravidade?: SortOrder
    acaoGerada?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOccurrenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceType | EnumOccurrenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceTypeFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceTypeFilter<$PrismaModel>
  }

  export type EnumOccurrenceSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceSeverity | EnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceSeverityWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceSeverityFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceSeverityFilter<$PrismaModel>
  }

  export type EnumOccurrenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
  }

  export type SectorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    descricao?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type ImportLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fileName?: SortOrder
    mode?: SortOrder
    entity?: SortOrder
    status?: SortOrder
    totalRecords?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type ImportLogAvgOrderByAggregateInput = {
    totalRecords?: SortOrder
  }

  export type ImportLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fileName?: SortOrder
    mode?: SortOrder
    entity?: SortOrder
    status?: SortOrder
    totalRecords?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type ImportLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fileName?: SortOrder
    mode?: SortOrder
    entity?: SortOrder
    status?: SortOrder
    totalRecords?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type ImportLogSumOrderByAggregateInput = {
    totalRecords?: SortOrder
  }

  export type EnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditTrailCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditTrailMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditTrailMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type ApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type WorkflowStepListRelationFilter = {
    every?: WorkflowStepWhereInput
    some?: WorkflowStepWhereInput
    none?: WorkflowStepWhereInput
  }

  export type WorkflowStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entityType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entityType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entityType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkflowStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeFilter<$PrismaModel> | $Enums.WorkflowStepType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type WorkflowDefinitionRelationFilter = {
    is?: WorkflowDefinitionWhereInput
    isNot?: WorkflowDefinitionWhereInput
  }

  export type WorkflowStepCountOrderByAggregateInput = {
    id?: SortOrder
    workflowDefinitionId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredRoles?: SortOrder
    requiredUsers?: SortOrder
    conditionExpression?: SortOrder
    notificationTemplate?: SortOrder
    autoAdvance?: SortOrder
    timeoutDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepAvgOrderByAggregateInput = {
    stepOrder?: SortOrder
    timeoutDays?: SortOrder
  }

  export type WorkflowStepMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowDefinitionId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notificationTemplate?: SortOrder
    autoAdvance?: SortOrder
    timeoutDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepMinOrderByAggregateInput = {
    id?: SortOrder
    workflowDefinitionId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notificationTemplate?: SortOrder
    autoAdvance?: SortOrder
    timeoutDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepSumOrderByAggregateInput = {
    stepOrder?: SortOrder
    timeoutDays?: SortOrder
  }

  export type EnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type WorkflowInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    workflowDefinitionId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    startedBy?: SortOrder
    currentStepOrder?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowInstanceAvgOrderByAggregateInput = {
    currentStepOrder?: SortOrder
  }

  export type WorkflowInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    workflowDefinitionId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    startedBy?: SortOrder
    currentStepOrder?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    workflowDefinitionId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    startedBy?: SortOrder
    currentStepOrder?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowInstanceSumOrderByAggregateInput = {
    currentStepOrder?: SortOrder
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type WorkflowInstanceRelationFilter = {
    is?: WorkflowInstanceWhereInput
    isNot?: WorkflowInstanceWhereInput
  }

  export type WorkflowStepExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    workflowInstanceId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    status?: SortOrder
    executedBy?: SortOrder
    comments?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepExecutionAvgOrderByAggregateInput = {
    stepOrder?: SortOrder
  }

  export type WorkflowStepExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowInstanceId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    status?: SortOrder
    executedBy?: SortOrder
    comments?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    workflowInstanceId?: SortOrder
    stepOrder?: SortOrder
    stepType?: SortOrder
    status?: SortOrder
    executedBy?: SortOrder
    comments?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkflowStepExecutionSumOrderByAggregateInput = {
    stepOrder?: SortOrder
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type EnumDocumentAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentAccessLevel | EnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentAccessLevelFilter<$PrismaModel> | $Enums.DocumentAccessLevel
  }

  export type WorkflowInstanceNullableRelationFilter = {
    is?: WorkflowInstanceWhereInput | null
    isNot?: WorkflowInstanceWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    accessLevel?: SortOrder
    currentVersion?: SortOrder
    createdBy?: SortOrder
    workflowInstanceId?: SortOrder
    allowedRoles?: SortOrder
    allowedUsers?: SortOrder
    metadata?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    currentVersion?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    accessLevel?: SortOrder
    currentVersion?: SortOrder
    createdBy?: SortOrder
    workflowInstanceId?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    accessLevel?: SortOrder
    currentVersion?: SortOrder
    createdBy?: SortOrder
    workflowInstanceId?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    currentVersion?: SortOrder
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentAccessLevel | EnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.DocumentAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumDocumentAccessLevelFilter<$PrismaModel>
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentVersionDocumentIdVersionCompoundUniqueInput = {
    documentId: string
    version: number
  }

  export type DocumentVersionCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    version?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    checksum?: SortOrder
    changeNotes?: SortOrder
    uploadedBy?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentVersionAvgOrderByAggregateInput = {
    version?: SortOrder
    size?: SortOrder
  }

  export type DocumentVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    version?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    checksum?: SortOrder
    changeNotes?: SortOrder
    uploadedBy?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentVersionMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    version?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    checksum?: SortOrder
    changeNotes?: SortOrder
    uploadedBy?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentVersionSumOrderByAggregateInput = {
    version?: SortOrder
    size?: SortOrder
  }

  export type DocumentTagCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentTagMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentTagMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    documentId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentReadConfirmationDocumentIdUserIdCompoundUniqueInput = {
    documentId: string
    userId: string
  }

  export type DocumentReadConfirmationCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    confirmedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type DocumentReadConfirmationMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    confirmedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type DocumentReadConfirmationMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    confirmedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportComponentListRelationFilter = {
    every?: ReportComponentWhereInput
    some?: ReportComponentWhereInput
    none?: ReportComponentWhereInput
  }

  export type ReportComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    reportType?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumReportComponentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportComponentType | EnumReportComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportComponentTypeFilter<$PrismaModel> | $Enums.ReportComponentType
  }

  export type ReportTemplateRelationFilter = {
    is?: ReportTemplateWhereInput
    isNot?: ReportTemplateWhereInput
  }

  export type ReportComponentCountOrderByAggregateInput = {
    id?: SortOrder
    reportTemplateId?: SortOrder
    componentType?: SortOrder
    order?: SortOrder
    title?: SortOrder
    configuration?: SortOrder
    dataSource?: SortOrder
    style?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportComponentAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ReportComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    reportTemplateId?: SortOrder
    componentType?: SortOrder
    order?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportComponentMinOrderByAggregateInput = {
    id?: SortOrder
    reportTemplateId?: SortOrder
    componentType?: SortOrder
    order?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportComponentSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumReportComponentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportComponentType | EnumReportComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportComponentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportComponentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportComponentTypeFilter<$PrismaModel>
    _max?: NestedEnumReportComponentTypeFilter<$PrismaModel>
  }

  export type EnumReportFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyFilter<$PrismaModel> | $Enums.ReportFrequency
  }

  export type ReportExecutionListRelationFilter = {
    every?: ReportExecutionWhereInput
    some?: ReportExecutionWhereInput
    none?: ReportExecutionWhereInput
  }

  export type ReportExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledReportCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    reportTemplateId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    recipients?: SortOrder
    format?: SortOrder
    filters?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    reportTemplateId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledReportMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    reportTemplateId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    status?: SortOrder
    enabled?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ReportFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFrequencyFilter<$PrismaModel>
    _max?: NestedEnumReportFrequencyFilter<$PrismaModel>
  }

  export type ScheduledReportRelationFilter = {
    is?: ScheduledReportWhereInput
    isNot?: ScheduledReportWhereInput
  }

  export type ReportExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    scheduledReportId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
  }

  export type ReportExecutionAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ReportExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduledReportId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ReportExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    scheduledReportId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ReportExecutionSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type InternalAuditCreateNestedManyWithoutTenantInput = {
    create?: XOR<InternalAuditCreateWithoutTenantInput, InternalAuditUncheckedCreateWithoutTenantInput> | InternalAuditCreateWithoutTenantInput[] | InternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutTenantInput | InternalAuditCreateOrConnectWithoutTenantInput[]
    createMany?: InternalAuditCreateManyTenantInputEnvelope
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
  }

  export type ExternalAuditCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExternalAuditCreateWithoutTenantInput, ExternalAuditUncheckedCreateWithoutTenantInput> | ExternalAuditCreateWithoutTenantInput[] | ExternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutTenantInput | ExternalAuditCreateOrConnectWithoutTenantInput[]
    createMany?: ExternalAuditCreateManyTenantInputEnvelope
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
  }

  export type ActionItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<ActionItemCreateWithoutTenantInput, ActionItemUncheckedCreateWithoutTenantInput> | ActionItemCreateWithoutTenantInput[] | ActionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutTenantInput | ActionItemCreateOrConnectWithoutTenantInput[]
    createMany?: ActionItemCreateManyTenantInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type RootCauseAnalysisCreateNestedManyWithoutTenantInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutTenantInput, RootCauseAnalysisUncheckedCreateWithoutTenantInput> | RootCauseAnalysisCreateWithoutTenantInput[] | RootCauseAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutTenantInput | RootCauseAnalysisCreateOrConnectWithoutTenantInput[]
    createMany?: RootCauseAnalysisCreateManyTenantInputEnvelope
    connect?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
  }

  export type OccurrenceCreateNestedManyWithoutTenantInput = {
    create?: XOR<OccurrenceCreateWithoutTenantInput, OccurrenceUncheckedCreateWithoutTenantInput> | OccurrenceCreateWithoutTenantInput[] | OccurrenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutTenantInput | OccurrenceCreateOrConnectWithoutTenantInput[]
    createMany?: OccurrenceCreateManyTenantInputEnvelope
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
  }

  export type SectorCreateNestedManyWithoutTenantInput = {
    create?: XOR<SectorCreateWithoutTenantInput, SectorUncheckedCreateWithoutTenantInput> | SectorCreateWithoutTenantInput[] | SectorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutTenantInput | SectorCreateOrConnectWithoutTenantInput[]
    createMany?: SectorCreateManyTenantInputEnvelope
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
  }

  export type ImportLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<ImportLogCreateWithoutTenantInput, ImportLogUncheckedCreateWithoutTenantInput> | ImportLogCreateWithoutTenantInput[] | ImportLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutTenantInput | ImportLogCreateOrConnectWithoutTenantInput[]
    createMany?: ImportLogCreateManyTenantInputEnvelope
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
  }

  export type AuditTrailCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditTrailCreateWithoutTenantInput, AuditTrailUncheckedCreateWithoutTenantInput> | AuditTrailCreateWithoutTenantInput[] | AuditTrailUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutTenantInput | AuditTrailCreateOrConnectWithoutTenantInput[]
    createMany?: AuditTrailCreateManyTenantInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type AuditProgramCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditProgramCreateWithoutTenantInput, AuditProgramUncheckedCreateWithoutTenantInput> | AuditProgramCreateWithoutTenantInput[] | AuditProgramUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTenantInput | AuditProgramCreateOrConnectWithoutTenantInput[]
    createMany?: AuditProgramCreateManyTenantInputEnvelope
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<AttachmentCreateWithoutTenantInput, AttachmentUncheckedCreateWithoutTenantInput> | AttachmentCreateWithoutTenantInput[] | AttachmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenantInput | AttachmentCreateOrConnectWithoutTenantInput[]
    createMany?: AttachmentCreateManyTenantInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTenantInput = {
    create?: XOR<CommentCreateWithoutTenantInput, CommentUncheckedCreateWithoutTenantInput> | CommentCreateWithoutTenantInput[] | CommentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTenantInput | CommentCreateOrConnectWithoutTenantInput[]
    createMany?: CommentCreateManyTenantInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutTenantInput = {
    create?: XOR<ApprovalCreateWithoutTenantInput, ApprovalUncheckedCreateWithoutTenantInput> | ApprovalCreateWithoutTenantInput[] | ApprovalUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTenantInput | ApprovalCreateOrConnectWithoutTenantInput[]
    createMany?: ApprovalCreateManyTenantInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type WorkflowDefinitionCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutTenantInput, WorkflowDefinitionUncheckedCreateWithoutTenantInput> | WorkflowDefinitionCreateWithoutTenantInput[] | WorkflowDefinitionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutTenantInput | WorkflowDefinitionCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowDefinitionCreateManyTenantInputEnvelope
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowInstanceCreateWithoutTenantInput, WorkflowInstanceUncheckedCreateWithoutTenantInput> | WorkflowInstanceCreateWithoutTenantInput[] | WorkflowInstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutTenantInput | WorkflowInstanceCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowInstanceCreateManyTenantInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentVersionCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentVersionCreateWithoutTenantInput, DocumentVersionUncheckedCreateWithoutTenantInput> | DocumentVersionCreateWithoutTenantInput[] | DocumentVersionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutTenantInput | DocumentVersionCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentVersionCreateManyTenantInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentTagCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentTagCreateWithoutTenantInput, DocumentTagUncheckedCreateWithoutTenantInput> | DocumentTagCreateWithoutTenantInput[] | DocumentTagUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutTenantInput | DocumentTagCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentTagCreateManyTenantInputEnvelope
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type DocumentReadConfirmationCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutTenantInput, DocumentReadConfirmationUncheckedCreateWithoutTenantInput> | DocumentReadConfirmationCreateWithoutTenantInput[] | DocumentReadConfirmationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutTenantInput | DocumentReadConfirmationCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentReadConfirmationCreateManyTenantInputEnvelope
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
  }

  export type ReportTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScheduledReportCreateWithoutTenantInput, ScheduledReportUncheckedCreateWithoutTenantInput> | ScheduledReportCreateWithoutTenantInput[] | ScheduledReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTenantInput | ScheduledReportCreateOrConnectWithoutTenantInput[]
    createMany?: ScheduledReportCreateManyTenantInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type InternalAuditUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InternalAuditCreateWithoutTenantInput, InternalAuditUncheckedCreateWithoutTenantInput> | InternalAuditCreateWithoutTenantInput[] | InternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutTenantInput | InternalAuditCreateOrConnectWithoutTenantInput[]
    createMany?: InternalAuditCreateManyTenantInputEnvelope
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
  }

  export type ExternalAuditUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExternalAuditCreateWithoutTenantInput, ExternalAuditUncheckedCreateWithoutTenantInput> | ExternalAuditCreateWithoutTenantInput[] | ExternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutTenantInput | ExternalAuditCreateOrConnectWithoutTenantInput[]
    createMany?: ExternalAuditCreateManyTenantInputEnvelope
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
  }

  export type ActionItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ActionItemCreateWithoutTenantInput, ActionItemUncheckedCreateWithoutTenantInput> | ActionItemCreateWithoutTenantInput[] | ActionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutTenantInput | ActionItemCreateOrConnectWithoutTenantInput[]
    createMany?: ActionItemCreateManyTenantInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutTenantInput, RootCauseAnalysisUncheckedCreateWithoutTenantInput> | RootCauseAnalysisCreateWithoutTenantInput[] | RootCauseAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutTenantInput | RootCauseAnalysisCreateOrConnectWithoutTenantInput[]
    createMany?: RootCauseAnalysisCreateManyTenantInputEnvelope
    connect?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
  }

  export type OccurrenceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OccurrenceCreateWithoutTenantInput, OccurrenceUncheckedCreateWithoutTenantInput> | OccurrenceCreateWithoutTenantInput[] | OccurrenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutTenantInput | OccurrenceCreateOrConnectWithoutTenantInput[]
    createMany?: OccurrenceCreateManyTenantInputEnvelope
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
  }

  export type SectorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SectorCreateWithoutTenantInput, SectorUncheckedCreateWithoutTenantInput> | SectorCreateWithoutTenantInput[] | SectorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutTenantInput | SectorCreateOrConnectWithoutTenantInput[]
    createMany?: SectorCreateManyTenantInputEnvelope
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
  }

  export type ImportLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ImportLogCreateWithoutTenantInput, ImportLogUncheckedCreateWithoutTenantInput> | ImportLogCreateWithoutTenantInput[] | ImportLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutTenantInput | ImportLogCreateOrConnectWithoutTenantInput[]
    createMany?: ImportLogCreateManyTenantInputEnvelope
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
  }

  export type AuditTrailUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditTrailCreateWithoutTenantInput, AuditTrailUncheckedCreateWithoutTenantInput> | AuditTrailCreateWithoutTenantInput[] | AuditTrailUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutTenantInput | AuditTrailCreateOrConnectWithoutTenantInput[]
    createMany?: AuditTrailCreateManyTenantInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type AuditProgramUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditProgramCreateWithoutTenantInput, AuditProgramUncheckedCreateWithoutTenantInput> | AuditProgramCreateWithoutTenantInput[] | AuditProgramUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTenantInput | AuditProgramCreateOrConnectWithoutTenantInput[]
    createMany?: AuditProgramCreateManyTenantInputEnvelope
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AttachmentCreateWithoutTenantInput, AttachmentUncheckedCreateWithoutTenantInput> | AttachmentCreateWithoutTenantInput[] | AttachmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenantInput | AttachmentCreateOrConnectWithoutTenantInput[]
    createMany?: AttachmentCreateManyTenantInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CommentCreateWithoutTenantInput, CommentUncheckedCreateWithoutTenantInput> | CommentCreateWithoutTenantInput[] | CommentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTenantInput | CommentCreateOrConnectWithoutTenantInput[]
    createMany?: CommentCreateManyTenantInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ApprovalCreateWithoutTenantInput, ApprovalUncheckedCreateWithoutTenantInput> | ApprovalCreateWithoutTenantInput[] | ApprovalUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTenantInput | ApprovalCreateOrConnectWithoutTenantInput[]
    createMany?: ApprovalCreateManyTenantInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutTenantInput, WorkflowDefinitionUncheckedCreateWithoutTenantInput> | WorkflowDefinitionCreateWithoutTenantInput[] | WorkflowDefinitionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutTenantInput | WorkflowDefinitionCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowDefinitionCreateManyTenantInputEnvelope
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WorkflowInstanceCreateWithoutTenantInput, WorkflowInstanceUncheckedCreateWithoutTenantInput> | WorkflowInstanceCreateWithoutTenantInput[] | WorkflowInstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutTenantInput | WorkflowInstanceCreateOrConnectWithoutTenantInput[]
    createMany?: WorkflowInstanceCreateManyTenantInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentVersionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentVersionCreateWithoutTenantInput, DocumentVersionUncheckedCreateWithoutTenantInput> | DocumentVersionCreateWithoutTenantInput[] | DocumentVersionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutTenantInput | DocumentVersionCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentVersionCreateManyTenantInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentTagUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentTagCreateWithoutTenantInput, DocumentTagUncheckedCreateWithoutTenantInput> | DocumentTagCreateWithoutTenantInput[] | DocumentTagUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutTenantInput | DocumentTagCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentTagCreateManyTenantInputEnvelope
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutTenantInput, DocumentReadConfirmationUncheckedCreateWithoutTenantInput> | DocumentReadConfirmationCreateWithoutTenantInput[] | DocumentReadConfirmationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutTenantInput | DocumentReadConfirmationCreateOrConnectWithoutTenantInput[]
    createMany?: DocumentReadConfirmationCreateManyTenantInputEnvelope
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
  }

  export type ReportTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ScheduledReportCreateWithoutTenantInput, ScheduledReportUncheckedCreateWithoutTenantInput> | ScheduledReportCreateWithoutTenantInput[] | ScheduledReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTenantInput | ScheduledReportCreateOrConnectWithoutTenantInput[]
    createMany?: ScheduledReportCreateManyTenantInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type InternalAuditUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InternalAuditCreateWithoutTenantInput, InternalAuditUncheckedCreateWithoutTenantInput> | InternalAuditCreateWithoutTenantInput[] | InternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutTenantInput | InternalAuditCreateOrConnectWithoutTenantInput[]
    upsert?: InternalAuditUpsertWithWhereUniqueWithoutTenantInput | InternalAuditUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InternalAuditCreateManyTenantInputEnvelope
    set?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    disconnect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    delete?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    update?: InternalAuditUpdateWithWhereUniqueWithoutTenantInput | InternalAuditUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InternalAuditUpdateManyWithWhereWithoutTenantInput | InternalAuditUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InternalAuditScalarWhereInput | InternalAuditScalarWhereInput[]
  }

  export type ExternalAuditUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExternalAuditCreateWithoutTenantInput, ExternalAuditUncheckedCreateWithoutTenantInput> | ExternalAuditCreateWithoutTenantInput[] | ExternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutTenantInput | ExternalAuditCreateOrConnectWithoutTenantInput[]
    upsert?: ExternalAuditUpsertWithWhereUniqueWithoutTenantInput | ExternalAuditUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExternalAuditCreateManyTenantInputEnvelope
    set?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    disconnect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    delete?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    update?: ExternalAuditUpdateWithWhereUniqueWithoutTenantInput | ExternalAuditUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExternalAuditUpdateManyWithWhereWithoutTenantInput | ExternalAuditUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExternalAuditScalarWhereInput | ExternalAuditScalarWhereInput[]
  }

  export type ActionItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ActionItemCreateWithoutTenantInput, ActionItemUncheckedCreateWithoutTenantInput> | ActionItemCreateWithoutTenantInput[] | ActionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutTenantInput | ActionItemCreateOrConnectWithoutTenantInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutTenantInput | ActionItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ActionItemCreateManyTenantInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutTenantInput | ActionItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutTenantInput | ActionItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type RootCauseAnalysisUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutTenantInput, RootCauseAnalysisUncheckedCreateWithoutTenantInput> | RootCauseAnalysisCreateWithoutTenantInput[] | RootCauseAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutTenantInput | RootCauseAnalysisCreateOrConnectWithoutTenantInput[]
    upsert?: RootCauseAnalysisUpsertWithWhereUniqueWithoutTenantInput | RootCauseAnalysisUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RootCauseAnalysisCreateManyTenantInputEnvelope
    set?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    disconnect?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    delete?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    connect?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    update?: RootCauseAnalysisUpdateWithWhereUniqueWithoutTenantInput | RootCauseAnalysisUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RootCauseAnalysisUpdateManyWithWhereWithoutTenantInput | RootCauseAnalysisUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RootCauseAnalysisScalarWhereInput | RootCauseAnalysisScalarWhereInput[]
  }

  export type OccurrenceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OccurrenceCreateWithoutTenantInput, OccurrenceUncheckedCreateWithoutTenantInput> | OccurrenceCreateWithoutTenantInput[] | OccurrenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutTenantInput | OccurrenceCreateOrConnectWithoutTenantInput[]
    upsert?: OccurrenceUpsertWithWhereUniqueWithoutTenantInput | OccurrenceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OccurrenceCreateManyTenantInputEnvelope
    set?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    disconnect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    delete?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    update?: OccurrenceUpdateWithWhereUniqueWithoutTenantInput | OccurrenceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OccurrenceUpdateManyWithWhereWithoutTenantInput | OccurrenceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
  }

  export type SectorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SectorCreateWithoutTenantInput, SectorUncheckedCreateWithoutTenantInput> | SectorCreateWithoutTenantInput[] | SectorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutTenantInput | SectorCreateOrConnectWithoutTenantInput[]
    upsert?: SectorUpsertWithWhereUniqueWithoutTenantInput | SectorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SectorCreateManyTenantInputEnvelope
    set?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    disconnect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    delete?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    update?: SectorUpdateWithWhereUniqueWithoutTenantInput | SectorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SectorUpdateManyWithWhereWithoutTenantInput | SectorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SectorScalarWhereInput | SectorScalarWhereInput[]
  }

  export type ImportLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ImportLogCreateWithoutTenantInput, ImportLogUncheckedCreateWithoutTenantInput> | ImportLogCreateWithoutTenantInput[] | ImportLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutTenantInput | ImportLogCreateOrConnectWithoutTenantInput[]
    upsert?: ImportLogUpsertWithWhereUniqueWithoutTenantInput | ImportLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ImportLogCreateManyTenantInputEnvelope
    set?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    disconnect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    delete?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    update?: ImportLogUpdateWithWhereUniqueWithoutTenantInput | ImportLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ImportLogUpdateManyWithWhereWithoutTenantInput | ImportLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
  }

  export type AuditTrailUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditTrailCreateWithoutTenantInput, AuditTrailUncheckedCreateWithoutTenantInput> | AuditTrailCreateWithoutTenantInput[] | AuditTrailUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutTenantInput | AuditTrailCreateOrConnectWithoutTenantInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutTenantInput | AuditTrailUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditTrailCreateManyTenantInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutTenantInput | AuditTrailUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutTenantInput | AuditTrailUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type AuditProgramUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditProgramCreateWithoutTenantInput, AuditProgramUncheckedCreateWithoutTenantInput> | AuditProgramCreateWithoutTenantInput[] | AuditProgramUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTenantInput | AuditProgramCreateOrConnectWithoutTenantInput[]
    upsert?: AuditProgramUpsertWithWhereUniqueWithoutTenantInput | AuditProgramUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditProgramCreateManyTenantInputEnvelope
    set?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    disconnect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    delete?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    update?: AuditProgramUpdateWithWhereUniqueWithoutTenantInput | AuditProgramUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditProgramUpdateManyWithWhereWithoutTenantInput | AuditProgramUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditProgramScalarWhereInput | AuditProgramScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AttachmentCreateWithoutTenantInput, AttachmentUncheckedCreateWithoutTenantInput> | AttachmentCreateWithoutTenantInput[] | AttachmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenantInput | AttachmentCreateOrConnectWithoutTenantInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTenantInput | AttachmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AttachmentCreateManyTenantInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTenantInput | AttachmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTenantInput | AttachmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CommentCreateWithoutTenantInput, CommentUncheckedCreateWithoutTenantInput> | CommentCreateWithoutTenantInput[] | CommentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTenantInput | CommentCreateOrConnectWithoutTenantInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTenantInput | CommentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CommentCreateManyTenantInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTenantInput | CommentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTenantInput | CommentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ApprovalCreateWithoutTenantInput, ApprovalUncheckedCreateWithoutTenantInput> | ApprovalCreateWithoutTenantInput[] | ApprovalUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTenantInput | ApprovalCreateOrConnectWithoutTenantInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutTenantInput | ApprovalUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ApprovalCreateManyTenantInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutTenantInput | ApprovalUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutTenantInput | ApprovalUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type WorkflowDefinitionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutTenantInput, WorkflowDefinitionUncheckedCreateWithoutTenantInput> | WorkflowDefinitionCreateWithoutTenantInput[] | WorkflowDefinitionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutTenantInput | WorkflowDefinitionCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowDefinitionUpsertWithWhereUniqueWithoutTenantInput | WorkflowDefinitionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowDefinitionCreateManyTenantInputEnvelope
    set?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    disconnect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    delete?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    update?: WorkflowDefinitionUpdateWithWhereUniqueWithoutTenantInput | WorkflowDefinitionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowDefinitionUpdateManyWithWhereWithoutTenantInput | WorkflowDefinitionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutTenantInput, WorkflowInstanceUncheckedCreateWithoutTenantInput> | WorkflowInstanceCreateWithoutTenantInput[] | WorkflowInstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutTenantInput | WorkflowInstanceCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutTenantInput | WorkflowInstanceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowInstanceCreateManyTenantInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutTenantInput | WorkflowInstanceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutTenantInput | WorkflowInstanceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentVersionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutTenantInput, DocumentVersionUncheckedCreateWithoutTenantInput> | DocumentVersionCreateWithoutTenantInput[] | DocumentVersionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutTenantInput | DocumentVersionCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutTenantInput | DocumentVersionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentVersionCreateManyTenantInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutTenantInput | DocumentVersionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutTenantInput | DocumentVersionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentTagUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentTagCreateWithoutTenantInput, DocumentTagUncheckedCreateWithoutTenantInput> | DocumentTagCreateWithoutTenantInput[] | DocumentTagUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutTenantInput | DocumentTagCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutTenantInput | DocumentTagUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentTagCreateManyTenantInputEnvelope
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutTenantInput | DocumentTagUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutTenantInput | DocumentTagUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type DocumentReadConfirmationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutTenantInput, DocumentReadConfirmationUncheckedCreateWithoutTenantInput> | DocumentReadConfirmationCreateWithoutTenantInput[] | DocumentReadConfirmationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutTenantInput | DocumentReadConfirmationCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentReadConfirmationUpsertWithWhereUniqueWithoutTenantInput | DocumentReadConfirmationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentReadConfirmationCreateManyTenantInputEnvelope
    set?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    disconnect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    delete?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    update?: DocumentReadConfirmationUpdateWithWhereUniqueWithoutTenantInput | DocumentReadConfirmationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentReadConfirmationUpdateManyWithWhereWithoutTenantInput | DocumentReadConfirmationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
  }

  export type ReportTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutTenantInput | ReportTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutTenantInput | ReportTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutTenantInput | ReportTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutTenantInput, ScheduledReportUncheckedCreateWithoutTenantInput> | ScheduledReportCreateWithoutTenantInput[] | ScheduledReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTenantInput | ScheduledReportCreateOrConnectWithoutTenantInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutTenantInput | ScheduledReportUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScheduledReportCreateManyTenantInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutTenantInput | ScheduledReportUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutTenantInput | ScheduledReportUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type InternalAuditUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InternalAuditCreateWithoutTenantInput, InternalAuditUncheckedCreateWithoutTenantInput> | InternalAuditCreateWithoutTenantInput[] | InternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutTenantInput | InternalAuditCreateOrConnectWithoutTenantInput[]
    upsert?: InternalAuditUpsertWithWhereUniqueWithoutTenantInput | InternalAuditUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InternalAuditCreateManyTenantInputEnvelope
    set?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    disconnect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    delete?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    update?: InternalAuditUpdateWithWhereUniqueWithoutTenantInput | InternalAuditUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InternalAuditUpdateManyWithWhereWithoutTenantInput | InternalAuditUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InternalAuditScalarWhereInput | InternalAuditScalarWhereInput[]
  }

  export type ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExternalAuditCreateWithoutTenantInput, ExternalAuditUncheckedCreateWithoutTenantInput> | ExternalAuditCreateWithoutTenantInput[] | ExternalAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutTenantInput | ExternalAuditCreateOrConnectWithoutTenantInput[]
    upsert?: ExternalAuditUpsertWithWhereUniqueWithoutTenantInput | ExternalAuditUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExternalAuditCreateManyTenantInputEnvelope
    set?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    disconnect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    delete?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    update?: ExternalAuditUpdateWithWhereUniqueWithoutTenantInput | ExternalAuditUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExternalAuditUpdateManyWithWhereWithoutTenantInput | ExternalAuditUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExternalAuditScalarWhereInput | ExternalAuditScalarWhereInput[]
  }

  export type ActionItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ActionItemCreateWithoutTenantInput, ActionItemUncheckedCreateWithoutTenantInput> | ActionItemCreateWithoutTenantInput[] | ActionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutTenantInput | ActionItemCreateOrConnectWithoutTenantInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutTenantInput | ActionItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ActionItemCreateManyTenantInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutTenantInput | ActionItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutTenantInput | ActionItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutTenantInput, RootCauseAnalysisUncheckedCreateWithoutTenantInput> | RootCauseAnalysisCreateWithoutTenantInput[] | RootCauseAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutTenantInput | RootCauseAnalysisCreateOrConnectWithoutTenantInput[]
    upsert?: RootCauseAnalysisUpsertWithWhereUniqueWithoutTenantInput | RootCauseAnalysisUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RootCauseAnalysisCreateManyTenantInputEnvelope
    set?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    disconnect?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    delete?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    connect?: RootCauseAnalysisWhereUniqueInput | RootCauseAnalysisWhereUniqueInput[]
    update?: RootCauseAnalysisUpdateWithWhereUniqueWithoutTenantInput | RootCauseAnalysisUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RootCauseAnalysisUpdateManyWithWhereWithoutTenantInput | RootCauseAnalysisUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RootCauseAnalysisScalarWhereInput | RootCauseAnalysisScalarWhereInput[]
  }

  export type OccurrenceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OccurrenceCreateWithoutTenantInput, OccurrenceUncheckedCreateWithoutTenantInput> | OccurrenceCreateWithoutTenantInput[] | OccurrenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutTenantInput | OccurrenceCreateOrConnectWithoutTenantInput[]
    upsert?: OccurrenceUpsertWithWhereUniqueWithoutTenantInput | OccurrenceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OccurrenceCreateManyTenantInputEnvelope
    set?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    disconnect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    delete?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    update?: OccurrenceUpdateWithWhereUniqueWithoutTenantInput | OccurrenceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OccurrenceUpdateManyWithWhereWithoutTenantInput | OccurrenceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
  }

  export type SectorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SectorCreateWithoutTenantInput, SectorUncheckedCreateWithoutTenantInput> | SectorCreateWithoutTenantInput[] | SectorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SectorCreateOrConnectWithoutTenantInput | SectorCreateOrConnectWithoutTenantInput[]
    upsert?: SectorUpsertWithWhereUniqueWithoutTenantInput | SectorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SectorCreateManyTenantInputEnvelope
    set?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    disconnect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    delete?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    connect?: SectorWhereUniqueInput | SectorWhereUniqueInput[]
    update?: SectorUpdateWithWhereUniqueWithoutTenantInput | SectorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SectorUpdateManyWithWhereWithoutTenantInput | SectorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SectorScalarWhereInput | SectorScalarWhereInput[]
  }

  export type ImportLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ImportLogCreateWithoutTenantInput, ImportLogUncheckedCreateWithoutTenantInput> | ImportLogCreateWithoutTenantInput[] | ImportLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ImportLogCreateOrConnectWithoutTenantInput | ImportLogCreateOrConnectWithoutTenantInput[]
    upsert?: ImportLogUpsertWithWhereUniqueWithoutTenantInput | ImportLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ImportLogCreateManyTenantInputEnvelope
    set?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    disconnect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    delete?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    connect?: ImportLogWhereUniqueInput | ImportLogWhereUniqueInput[]
    update?: ImportLogUpdateWithWhereUniqueWithoutTenantInput | ImportLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ImportLogUpdateManyWithWhereWithoutTenantInput | ImportLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
  }

  export type AuditTrailUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditTrailCreateWithoutTenantInput, AuditTrailUncheckedCreateWithoutTenantInput> | AuditTrailCreateWithoutTenantInput[] | AuditTrailUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutTenantInput | AuditTrailCreateOrConnectWithoutTenantInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutTenantInput | AuditTrailUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditTrailCreateManyTenantInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutTenantInput | AuditTrailUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutTenantInput | AuditTrailUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type AuditProgramUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditProgramCreateWithoutTenantInput, AuditProgramUncheckedCreateWithoutTenantInput> | AuditProgramCreateWithoutTenantInput[] | AuditProgramUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTenantInput | AuditProgramCreateOrConnectWithoutTenantInput[]
    upsert?: AuditProgramUpsertWithWhereUniqueWithoutTenantInput | AuditProgramUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditProgramCreateManyTenantInputEnvelope
    set?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    disconnect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    delete?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    update?: AuditProgramUpdateWithWhereUniqueWithoutTenantInput | AuditProgramUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditProgramUpdateManyWithWhereWithoutTenantInput | AuditProgramUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditProgramScalarWhereInput | AuditProgramScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AttachmentCreateWithoutTenantInput, AttachmentUncheckedCreateWithoutTenantInput> | AttachmentCreateWithoutTenantInput[] | AttachmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenantInput | AttachmentCreateOrConnectWithoutTenantInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTenantInput | AttachmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AttachmentCreateManyTenantInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTenantInput | AttachmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTenantInput | AttachmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CommentCreateWithoutTenantInput, CommentUncheckedCreateWithoutTenantInput> | CommentCreateWithoutTenantInput[] | CommentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTenantInput | CommentCreateOrConnectWithoutTenantInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTenantInput | CommentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CommentCreateManyTenantInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTenantInput | CommentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTenantInput | CommentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ApprovalCreateWithoutTenantInput, ApprovalUncheckedCreateWithoutTenantInput> | ApprovalCreateWithoutTenantInput[] | ApprovalUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTenantInput | ApprovalCreateOrConnectWithoutTenantInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutTenantInput | ApprovalUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ApprovalCreateManyTenantInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutTenantInput | ApprovalUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutTenantInput | ApprovalUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutTenantInput, WorkflowDefinitionUncheckedCreateWithoutTenantInput> | WorkflowDefinitionCreateWithoutTenantInput[] | WorkflowDefinitionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutTenantInput | WorkflowDefinitionCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowDefinitionUpsertWithWhereUniqueWithoutTenantInput | WorkflowDefinitionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowDefinitionCreateManyTenantInputEnvelope
    set?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    disconnect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    delete?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    connect?: WorkflowDefinitionWhereUniqueInput | WorkflowDefinitionWhereUniqueInput[]
    update?: WorkflowDefinitionUpdateWithWhereUniqueWithoutTenantInput | WorkflowDefinitionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowDefinitionUpdateManyWithWhereWithoutTenantInput | WorkflowDefinitionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutTenantInput, WorkflowInstanceUncheckedCreateWithoutTenantInput> | WorkflowInstanceCreateWithoutTenantInput[] | WorkflowInstanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutTenantInput | WorkflowInstanceCreateOrConnectWithoutTenantInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutTenantInput | WorkflowInstanceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WorkflowInstanceCreateManyTenantInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutTenantInput | WorkflowInstanceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutTenantInput | WorkflowInstanceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput> | DocumentCreateWithoutTenantInput[] | DocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutTenantInput | DocumentCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutTenantInput | DocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentCreateManyTenantInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutTenantInput | DocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutTenantInput | DocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutTenantInput, DocumentVersionUncheckedCreateWithoutTenantInput> | DocumentVersionCreateWithoutTenantInput[] | DocumentVersionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutTenantInput | DocumentVersionCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutTenantInput | DocumentVersionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentVersionCreateManyTenantInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutTenantInput | DocumentVersionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutTenantInput | DocumentVersionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentTagUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentTagCreateWithoutTenantInput, DocumentTagUncheckedCreateWithoutTenantInput> | DocumentTagCreateWithoutTenantInput[] | DocumentTagUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutTenantInput | DocumentTagCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutTenantInput | DocumentTagUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentTagCreateManyTenantInputEnvelope
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutTenantInput | DocumentTagUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutTenantInput | DocumentTagUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutTenantInput, DocumentReadConfirmationUncheckedCreateWithoutTenantInput> | DocumentReadConfirmationCreateWithoutTenantInput[] | DocumentReadConfirmationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutTenantInput | DocumentReadConfirmationCreateOrConnectWithoutTenantInput[]
    upsert?: DocumentReadConfirmationUpsertWithWhereUniqueWithoutTenantInput | DocumentReadConfirmationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DocumentReadConfirmationCreateManyTenantInputEnvelope
    set?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    disconnect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    delete?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    update?: DocumentReadConfirmationUpdateWithWhereUniqueWithoutTenantInput | DocumentReadConfirmationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DocumentReadConfirmationUpdateManyWithWhereWithoutTenantInput | DocumentReadConfirmationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
  }

  export type ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutTenantInput | ReportTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutTenantInput | ReportTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutTenantInput | ReportTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutTenantInput, ScheduledReportUncheckedCreateWithoutTenantInput> | ScheduledReportCreateWithoutTenantInput[] | ScheduledReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutTenantInput | ScheduledReportCreateOrConnectWithoutTenantInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutTenantInput | ScheduledReportUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ScheduledReportCreateManyTenantInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutTenantInput | ScheduledReportUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutTenantInput | ScheduledReportUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type AuditTrailCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ApprovalCreateWithoutRequesterInput, ApprovalUncheckedCreateWithoutRequesterInput> | ApprovalCreateWithoutRequesterInput[] | ApprovalUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutRequesterInput | ApprovalCreateOrConnectWithoutRequesterInput[]
    createMany?: ApprovalCreateManyRequesterInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutStartedByUserInput = {
    create?: XOR<WorkflowInstanceCreateWithoutStartedByUserInput, WorkflowInstanceUncheckedCreateWithoutStartedByUserInput> | WorkflowInstanceCreateWithoutStartedByUserInput[] | WorkflowInstanceUncheckedCreateWithoutStartedByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutStartedByUserInput | WorkflowInstanceCreateOrConnectWithoutStartedByUserInput[]
    createMany?: WorkflowInstanceCreateManyStartedByUserInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput = {
    create?: XOR<WorkflowInstanceCreateWithoutCancelledByUserInput, WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput> | WorkflowInstanceCreateWithoutCancelledByUserInput[] | WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput | WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput[]
    createMany?: WorkflowInstanceCreateManyCancelledByUserInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput> | WorkflowStepExecutionCreateWithoutExecutedByUserInput[] | WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput | WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput[]
    createMany?: WorkflowStepExecutionCreateManyExecutedByUserInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DocumentCreateWithoutCreatorInput, DocumentUncheckedCreateWithoutCreatorInput> | DocumentCreateWithoutCreatorInput[] | DocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatorInput | DocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: DocumentCreateManyCreatorInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentVersionCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentVersionCreateWithoutUploaderInput, DocumentVersionUncheckedCreateWithoutUploaderInput> | DocumentVersionCreateWithoutUploaderInput[] | DocumentVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUploaderInput | DocumentVersionCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentVersionCreateManyUploaderInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type ReportTemplateCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatorInput, ReportTemplateUncheckedCreateWithoutCreatorInput> | ReportTemplateCreateWithoutCreatorInput[] | ReportTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatorInput | ReportTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: ReportTemplateCreateManyCreatorInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatorInput, ScheduledReportUncheckedCreateWithoutCreatorInput> | ScheduledReportCreateWithoutCreatorInput[] | ScheduledReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatorInput | ScheduledReportCreateOrConnectWithoutCreatorInput[]
    createMany?: ScheduledReportCreateManyCreatorInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type DocumentReadConfirmationCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutUserInput, DocumentReadConfirmationUncheckedCreateWithoutUserInput> | DocumentReadConfirmationCreateWithoutUserInput[] | DocumentReadConfirmationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutUserInput | DocumentReadConfirmationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentReadConfirmationCreateManyUserInputEnvelope
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditTrailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ApprovalCreateWithoutRequesterInput, ApprovalUncheckedCreateWithoutRequesterInput> | ApprovalCreateWithoutRequesterInput[] | ApprovalUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutRequesterInput | ApprovalCreateOrConnectWithoutRequesterInput[]
    createMany?: ApprovalCreateManyRequesterInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput = {
    create?: XOR<WorkflowInstanceCreateWithoutStartedByUserInput, WorkflowInstanceUncheckedCreateWithoutStartedByUserInput> | WorkflowInstanceCreateWithoutStartedByUserInput[] | WorkflowInstanceUncheckedCreateWithoutStartedByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutStartedByUserInput | WorkflowInstanceCreateOrConnectWithoutStartedByUserInput[]
    createMany?: WorkflowInstanceCreateManyStartedByUserInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput = {
    create?: XOR<WorkflowInstanceCreateWithoutCancelledByUserInput, WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput> | WorkflowInstanceCreateWithoutCancelledByUserInput[] | WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput | WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput[]
    createMany?: WorkflowInstanceCreateManyCancelledByUserInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput> | WorkflowStepExecutionCreateWithoutExecutedByUserInput[] | WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput | WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput[]
    createMany?: WorkflowStepExecutionCreateManyExecutedByUserInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DocumentCreateWithoutCreatorInput, DocumentUncheckedCreateWithoutCreatorInput> | DocumentCreateWithoutCreatorInput[] | DocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatorInput | DocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: DocumentCreateManyCreatorInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentVersionCreateWithoutUploaderInput, DocumentVersionUncheckedCreateWithoutUploaderInput> | DocumentVersionCreateWithoutUploaderInput[] | DocumentVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUploaderInput | DocumentVersionCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentVersionCreateManyUploaderInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatorInput, ReportTemplateUncheckedCreateWithoutCreatorInput> | ReportTemplateCreateWithoutCreatorInput[] | ReportTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatorInput | ReportTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: ReportTemplateCreateManyCreatorInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatorInput, ScheduledReportUncheckedCreateWithoutCreatorInput> | ScheduledReportCreateWithoutCreatorInput[] | ScheduledReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatorInput | ScheduledReportCreateOrConnectWithoutCreatorInput[]
    createMany?: ScheduledReportCreateManyCreatorInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutUserInput, DocumentReadConfirmationUncheckedCreateWithoutUserInput> | DocumentReadConfirmationCreateWithoutUserInput[] | DocumentReadConfirmationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutUserInput | DocumentReadConfirmationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentReadConfirmationCreateManyUserInputEnvelope
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type AuditTrailUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutUserInput | AuditTrailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutUserInput | AuditTrailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutUserInput | AuditTrailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ApprovalCreateWithoutRequesterInput, ApprovalUncheckedCreateWithoutRequesterInput> | ApprovalCreateWithoutRequesterInput[] | ApprovalUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutRequesterInput | ApprovalCreateOrConnectWithoutRequesterInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutRequesterInput | ApprovalUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ApprovalCreateManyRequesterInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutRequesterInput | ApprovalUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutRequesterInput | ApprovalUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutApproverInput | ApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutApproverInput | ApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutApproverInput | ApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutStartedByUserInput, WorkflowInstanceUncheckedCreateWithoutStartedByUserInput> | WorkflowInstanceCreateWithoutStartedByUserInput[] | WorkflowInstanceUncheckedCreateWithoutStartedByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutStartedByUserInput | WorkflowInstanceCreateOrConnectWithoutStartedByUserInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutStartedByUserInput | WorkflowInstanceUpsertWithWhereUniqueWithoutStartedByUserInput[]
    createMany?: WorkflowInstanceCreateManyStartedByUserInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutStartedByUserInput | WorkflowInstanceUpdateWithWhereUniqueWithoutStartedByUserInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutStartedByUserInput | WorkflowInstanceUpdateManyWithWhereWithoutStartedByUserInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutCancelledByUserInput, WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput> | WorkflowInstanceCreateWithoutCancelledByUserInput[] | WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput | WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutCancelledByUserInput | WorkflowInstanceUpsertWithWhereUniqueWithoutCancelledByUserInput[]
    createMany?: WorkflowInstanceCreateManyCancelledByUserInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutCancelledByUserInput | WorkflowInstanceUpdateWithWhereUniqueWithoutCancelledByUserInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutCancelledByUserInput | WorkflowInstanceUpdateManyWithWhereWithoutCancelledByUserInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput> | WorkflowStepExecutionCreateWithoutExecutedByUserInput[] | WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput | WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutExecutedByUserInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutExecutedByUserInput[]
    createMany?: WorkflowStepExecutionCreateManyExecutedByUserInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutExecutedByUserInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutExecutedByUserInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutExecutedByUserInput | WorkflowStepExecutionUpdateManyWithWhereWithoutExecutedByUserInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DocumentCreateWithoutCreatorInput, DocumentUncheckedCreateWithoutCreatorInput> | DocumentCreateWithoutCreatorInput[] | DocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatorInput | DocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCreatorInput | DocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DocumentCreateManyCreatorInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCreatorInput | DocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCreatorInput | DocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentVersionUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutUploaderInput, DocumentVersionUncheckedCreateWithoutUploaderInput> | DocumentVersionCreateWithoutUploaderInput[] | DocumentVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUploaderInput | DocumentVersionCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutUploaderInput | DocumentVersionUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentVersionCreateManyUploaderInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutUploaderInput | DocumentVersionUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutUploaderInput | DocumentVersionUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type ReportTemplateUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatorInput, ReportTemplateUncheckedCreateWithoutCreatorInput> | ReportTemplateCreateWithoutCreatorInput[] | ReportTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatorInput | ReportTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutCreatorInput | ReportTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ReportTemplateCreateManyCreatorInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutCreatorInput | ReportTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutCreatorInput | ReportTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatorInput, ScheduledReportUncheckedCreateWithoutCreatorInput> | ScheduledReportCreateWithoutCreatorInput[] | ScheduledReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatorInput | ScheduledReportCreateOrConnectWithoutCreatorInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutCreatorInput | ScheduledReportUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ScheduledReportCreateManyCreatorInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutCreatorInput | ScheduledReportUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutCreatorInput | ScheduledReportUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type DocumentReadConfirmationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutUserInput, DocumentReadConfirmationUncheckedCreateWithoutUserInput> | DocumentReadConfirmationCreateWithoutUserInput[] | DocumentReadConfirmationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutUserInput | DocumentReadConfirmationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentReadConfirmationUpsertWithWhereUniqueWithoutUserInput | DocumentReadConfirmationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentReadConfirmationCreateManyUserInputEnvelope
    set?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    disconnect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    delete?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    update?: DocumentReadConfirmationUpdateWithWhereUniqueWithoutUserInput | DocumentReadConfirmationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentReadConfirmationUpdateManyWithWhereWithoutUserInput | DocumentReadConfirmationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditTrailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutUserInput | AuditTrailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutUserInput | AuditTrailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutUserInput | AuditTrailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ApprovalCreateWithoutRequesterInput, ApprovalUncheckedCreateWithoutRequesterInput> | ApprovalCreateWithoutRequesterInput[] | ApprovalUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutRequesterInput | ApprovalCreateOrConnectWithoutRequesterInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutRequesterInput | ApprovalUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ApprovalCreateManyRequesterInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutRequesterInput | ApprovalUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutRequesterInput | ApprovalUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutApproverInput | ApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutApproverInput | ApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutApproverInput | ApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutStartedByUserInput, WorkflowInstanceUncheckedCreateWithoutStartedByUserInput> | WorkflowInstanceCreateWithoutStartedByUserInput[] | WorkflowInstanceUncheckedCreateWithoutStartedByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutStartedByUserInput | WorkflowInstanceCreateOrConnectWithoutStartedByUserInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutStartedByUserInput | WorkflowInstanceUpsertWithWhereUniqueWithoutStartedByUserInput[]
    createMany?: WorkflowInstanceCreateManyStartedByUserInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutStartedByUserInput | WorkflowInstanceUpdateWithWhereUniqueWithoutStartedByUserInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutStartedByUserInput | WorkflowInstanceUpdateManyWithWhereWithoutStartedByUserInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutCancelledByUserInput, WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput> | WorkflowInstanceCreateWithoutCancelledByUserInput[] | WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput | WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutCancelledByUserInput | WorkflowInstanceUpsertWithWhereUniqueWithoutCancelledByUserInput[]
    createMany?: WorkflowInstanceCreateManyCancelledByUserInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutCancelledByUserInput | WorkflowInstanceUpdateWithWhereUniqueWithoutCancelledByUserInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutCancelledByUserInput | WorkflowInstanceUpdateManyWithWhereWithoutCancelledByUserInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput> | WorkflowStepExecutionCreateWithoutExecutedByUserInput[] | WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput | WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutExecutedByUserInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutExecutedByUserInput[]
    createMany?: WorkflowStepExecutionCreateManyExecutedByUserInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutExecutedByUserInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutExecutedByUserInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutExecutedByUserInput | WorkflowStepExecutionUpdateManyWithWhereWithoutExecutedByUserInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DocumentCreateWithoutCreatorInput, DocumentUncheckedCreateWithoutCreatorInput> | DocumentCreateWithoutCreatorInput[] | DocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatorInput | DocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCreatorInput | DocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DocumentCreateManyCreatorInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCreatorInput | DocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCreatorInput | DocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutUploaderInput, DocumentVersionUncheckedCreateWithoutUploaderInput> | DocumentVersionCreateWithoutUploaderInput[] | DocumentVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUploaderInput | DocumentVersionCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutUploaderInput | DocumentVersionUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentVersionCreateManyUploaderInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutUploaderInput | DocumentVersionUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutUploaderInput | DocumentVersionUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutCreatorInput, ReportTemplateUncheckedCreateWithoutCreatorInput> | ReportTemplateCreateWithoutCreatorInput[] | ReportTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutCreatorInput | ReportTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutCreatorInput | ReportTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ReportTemplateCreateManyCreatorInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutCreatorInput | ReportTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutCreatorInput | ReportTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutCreatorInput, ScheduledReportUncheckedCreateWithoutCreatorInput> | ScheduledReportCreateWithoutCreatorInput[] | ScheduledReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutCreatorInput | ScheduledReportCreateOrConnectWithoutCreatorInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutCreatorInput | ScheduledReportUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ScheduledReportCreateManyCreatorInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutCreatorInput | ScheduledReportUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutCreatorInput | ScheduledReportUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutUserInput, DocumentReadConfirmationUncheckedCreateWithoutUserInput> | DocumentReadConfirmationCreateWithoutUserInput[] | DocumentReadConfirmationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutUserInput | DocumentReadConfirmationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentReadConfirmationUpsertWithWhereUniqueWithoutUserInput | DocumentReadConfirmationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentReadConfirmationCreateManyUserInputEnvelope
    set?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    disconnect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    delete?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    update?: DocumentReadConfirmationUpdateWithWhereUniqueWithoutUserInput | DocumentReadConfirmationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentReadConfirmationUpdateManyWithWhereWithoutUserInput | DocumentReadConfirmationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantCreateNestedOneWithoutInternalAuditsInput = {
    create?: XOR<TenantCreateWithoutInternalAuditsInput, TenantUncheckedCreateWithoutInternalAuditsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInternalAuditsInput
    connect?: TenantWhereUniqueInput
  }

  export type AuditProgramCreateNestedOneWithoutInternalAuditsInput = {
    create?: XOR<AuditProgramCreateWithoutInternalAuditsInput, AuditProgramUncheckedCreateWithoutInternalAuditsInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutInternalAuditsInput
    connect?: AuditProgramWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutInternalAuditsNestedInput = {
    create?: XOR<TenantCreateWithoutInternalAuditsInput, TenantUncheckedCreateWithoutInternalAuditsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInternalAuditsInput
    upsert?: TenantUpsertWithoutInternalAuditsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInternalAuditsInput, TenantUpdateWithoutInternalAuditsInput>, TenantUncheckedUpdateWithoutInternalAuditsInput>
  }

  export type AuditProgramUpdateOneWithoutInternalAuditsNestedInput = {
    create?: XOR<AuditProgramCreateWithoutInternalAuditsInput, AuditProgramUncheckedCreateWithoutInternalAuditsInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutInternalAuditsInput
    upsert?: AuditProgramUpsertWithoutInternalAuditsInput
    disconnect?: AuditProgramWhereInput | boolean
    delete?: AuditProgramWhereInput | boolean
    connect?: AuditProgramWhereUniqueInput
    update?: XOR<XOR<AuditProgramUpdateToOneWithWhereWithoutInternalAuditsInput, AuditProgramUpdateWithoutInternalAuditsInput>, AuditProgramUncheckedUpdateWithoutInternalAuditsInput>
  }

  export type TenantCreateNestedOneWithoutExternalAuditsInput = {
    create?: XOR<TenantCreateWithoutExternalAuditsInput, TenantUncheckedCreateWithoutExternalAuditsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExternalAuditsInput
    connect?: TenantWhereUniqueInput
  }

  export type AuditProgramCreateNestedOneWithoutExternalAuditsInput = {
    create?: XOR<AuditProgramCreateWithoutExternalAuditsInput, AuditProgramUncheckedCreateWithoutExternalAuditsInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutExternalAuditsInput
    connect?: AuditProgramWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutExternalAuditsNestedInput = {
    create?: XOR<TenantCreateWithoutExternalAuditsInput, TenantUncheckedCreateWithoutExternalAuditsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExternalAuditsInput
    upsert?: TenantUpsertWithoutExternalAuditsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutExternalAuditsInput, TenantUpdateWithoutExternalAuditsInput>, TenantUncheckedUpdateWithoutExternalAuditsInput>
  }

  export type AuditProgramUpdateOneWithoutExternalAuditsNestedInput = {
    create?: XOR<AuditProgramCreateWithoutExternalAuditsInput, AuditProgramUncheckedCreateWithoutExternalAuditsInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutExternalAuditsInput
    upsert?: AuditProgramUpsertWithoutExternalAuditsInput
    disconnect?: AuditProgramWhereInput | boolean
    delete?: AuditProgramWhereInput | boolean
    connect?: AuditProgramWhereUniqueInput
    update?: XOR<XOR<AuditProgramUpdateToOneWithWhereWithoutExternalAuditsInput, AuditProgramUpdateWithoutExternalAuditsInput>, AuditProgramUncheckedUpdateWithoutExternalAuditsInput>
  }

  export type TenantCreateNestedOneWithoutAuditProgramsInput = {
    create?: XOR<TenantCreateWithoutAuditProgramsInput, TenantUncheckedCreateWithoutAuditProgramsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditProgramsInput
    connect?: TenantWhereUniqueInput
  }

  export type AuditProgramCreateNestedOneWithoutDerivativesInput = {
    create?: XOR<AuditProgramCreateWithoutDerivativesInput, AuditProgramUncheckedCreateWithoutDerivativesInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutDerivativesInput
    connect?: AuditProgramWhereUniqueInput
  }

  export type AuditProgramCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AuditProgramCreateWithoutTemplateInput, AuditProgramUncheckedCreateWithoutTemplateInput> | AuditProgramCreateWithoutTemplateInput[] | AuditProgramUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTemplateInput | AuditProgramCreateOrConnectWithoutTemplateInput[]
    createMany?: AuditProgramCreateManyTemplateInputEnvelope
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
  }

  export type AuditChecklistCreateNestedManyWithoutAuditProgramInput = {
    create?: XOR<AuditChecklistCreateWithoutAuditProgramInput, AuditChecklistUncheckedCreateWithoutAuditProgramInput> | AuditChecklistCreateWithoutAuditProgramInput[] | AuditChecklistUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: AuditChecklistCreateOrConnectWithoutAuditProgramInput | AuditChecklistCreateOrConnectWithoutAuditProgramInput[]
    createMany?: AuditChecklistCreateManyAuditProgramInputEnvelope
    connect?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
  }

  export type InternalAuditCreateNestedManyWithoutAuditProgramInput = {
    create?: XOR<InternalAuditCreateWithoutAuditProgramInput, InternalAuditUncheckedCreateWithoutAuditProgramInput> | InternalAuditCreateWithoutAuditProgramInput[] | InternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutAuditProgramInput | InternalAuditCreateOrConnectWithoutAuditProgramInput[]
    createMany?: InternalAuditCreateManyAuditProgramInputEnvelope
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
  }

  export type ExternalAuditCreateNestedManyWithoutAuditProgramInput = {
    create?: XOR<ExternalAuditCreateWithoutAuditProgramInput, ExternalAuditUncheckedCreateWithoutAuditProgramInput> | ExternalAuditCreateWithoutAuditProgramInput[] | ExternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutAuditProgramInput | ExternalAuditCreateOrConnectWithoutAuditProgramInput[]
    createMany?: ExternalAuditCreateManyAuditProgramInputEnvelope
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
  }

  export type AuditProgramUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AuditProgramCreateWithoutTemplateInput, AuditProgramUncheckedCreateWithoutTemplateInput> | AuditProgramCreateWithoutTemplateInput[] | AuditProgramUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTemplateInput | AuditProgramCreateOrConnectWithoutTemplateInput[]
    createMany?: AuditProgramCreateManyTemplateInputEnvelope
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
  }

  export type AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput = {
    create?: XOR<AuditChecklistCreateWithoutAuditProgramInput, AuditChecklistUncheckedCreateWithoutAuditProgramInput> | AuditChecklistCreateWithoutAuditProgramInput[] | AuditChecklistUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: AuditChecklistCreateOrConnectWithoutAuditProgramInput | AuditChecklistCreateOrConnectWithoutAuditProgramInput[]
    createMany?: AuditChecklistCreateManyAuditProgramInputEnvelope
    connect?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
  }

  export type InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput = {
    create?: XOR<InternalAuditCreateWithoutAuditProgramInput, InternalAuditUncheckedCreateWithoutAuditProgramInput> | InternalAuditCreateWithoutAuditProgramInput[] | InternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutAuditProgramInput | InternalAuditCreateOrConnectWithoutAuditProgramInput[]
    createMany?: InternalAuditCreateManyAuditProgramInputEnvelope
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
  }

  export type ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput = {
    create?: XOR<ExternalAuditCreateWithoutAuditProgramInput, ExternalAuditUncheckedCreateWithoutAuditProgramInput> | ExternalAuditCreateWithoutAuditProgramInput[] | ExternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutAuditProgramInput | ExternalAuditCreateOrConnectWithoutAuditProgramInput[]
    createMany?: ExternalAuditCreateManyAuditProgramInputEnvelope
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutAuditProgramsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditProgramsInput, TenantUncheckedCreateWithoutAuditProgramsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditProgramsInput
    upsert?: TenantUpsertWithoutAuditProgramsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditProgramsInput, TenantUpdateWithoutAuditProgramsInput>, TenantUncheckedUpdateWithoutAuditProgramsInput>
  }

  export type AuditProgramUpdateOneWithoutDerivativesNestedInput = {
    create?: XOR<AuditProgramCreateWithoutDerivativesInput, AuditProgramUncheckedCreateWithoutDerivativesInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutDerivativesInput
    upsert?: AuditProgramUpsertWithoutDerivativesInput
    disconnect?: AuditProgramWhereInput | boolean
    delete?: AuditProgramWhereInput | boolean
    connect?: AuditProgramWhereUniqueInput
    update?: XOR<XOR<AuditProgramUpdateToOneWithWhereWithoutDerivativesInput, AuditProgramUpdateWithoutDerivativesInput>, AuditProgramUncheckedUpdateWithoutDerivativesInput>
  }

  export type AuditProgramUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AuditProgramCreateWithoutTemplateInput, AuditProgramUncheckedCreateWithoutTemplateInput> | AuditProgramCreateWithoutTemplateInput[] | AuditProgramUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTemplateInput | AuditProgramCreateOrConnectWithoutTemplateInput[]
    upsert?: AuditProgramUpsertWithWhereUniqueWithoutTemplateInput | AuditProgramUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AuditProgramCreateManyTemplateInputEnvelope
    set?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    disconnect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    delete?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    update?: AuditProgramUpdateWithWhereUniqueWithoutTemplateInput | AuditProgramUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AuditProgramUpdateManyWithWhereWithoutTemplateInput | AuditProgramUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AuditProgramScalarWhereInput | AuditProgramScalarWhereInput[]
  }

  export type AuditChecklistUpdateManyWithoutAuditProgramNestedInput = {
    create?: XOR<AuditChecklistCreateWithoutAuditProgramInput, AuditChecklistUncheckedCreateWithoutAuditProgramInput> | AuditChecklistCreateWithoutAuditProgramInput[] | AuditChecklistUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: AuditChecklistCreateOrConnectWithoutAuditProgramInput | AuditChecklistCreateOrConnectWithoutAuditProgramInput[]
    upsert?: AuditChecklistUpsertWithWhereUniqueWithoutAuditProgramInput | AuditChecklistUpsertWithWhereUniqueWithoutAuditProgramInput[]
    createMany?: AuditChecklistCreateManyAuditProgramInputEnvelope
    set?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    disconnect?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    delete?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    connect?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    update?: AuditChecklistUpdateWithWhereUniqueWithoutAuditProgramInput | AuditChecklistUpdateWithWhereUniqueWithoutAuditProgramInput[]
    updateMany?: AuditChecklistUpdateManyWithWhereWithoutAuditProgramInput | AuditChecklistUpdateManyWithWhereWithoutAuditProgramInput[]
    deleteMany?: AuditChecklistScalarWhereInput | AuditChecklistScalarWhereInput[]
  }

  export type InternalAuditUpdateManyWithoutAuditProgramNestedInput = {
    create?: XOR<InternalAuditCreateWithoutAuditProgramInput, InternalAuditUncheckedCreateWithoutAuditProgramInput> | InternalAuditCreateWithoutAuditProgramInput[] | InternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutAuditProgramInput | InternalAuditCreateOrConnectWithoutAuditProgramInput[]
    upsert?: InternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput | InternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput[]
    createMany?: InternalAuditCreateManyAuditProgramInputEnvelope
    set?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    disconnect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    delete?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    update?: InternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput | InternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput[]
    updateMany?: InternalAuditUpdateManyWithWhereWithoutAuditProgramInput | InternalAuditUpdateManyWithWhereWithoutAuditProgramInput[]
    deleteMany?: InternalAuditScalarWhereInput | InternalAuditScalarWhereInput[]
  }

  export type ExternalAuditUpdateManyWithoutAuditProgramNestedInput = {
    create?: XOR<ExternalAuditCreateWithoutAuditProgramInput, ExternalAuditUncheckedCreateWithoutAuditProgramInput> | ExternalAuditCreateWithoutAuditProgramInput[] | ExternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutAuditProgramInput | ExternalAuditCreateOrConnectWithoutAuditProgramInput[]
    upsert?: ExternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput | ExternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput[]
    createMany?: ExternalAuditCreateManyAuditProgramInputEnvelope
    set?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    disconnect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    delete?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    update?: ExternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput | ExternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput[]
    updateMany?: ExternalAuditUpdateManyWithWhereWithoutAuditProgramInput | ExternalAuditUpdateManyWithWhereWithoutAuditProgramInput[]
    deleteMany?: ExternalAuditScalarWhereInput | ExternalAuditScalarWhereInput[]
  }

  export type AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AuditProgramCreateWithoutTemplateInput, AuditProgramUncheckedCreateWithoutTemplateInput> | AuditProgramCreateWithoutTemplateInput[] | AuditProgramUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AuditProgramCreateOrConnectWithoutTemplateInput | AuditProgramCreateOrConnectWithoutTemplateInput[]
    upsert?: AuditProgramUpsertWithWhereUniqueWithoutTemplateInput | AuditProgramUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AuditProgramCreateManyTemplateInputEnvelope
    set?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    disconnect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    delete?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    connect?: AuditProgramWhereUniqueInput | AuditProgramWhereUniqueInput[]
    update?: AuditProgramUpdateWithWhereUniqueWithoutTemplateInput | AuditProgramUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AuditProgramUpdateManyWithWhereWithoutTemplateInput | AuditProgramUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AuditProgramScalarWhereInput | AuditProgramScalarWhereInput[]
  }

  export type AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput = {
    create?: XOR<AuditChecklistCreateWithoutAuditProgramInput, AuditChecklistUncheckedCreateWithoutAuditProgramInput> | AuditChecklistCreateWithoutAuditProgramInput[] | AuditChecklistUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: AuditChecklistCreateOrConnectWithoutAuditProgramInput | AuditChecklistCreateOrConnectWithoutAuditProgramInput[]
    upsert?: AuditChecklistUpsertWithWhereUniqueWithoutAuditProgramInput | AuditChecklistUpsertWithWhereUniqueWithoutAuditProgramInput[]
    createMany?: AuditChecklistCreateManyAuditProgramInputEnvelope
    set?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    disconnect?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    delete?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    connect?: AuditChecklistWhereUniqueInput | AuditChecklistWhereUniqueInput[]
    update?: AuditChecklistUpdateWithWhereUniqueWithoutAuditProgramInput | AuditChecklistUpdateWithWhereUniqueWithoutAuditProgramInput[]
    updateMany?: AuditChecklistUpdateManyWithWhereWithoutAuditProgramInput | AuditChecklistUpdateManyWithWhereWithoutAuditProgramInput[]
    deleteMany?: AuditChecklistScalarWhereInput | AuditChecklistScalarWhereInput[]
  }

  export type InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput = {
    create?: XOR<InternalAuditCreateWithoutAuditProgramInput, InternalAuditUncheckedCreateWithoutAuditProgramInput> | InternalAuditCreateWithoutAuditProgramInput[] | InternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: InternalAuditCreateOrConnectWithoutAuditProgramInput | InternalAuditCreateOrConnectWithoutAuditProgramInput[]
    upsert?: InternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput | InternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput[]
    createMany?: InternalAuditCreateManyAuditProgramInputEnvelope
    set?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    disconnect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    delete?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    connect?: InternalAuditWhereUniqueInput | InternalAuditWhereUniqueInput[]
    update?: InternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput | InternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput[]
    updateMany?: InternalAuditUpdateManyWithWhereWithoutAuditProgramInput | InternalAuditUpdateManyWithWhereWithoutAuditProgramInput[]
    deleteMany?: InternalAuditScalarWhereInput | InternalAuditScalarWhereInput[]
  }

  export type ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput = {
    create?: XOR<ExternalAuditCreateWithoutAuditProgramInput, ExternalAuditUncheckedCreateWithoutAuditProgramInput> | ExternalAuditCreateWithoutAuditProgramInput[] | ExternalAuditUncheckedCreateWithoutAuditProgramInput[]
    connectOrCreate?: ExternalAuditCreateOrConnectWithoutAuditProgramInput | ExternalAuditCreateOrConnectWithoutAuditProgramInput[]
    upsert?: ExternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput | ExternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput[]
    createMany?: ExternalAuditCreateManyAuditProgramInputEnvelope
    set?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    disconnect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    delete?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    connect?: ExternalAuditWhereUniqueInput | ExternalAuditWhereUniqueInput[]
    update?: ExternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput | ExternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput[]
    updateMany?: ExternalAuditUpdateManyWithWhereWithoutAuditProgramInput | ExternalAuditUpdateManyWithWhereWithoutAuditProgramInput[]
    deleteMany?: ExternalAuditScalarWhereInput | ExternalAuditScalarWhereInput[]
  }

  export type AuditProgramCreateNestedOneWithoutChecklistsInput = {
    create?: XOR<AuditProgramCreateWithoutChecklistsInput, AuditProgramUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutChecklistsInput
    connect?: AuditProgramWhereUniqueInput
  }

  export type AuditProgramUpdateOneRequiredWithoutChecklistsNestedInput = {
    create?: XOR<AuditProgramCreateWithoutChecklistsInput, AuditProgramUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: AuditProgramCreateOrConnectWithoutChecklistsInput
    upsert?: AuditProgramUpsertWithoutChecklistsInput
    connect?: AuditProgramWhereUniqueInput
    update?: XOR<XOR<AuditProgramUpdateToOneWithWhereWithoutChecklistsInput, AuditProgramUpdateWithoutChecklistsInput>, AuditProgramUncheckedUpdateWithoutChecklistsInput>
  }

  export type TenantCreateNestedOneWithoutActionItemsInput = {
    create?: XOR<TenantCreateWithoutActionItemsInput, TenantUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutActionItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type RootCauseAnalysisCreateNestedOneWithoutActionItemInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutActionItemInput, RootCauseAnalysisUncheckedCreateWithoutActionItemInput>
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutActionItemInput
    connect?: RootCauseAnalysisWhereUniqueInput
  }

  export type RootCauseAnalysisUncheckedCreateNestedOneWithoutActionItemInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutActionItemInput, RootCauseAnalysisUncheckedCreateWithoutActionItemInput>
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutActionItemInput
    connect?: RootCauseAnalysisWhereUniqueInput
  }

  export type EnumActionOriginFieldUpdateOperationsInput = {
    set?: $Enums.ActionOrigin
  }

  export type NullableEnumConformidadeFieldUpdateOperationsInput = {
    set?: $Enums.Conformidade | null
  }

  export type EnumActionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActionStatus
  }

  export type EnumImpactFieldUpdateOperationsInput = {
    set?: $Enums.Impact
  }

  export type TenantUpdateOneRequiredWithoutActionItemsNestedInput = {
    create?: XOR<TenantCreateWithoutActionItemsInput, TenantUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutActionItemsInput
    upsert?: TenantUpsertWithoutActionItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutActionItemsInput, TenantUpdateWithoutActionItemsInput>, TenantUncheckedUpdateWithoutActionItemsInput>
  }

  export type RootCauseAnalysisUpdateOneWithoutActionItemNestedInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutActionItemInput, RootCauseAnalysisUncheckedCreateWithoutActionItemInput>
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutActionItemInput
    upsert?: RootCauseAnalysisUpsertWithoutActionItemInput
    disconnect?: RootCauseAnalysisWhereInput | boolean
    delete?: RootCauseAnalysisWhereInput | boolean
    connect?: RootCauseAnalysisWhereUniqueInput
    update?: XOR<XOR<RootCauseAnalysisUpdateToOneWithWhereWithoutActionItemInput, RootCauseAnalysisUpdateWithoutActionItemInput>, RootCauseAnalysisUncheckedUpdateWithoutActionItemInput>
  }

  export type RootCauseAnalysisUncheckedUpdateOneWithoutActionItemNestedInput = {
    create?: XOR<RootCauseAnalysisCreateWithoutActionItemInput, RootCauseAnalysisUncheckedCreateWithoutActionItemInput>
    connectOrCreate?: RootCauseAnalysisCreateOrConnectWithoutActionItemInput
    upsert?: RootCauseAnalysisUpsertWithoutActionItemInput
    disconnect?: RootCauseAnalysisWhereInput | boolean
    delete?: RootCauseAnalysisWhereInput | boolean
    connect?: RootCauseAnalysisWhereUniqueInput
    update?: XOR<XOR<RootCauseAnalysisUpdateToOneWithWhereWithoutActionItemInput, RootCauseAnalysisUpdateWithoutActionItemInput>, RootCauseAnalysisUncheckedUpdateWithoutActionItemInput>
  }

  export type ActionItemCreateNestedOneWithoutRootCauseAnalysisInput = {
    create?: XOR<ActionItemCreateWithoutRootCauseAnalysisInput, ActionItemUncheckedCreateWithoutRootCauseAnalysisInput>
    connectOrCreate?: ActionItemCreateOrConnectWithoutRootCauseAnalysisInput
    connect?: ActionItemWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutRootCauseAnalysesInput = {
    create?: XOR<TenantCreateWithoutRootCauseAnalysesInput, TenantUncheckedCreateWithoutRootCauseAnalysesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRootCauseAnalysesInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumRootCauseAnalysisTypeFieldUpdateOperationsInput = {
    set?: $Enums.RootCauseAnalysisType
  }

  export type ActionItemUpdateOneRequiredWithoutRootCauseAnalysisNestedInput = {
    create?: XOR<ActionItemCreateWithoutRootCauseAnalysisInput, ActionItemUncheckedCreateWithoutRootCauseAnalysisInput>
    connectOrCreate?: ActionItemCreateOrConnectWithoutRootCauseAnalysisInput
    upsert?: ActionItemUpsertWithoutRootCauseAnalysisInput
    connect?: ActionItemWhereUniqueInput
    update?: XOR<XOR<ActionItemUpdateToOneWithWhereWithoutRootCauseAnalysisInput, ActionItemUpdateWithoutRootCauseAnalysisInput>, ActionItemUncheckedUpdateWithoutRootCauseAnalysisInput>
  }

  export type TenantUpdateOneRequiredWithoutRootCauseAnalysesNestedInput = {
    create?: XOR<TenantCreateWithoutRootCauseAnalysesInput, TenantUncheckedCreateWithoutRootCauseAnalysesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRootCauseAnalysesInput
    upsert?: TenantUpsertWithoutRootCauseAnalysesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRootCauseAnalysesInput, TenantUpdateWithoutRootCauseAnalysesInput>, TenantUncheckedUpdateWithoutRootCauseAnalysesInput>
  }

  export type TenantCreateNestedOneWithoutOccurrencesInput = {
    create?: XOR<TenantCreateWithoutOccurrencesInput, TenantUncheckedCreateWithoutOccurrencesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOccurrencesInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumOccurrenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.OccurrenceType
  }

  export type EnumOccurrenceSeverityFieldUpdateOperationsInput = {
    set?: $Enums.OccurrenceSeverity
  }

  export type EnumOccurrenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.OccurrenceStatus
  }

  export type TenantUpdateOneRequiredWithoutOccurrencesNestedInput = {
    create?: XOR<TenantCreateWithoutOccurrencesInput, TenantUncheckedCreateWithoutOccurrencesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOccurrencesInput
    upsert?: TenantUpsertWithoutOccurrencesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOccurrencesInput, TenantUpdateWithoutOccurrencesInput>, TenantUncheckedUpdateWithoutOccurrencesInput>
  }

  export type TenantCreateNestedOneWithoutSectorsInput = {
    create?: XOR<TenantCreateWithoutSectorsInput, TenantUncheckedCreateWithoutSectorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSectorsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutSectorsNestedInput = {
    create?: XOR<TenantCreateWithoutSectorsInput, TenantUncheckedCreateWithoutSectorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSectorsInput
    upsert?: TenantUpsertWithoutSectorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSectorsInput, TenantUpdateWithoutSectorsInput>, TenantUncheckedUpdateWithoutSectorsInput>
  }

  export type TenantCreateNestedOneWithoutImportLogsInput = {
    create?: XOR<TenantCreateWithoutImportLogsInput, TenantUncheckedCreateWithoutImportLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutImportLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportStatus
  }

  export type TenantUpdateOneRequiredWithoutImportLogsNestedInput = {
    create?: XOR<TenantCreateWithoutImportLogsInput, TenantUncheckedCreateWithoutImportLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutImportLogsInput
    upsert?: TenantUpsertWithoutImportLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutImportLogsInput, TenantUpdateWithoutImportLogsInput>, TenantUncheckedUpdateWithoutImportLogsInput>
  }

  export type TenantCreateNestedOneWithoutAuditTrailsInput = {
    create?: XOR<TenantCreateWithoutAuditTrailsInput, TenantUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditTrailsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditTrailsInput = {
    create?: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrailsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type TenantUpdateOneRequiredWithoutAuditTrailsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditTrailsInput, TenantUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditTrailsInput
    upsert?: TenantUpsertWithoutAuditTrailsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditTrailsInput, TenantUpdateWithoutAuditTrailsInput>, TenantUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type UserUpdateOneWithoutAuditTrailsNestedInput = {
    create?: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrailsInput
    upsert?: UserUpsertWithoutAuditTrailsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditTrailsInput, UserUpdateWithoutAuditTrailsInput>, UserUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type TenantCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TenantCreateWithoutAttachmentsInput, TenantUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAttachmentsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TenantCreateWithoutAttachmentsInput, TenantUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAttachmentsInput
    upsert?: TenantUpsertWithoutAttachmentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAttachmentsInput, TenantUpdateWithoutAttachmentsInput>, TenantUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentsInput
    upsert?: UserUpsertWithoutAttachmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttachmentsInput, UserUpdateWithoutAttachmentsInput>, UserUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TenantCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TenantCreateWithoutCommentsInput, TenantUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCommentsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TenantCreateWithoutCommentsInput, TenantUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCommentsInput
    upsert?: TenantUpsertWithoutCommentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCommentsInput, TenantUpdateWithoutCommentsInput>, TenantUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type TenantCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<TenantCreateWithoutApprovalsInput, TenantUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutApprovalsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalRequestsInput = {
    create?: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalApprovalsInput = {
    create?: XOR<UserCreateWithoutApprovalApprovalsInput, UserUncheckedCreateWithoutApprovalApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type TenantUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<TenantCreateWithoutApprovalsInput, TenantUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutApprovalsInput
    upsert?: TenantUpsertWithoutApprovalsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutApprovalsInput, TenantUpdateWithoutApprovalsInput>, TenantUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalRequestsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalRequestsInput
    upsert?: UserUpsertWithoutApprovalRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalRequestsInput, UserUpdateWithoutApprovalRequestsInput>, UserUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type UserUpdateOneWithoutApprovalApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalApprovalsInput, UserUncheckedCreateWithoutApprovalApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalApprovalsInput
    upsert?: UserUpsertWithoutApprovalApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalApprovalsInput, UserUpdateWithoutApprovalApprovalsInput>, UserUncheckedUpdateWithoutApprovalApprovalsInput>
  }

  export type TenantCreateNestedOneWithoutWorkflowDefinitionsInput = {
    create?: XOR<TenantCreateWithoutWorkflowDefinitionsInput, TenantUncheckedCreateWithoutWorkflowDefinitionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowDefinitionsInput
    connect?: TenantWhereUniqueInput
  }

  export type WorkflowStepCreateNestedManyWithoutWorkflowDefinitionInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowStepCreateWithoutWorkflowDefinitionInput[] | WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowStepCreateManyWorkflowDefinitionInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedManyWithoutWorkflowDefinitionInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowInstanceCreateWithoutWorkflowDefinitionInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowDefinitionInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type WorkflowStepUncheckedCreateNestedManyWithoutWorkflowDefinitionInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowStepCreateWithoutWorkflowDefinitionInput[] | WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowStepCreateManyWorkflowDefinitionInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowDefinitionInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowInstanceCreateWithoutWorkflowDefinitionInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowDefinitionInputEnvelope
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutWorkflowDefinitionsNestedInput = {
    create?: XOR<TenantCreateWithoutWorkflowDefinitionsInput, TenantUncheckedCreateWithoutWorkflowDefinitionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowDefinitionsInput
    upsert?: TenantUpsertWithoutWorkflowDefinitionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWorkflowDefinitionsInput, TenantUpdateWithoutWorkflowDefinitionsInput>, TenantUncheckedUpdateWithoutWorkflowDefinitionsInput>
  }

  export type WorkflowStepUpdateManyWithoutWorkflowDefinitionNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowStepCreateWithoutWorkflowDefinitionInput[] | WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowStepUpsertWithWhereUniqueWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowStepCreateManyWorkflowDefinitionInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowStepUpdateWithWhereUniqueWithoutWorkflowDefinitionInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutWorkflowDefinitionInput | WorkflowStepUpdateManyWithWhereWithoutWorkflowDefinitionInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateManyWithoutWorkflowDefinitionNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowInstanceCreateWithoutWorkflowDefinitionInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowDefinitionInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowDefinitionInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutWorkflowDefinitionInput | WorkflowInstanceUpdateManyWithWhereWithoutWorkflowDefinitionInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowStepUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowStepCreateWithoutWorkflowDefinitionInput[] | WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowStepUpsertWithWhereUniqueWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowStepCreateManyWorkflowDefinitionInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowStepUpdateWithWhereUniqueWithoutWorkflowDefinitionInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutWorkflowDefinitionInput | WorkflowStepUpdateManyWithWhereWithoutWorkflowDefinitionInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput> | WorkflowInstanceCreateWithoutWorkflowDefinitionInput[] | WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput[]
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput | WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput[]
    upsert?: WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowDefinitionInput[]
    createMany?: WorkflowInstanceCreateManyWorkflowDefinitionInputEnvelope
    set?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    disconnect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    delete?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    connect?: WorkflowInstanceWhereUniqueInput | WorkflowInstanceWhereUniqueInput[]
    update?: WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowDefinitionInput | WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowDefinitionInput[]
    updateMany?: WorkflowInstanceUpdateManyWithWhereWithoutWorkflowDefinitionInput | WorkflowInstanceUpdateManyWithWhereWithoutWorkflowDefinitionInput[]
    deleteMany?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
  }

  export type WorkflowDefinitionCreateNestedOneWithoutStepsInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutStepsInput
    connect?: WorkflowDefinitionWhereUniqueInput
  }

  export type EnumWorkflowStepTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStepType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkflowDefinitionUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutStepsInput
    upsert?: WorkflowDefinitionUpsertWithoutStepsInput
    connect?: WorkflowDefinitionWhereUniqueInput
    update?: XOR<XOR<WorkflowDefinitionUpdateToOneWithWhereWithoutStepsInput, WorkflowDefinitionUpdateWithoutStepsInput>, WorkflowDefinitionUncheckedUpdateWithoutStepsInput>
  }

  export type TenantCreateNestedOneWithoutWorkflowInstancesInput = {
    create?: XOR<TenantCreateWithoutWorkflowInstancesInput, TenantUncheckedCreateWithoutWorkflowInstancesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowInstancesInput
    connect?: TenantWhereUniqueInput
  }

  export type WorkflowDefinitionCreateNestedOneWithoutInstancesInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutInstancesInput
    connect?: WorkflowDefinitionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkflowInstancesInput = {
    create?: XOR<UserCreateWithoutWorkflowInstancesInput, UserUncheckedCreateWithoutWorkflowInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowInstancesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkflowCancelledInput = {
    create?: XOR<UserCreateWithoutWorkflowCancelledInput, UserUncheckedCreateWithoutWorkflowCancelledInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowCancelledInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput> | WorkflowStepExecutionCreateWithoutWorkflowInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyWorkflowInstanceInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutWorkflowInstanceInput = {
    create?: XOR<DocumentCreateWithoutWorkflowInstanceInput, DocumentUncheckedCreateWithoutWorkflowInstanceInput> | DocumentCreateWithoutWorkflowInstanceInput[] | DocumentUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkflowInstanceInput | DocumentCreateOrConnectWithoutWorkflowInstanceInput[]
    createMany?: DocumentCreateManyWorkflowInstanceInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput> | WorkflowStepExecutionCreateWithoutWorkflowInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyWorkflowInstanceInputEnvelope
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput = {
    create?: XOR<DocumentCreateWithoutWorkflowInstanceInput, DocumentUncheckedCreateWithoutWorkflowInstanceInput> | DocumentCreateWithoutWorkflowInstanceInput[] | DocumentUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkflowInstanceInput | DocumentCreateOrConnectWithoutWorkflowInstanceInput[]
    createMany?: DocumentCreateManyWorkflowInstanceInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput = {
    create?: XOR<TenantCreateWithoutWorkflowInstancesInput, TenantUncheckedCreateWithoutWorkflowInstancesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWorkflowInstancesInput
    upsert?: TenantUpsertWithoutWorkflowInstancesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWorkflowInstancesInput, TenantUpdateWithoutWorkflowInstancesInput>, TenantUncheckedUpdateWithoutWorkflowInstancesInput>
  }

  export type WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: WorkflowDefinitionCreateOrConnectWithoutInstancesInput
    upsert?: WorkflowDefinitionUpsertWithoutInstancesInput
    connect?: WorkflowDefinitionWhereUniqueInput
    update?: XOR<XOR<WorkflowDefinitionUpdateToOneWithWhereWithoutInstancesInput, WorkflowDefinitionUpdateWithoutInstancesInput>, WorkflowDefinitionUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowInstancesInput, UserUncheckedCreateWithoutWorkflowInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowInstancesInput
    upsert?: UserUpsertWithoutWorkflowInstancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowInstancesInput, UserUpdateWithoutWorkflowInstancesInput>, UserUncheckedUpdateWithoutWorkflowInstancesInput>
  }

  export type UserUpdateOneWithoutWorkflowCancelledNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowCancelledInput, UserUncheckedCreateWithoutWorkflowCancelledInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowCancelledInput
    upsert?: UserUpsertWithoutWorkflowCancelledInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowCancelledInput, UserUpdateWithoutWorkflowCancelledInput>, UserUncheckedUpdateWithoutWorkflowCancelledInput>
  }

  export type WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput> | WorkflowStepExecutionCreateWithoutWorkflowInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutWorkflowInstanceInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutWorkflowInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyWorkflowInstanceInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutWorkflowInstanceInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutWorkflowInstanceInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutWorkflowInstanceInput | WorkflowStepExecutionUpdateManyWithWhereWithoutWorkflowInstanceInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutWorkflowInstanceNestedInput = {
    create?: XOR<DocumentCreateWithoutWorkflowInstanceInput, DocumentUncheckedCreateWithoutWorkflowInstanceInput> | DocumentCreateWithoutWorkflowInstanceInput[] | DocumentUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkflowInstanceInput | DocumentCreateOrConnectWithoutWorkflowInstanceInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutWorkflowInstanceInput | DocumentUpsertWithWhereUniqueWithoutWorkflowInstanceInput[]
    createMany?: DocumentCreateManyWorkflowInstanceInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutWorkflowInstanceInput | DocumentUpdateWithWhereUniqueWithoutWorkflowInstanceInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutWorkflowInstanceInput | DocumentUpdateManyWithWhereWithoutWorkflowInstanceInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput = {
    create?: XOR<WorkflowStepExecutionCreateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput> | WorkflowStepExecutionCreateWithoutWorkflowInstanceInput[] | WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput | WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput[]
    upsert?: WorkflowStepExecutionUpsertWithWhereUniqueWithoutWorkflowInstanceInput | WorkflowStepExecutionUpsertWithWhereUniqueWithoutWorkflowInstanceInput[]
    createMany?: WorkflowStepExecutionCreateManyWorkflowInstanceInputEnvelope
    set?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    disconnect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    delete?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    connect?: WorkflowStepExecutionWhereUniqueInput | WorkflowStepExecutionWhereUniqueInput[]
    update?: WorkflowStepExecutionUpdateWithWhereUniqueWithoutWorkflowInstanceInput | WorkflowStepExecutionUpdateWithWhereUniqueWithoutWorkflowInstanceInput[]
    updateMany?: WorkflowStepExecutionUpdateManyWithWhereWithoutWorkflowInstanceInput | WorkflowStepExecutionUpdateManyWithWhereWithoutWorkflowInstanceInput[]
    deleteMany?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput = {
    create?: XOR<DocumentCreateWithoutWorkflowInstanceInput, DocumentUncheckedCreateWithoutWorkflowInstanceInput> | DocumentCreateWithoutWorkflowInstanceInput[] | DocumentUncheckedCreateWithoutWorkflowInstanceInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutWorkflowInstanceInput | DocumentCreateOrConnectWithoutWorkflowInstanceInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutWorkflowInstanceInput | DocumentUpsertWithWhereUniqueWithoutWorkflowInstanceInput[]
    createMany?: DocumentCreateManyWorkflowInstanceInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutWorkflowInstanceInput | DocumentUpdateWithWhereUniqueWithoutWorkflowInstanceInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutWorkflowInstanceInput | DocumentUpdateManyWithWhereWithoutWorkflowInstanceInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type WorkflowInstanceCreateNestedOneWithoutStepExecutionsInput = {
    create?: XOR<WorkflowInstanceCreateWithoutStepExecutionsInput, WorkflowInstanceUncheckedCreateWithoutStepExecutionsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutStepExecutionsInput
    connect?: WorkflowInstanceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkflowStepExecutionsInput = {
    create?: XOR<UserCreateWithoutWorkflowStepExecutionsInput, UserUncheckedCreateWithoutWorkflowStepExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowStepExecutionsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkflowInstanceUpdateOneRequiredWithoutStepExecutionsNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutStepExecutionsInput, WorkflowInstanceUncheckedCreateWithoutStepExecutionsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutStepExecutionsInput
    upsert?: WorkflowInstanceUpsertWithoutStepExecutionsInput
    connect?: WorkflowInstanceWhereUniqueInput
    update?: XOR<XOR<WorkflowInstanceUpdateToOneWithWhereWithoutStepExecutionsInput, WorkflowInstanceUpdateWithoutStepExecutionsInput>, WorkflowInstanceUncheckedUpdateWithoutStepExecutionsInput>
  }

  export type UserUpdateOneWithoutWorkflowStepExecutionsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowStepExecutionsInput, UserUncheckedCreateWithoutWorkflowStepExecutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowStepExecutionsInput
    upsert?: UserUpsertWithoutWorkflowStepExecutionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowStepExecutionsInput, UserUpdateWithoutWorkflowStepExecutionsInput>, UserUncheckedUpdateWithoutWorkflowStepExecutionsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type TenantCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedDocumentsInput = {
    create?: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentVersionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput> | DocumentVersionCreateWithoutDocumentInput[] | DocumentVersionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentInput | DocumentVersionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentTagCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentInput, DocumentTagUncheckedCreateWithoutDocumentInput> | DocumentTagCreateWithoutDocumentInput[] | DocumentTagUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentInput | DocumentTagCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentTagCreateManyDocumentInputEnvelope
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type WorkflowInstanceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<WorkflowInstanceCreateWithoutDocumentsInput, WorkflowInstanceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutDocumentsInput
    connect?: WorkflowInstanceWhereUniqueInput
  }

  export type DocumentReadConfirmationCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutDocumentInput, DocumentReadConfirmationUncheckedCreateWithoutDocumentInput> | DocumentReadConfirmationCreateWithoutDocumentInput[] | DocumentReadConfirmationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutDocumentInput | DocumentReadConfirmationCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentReadConfirmationCreateManyDocumentInputEnvelope
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
  }

  export type DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput> | DocumentVersionCreateWithoutDocumentInput[] | DocumentVersionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentInput | DocumentVersionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentTagUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentInput, DocumentTagUncheckedCreateWithoutDocumentInput> | DocumentTagCreateWithoutDocumentInput[] | DocumentTagUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentInput | DocumentTagCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentTagCreateManyDocumentInputEnvelope
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutDocumentInput, DocumentReadConfirmationUncheckedCreateWithoutDocumentInput> | DocumentReadConfirmationCreateWithoutDocumentInput[] | DocumentReadConfirmationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutDocumentInput | DocumentReadConfirmationCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentReadConfirmationCreateManyDocumentInputEnvelope
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type EnumDocumentAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.DocumentAccessLevel
  }

  export type TenantUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentsInput
    upsert?: TenantUpsertWithoutDocumentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentsInput, TenantUpdateWithoutDocumentsInput>, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDocumentsInput
    upsert?: UserUpsertWithoutCreatedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedDocumentsInput, UserUpdateWithoutCreatedDocumentsInput>, UserUncheckedUpdateWithoutCreatedDocumentsInput>
  }

  export type DocumentVersionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput> | DocumentVersionCreateWithoutDocumentInput[] | DocumentVersionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentInput | DocumentVersionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput | DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput | DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutDocumentInput | DocumentVersionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentTagUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentInput, DocumentTagUncheckedCreateWithoutDocumentInput> | DocumentTagCreateWithoutDocumentInput[] | DocumentTagUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentInput | DocumentTagCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutDocumentInput | DocumentTagUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentTagCreateManyDocumentInputEnvelope
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutDocumentInput | DocumentTagUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutDocumentInput | DocumentTagUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type WorkflowInstanceUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<WorkflowInstanceCreateWithoutDocumentsInput, WorkflowInstanceUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: WorkflowInstanceCreateOrConnectWithoutDocumentsInput
    upsert?: WorkflowInstanceUpsertWithoutDocumentsInput
    disconnect?: WorkflowInstanceWhereInput | boolean
    delete?: WorkflowInstanceWhereInput | boolean
    connect?: WorkflowInstanceWhereUniqueInput
    update?: XOR<XOR<WorkflowInstanceUpdateToOneWithWhereWithoutDocumentsInput, WorkflowInstanceUpdateWithoutDocumentsInput>, WorkflowInstanceUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutDocumentInput, DocumentReadConfirmationUncheckedCreateWithoutDocumentInput> | DocumentReadConfirmationCreateWithoutDocumentInput[] | DocumentReadConfirmationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutDocumentInput | DocumentReadConfirmationCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentReadConfirmationUpsertWithWhereUniqueWithoutDocumentInput | DocumentReadConfirmationUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentReadConfirmationCreateManyDocumentInputEnvelope
    set?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    disconnect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    delete?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    update?: DocumentReadConfirmationUpdateWithWhereUniqueWithoutDocumentInput | DocumentReadConfirmationUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentReadConfirmationUpdateManyWithWhereWithoutDocumentInput | DocumentReadConfirmationUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
  }

  export type DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput> | DocumentVersionCreateWithoutDocumentInput[] | DocumentVersionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentInput | DocumentVersionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput | DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput | DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutDocumentInput | DocumentVersionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentInput, DocumentTagUncheckedCreateWithoutDocumentInput> | DocumentTagCreateWithoutDocumentInput[] | DocumentTagUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentInput | DocumentTagCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutDocumentInput | DocumentTagUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentTagCreateManyDocumentInputEnvelope
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutDocumentInput | DocumentTagUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutDocumentInput | DocumentTagUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentReadConfirmationCreateWithoutDocumentInput, DocumentReadConfirmationUncheckedCreateWithoutDocumentInput> | DocumentReadConfirmationCreateWithoutDocumentInput[] | DocumentReadConfirmationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentReadConfirmationCreateOrConnectWithoutDocumentInput | DocumentReadConfirmationCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentReadConfirmationUpsertWithWhereUniqueWithoutDocumentInput | DocumentReadConfirmationUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentReadConfirmationCreateManyDocumentInputEnvelope
    set?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    disconnect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    delete?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    connect?: DocumentReadConfirmationWhereUniqueInput | DocumentReadConfirmationWhereUniqueInput[]
    update?: DocumentReadConfirmationUpdateWithWhereUniqueWithoutDocumentInput | DocumentReadConfirmationUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentReadConfirmationUpdateManyWithWhereWithoutDocumentInput | DocumentReadConfirmationUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutVersionsInput = {
    create?: XOR<DocumentCreateWithoutVersionsInput, DocumentUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutVersionsInput
    connect?: DocumentWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutDocumentVersionsInput = {
    create?: XOR<TenantCreateWithoutDocumentVersionsInput, TenantUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentVersionsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedDocumentVersionsInput = {
    create?: XOR<UserCreateWithoutUpdatedDocumentVersionsInput, UserUncheckedCreateWithoutUpdatedDocumentVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedDocumentVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<DocumentCreateWithoutVersionsInput, DocumentUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutVersionsInput
    upsert?: DocumentUpsertWithoutVersionsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutVersionsInput, DocumentUpdateWithoutVersionsInput>, DocumentUncheckedUpdateWithoutVersionsInput>
  }

  export type TenantUpdateOneRequiredWithoutDocumentVersionsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentVersionsInput, TenantUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentVersionsInput
    upsert?: TenantUpsertWithoutDocumentVersionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentVersionsInput, TenantUpdateWithoutDocumentVersionsInput>, TenantUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type UserUpdateOneRequiredWithoutUpdatedDocumentVersionsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedDocumentVersionsInput, UserUncheckedCreateWithoutUpdatedDocumentVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedDocumentVersionsInput
    upsert?: UserUpsertWithoutUpdatedDocumentVersionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedDocumentVersionsInput, UserUpdateWithoutUpdatedDocumentVersionsInput>, UserUncheckedUpdateWithoutUpdatedDocumentVersionsInput>
  }

  export type TenantCreateNestedOneWithoutDocumentTagsInput = {
    create?: XOR<TenantCreateWithoutDocumentTagsInput, TenantUncheckedCreateWithoutDocumentTagsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentTagsInput
    connect?: TenantWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutTagsInput = {
    create?: XOR<DocumentCreateWithoutTagsInput, DocumentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutTagsInput
    connect?: DocumentWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutDocumentTagsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentTagsInput, TenantUncheckedCreateWithoutDocumentTagsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentTagsInput
    upsert?: TenantUpsertWithoutDocumentTagsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentTagsInput, TenantUpdateWithoutDocumentTagsInput>, TenantUncheckedUpdateWithoutDocumentTagsInput>
  }

  export type DocumentUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<DocumentCreateWithoutTagsInput, DocumentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutTagsInput
    upsert?: DocumentUpsertWithoutTagsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutTagsInput, DocumentUpdateWithoutTagsInput>, DocumentUncheckedUpdateWithoutTagsInput>
  }

  export type DocumentCreateNestedOneWithoutReadConfirmationsInput = {
    create?: XOR<DocumentCreateWithoutReadConfirmationsInput, DocumentUncheckedCreateWithoutReadConfirmationsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutReadConfirmationsInput
    connect?: DocumentWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutDocumentReadConfirmationsInput = {
    create?: XOR<TenantCreateWithoutDocumentReadConfirmationsInput, TenantUncheckedCreateWithoutDocumentReadConfirmationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentReadConfirmationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentReadConfirmationsInput = {
    create?: XOR<UserCreateWithoutDocumentReadConfirmationsInput, UserUncheckedCreateWithoutDocumentReadConfirmationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentReadConfirmationsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutReadConfirmationsNestedInput = {
    create?: XOR<DocumentCreateWithoutReadConfirmationsInput, DocumentUncheckedCreateWithoutReadConfirmationsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutReadConfirmationsInput
    upsert?: DocumentUpsertWithoutReadConfirmationsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutReadConfirmationsInput, DocumentUpdateWithoutReadConfirmationsInput>, DocumentUncheckedUpdateWithoutReadConfirmationsInput>
  }

  export type TenantUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput = {
    create?: XOR<TenantCreateWithoutDocumentReadConfirmationsInput, TenantUncheckedCreateWithoutDocumentReadConfirmationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDocumentReadConfirmationsInput
    upsert?: TenantUpsertWithoutDocumentReadConfirmationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDocumentReadConfirmationsInput, TenantUpdateWithoutDocumentReadConfirmationsInput>, TenantUncheckedUpdateWithoutDocumentReadConfirmationsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentReadConfirmationsInput, UserUncheckedCreateWithoutDocumentReadConfirmationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentReadConfirmationsInput
    upsert?: UserUpsertWithoutDocumentReadConfirmationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentReadConfirmationsInput, UserUpdateWithoutDocumentReadConfirmationsInput>, UserUncheckedUpdateWithoutDocumentReadConfirmationsInput>
  }

  export type TenantCreateNestedOneWithoutReportTemplatesInput = {
    create?: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReportTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedReportTemplatesInput = {
    create?: XOR<UserCreateWithoutCreatedReportTemplatesInput, UserUncheckedCreateWithoutCreatedReportTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedReportTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type ReportComponentCreateNestedManyWithoutReportTemplateInput = {
    create?: XOR<ReportComponentCreateWithoutReportTemplateInput, ReportComponentUncheckedCreateWithoutReportTemplateInput> | ReportComponentCreateWithoutReportTemplateInput[] | ReportComponentUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ReportComponentCreateOrConnectWithoutReportTemplateInput | ReportComponentCreateOrConnectWithoutReportTemplateInput[]
    createMany?: ReportComponentCreateManyReportTemplateInputEnvelope
    connect?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
  }

  export type ScheduledReportCreateNestedManyWithoutReportTemplateInput = {
    create?: XOR<ScheduledReportCreateWithoutReportTemplateInput, ScheduledReportUncheckedCreateWithoutReportTemplateInput> | ScheduledReportCreateWithoutReportTemplateInput[] | ScheduledReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutReportTemplateInput | ScheduledReportCreateOrConnectWithoutReportTemplateInput[]
    createMany?: ScheduledReportCreateManyReportTemplateInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type ReportComponentUncheckedCreateNestedManyWithoutReportTemplateInput = {
    create?: XOR<ReportComponentCreateWithoutReportTemplateInput, ReportComponentUncheckedCreateWithoutReportTemplateInput> | ReportComponentCreateWithoutReportTemplateInput[] | ReportComponentUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ReportComponentCreateOrConnectWithoutReportTemplateInput | ReportComponentCreateOrConnectWithoutReportTemplateInput[]
    createMany?: ReportComponentCreateManyReportTemplateInputEnvelope
    connect?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
  }

  export type ScheduledReportUncheckedCreateNestedManyWithoutReportTemplateInput = {
    create?: XOR<ScheduledReportCreateWithoutReportTemplateInput, ScheduledReportUncheckedCreateWithoutReportTemplateInput> | ScheduledReportCreateWithoutReportTemplateInput[] | ScheduledReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutReportTemplateInput | ScheduledReportCreateOrConnectWithoutReportTemplateInput[]
    createMany?: ScheduledReportCreateManyReportTemplateInputEnvelope
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type TenantUpdateOneRequiredWithoutReportTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReportTemplatesInput
    upsert?: TenantUpsertWithoutReportTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutReportTemplatesInput, TenantUpdateWithoutReportTemplatesInput>, TenantUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedReportTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedReportTemplatesInput, UserUncheckedCreateWithoutCreatedReportTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedReportTemplatesInput
    upsert?: UserUpsertWithoutCreatedReportTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedReportTemplatesInput, UserUpdateWithoutCreatedReportTemplatesInput>, UserUncheckedUpdateWithoutCreatedReportTemplatesInput>
  }

  export type ReportComponentUpdateManyWithoutReportTemplateNestedInput = {
    create?: XOR<ReportComponentCreateWithoutReportTemplateInput, ReportComponentUncheckedCreateWithoutReportTemplateInput> | ReportComponentCreateWithoutReportTemplateInput[] | ReportComponentUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ReportComponentCreateOrConnectWithoutReportTemplateInput | ReportComponentCreateOrConnectWithoutReportTemplateInput[]
    upsert?: ReportComponentUpsertWithWhereUniqueWithoutReportTemplateInput | ReportComponentUpsertWithWhereUniqueWithoutReportTemplateInput[]
    createMany?: ReportComponentCreateManyReportTemplateInputEnvelope
    set?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    disconnect?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    delete?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    connect?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    update?: ReportComponentUpdateWithWhereUniqueWithoutReportTemplateInput | ReportComponentUpdateWithWhereUniqueWithoutReportTemplateInput[]
    updateMany?: ReportComponentUpdateManyWithWhereWithoutReportTemplateInput | ReportComponentUpdateManyWithWhereWithoutReportTemplateInput[]
    deleteMany?: ReportComponentScalarWhereInput | ReportComponentScalarWhereInput[]
  }

  export type ScheduledReportUpdateManyWithoutReportTemplateNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutReportTemplateInput, ScheduledReportUncheckedCreateWithoutReportTemplateInput> | ScheduledReportCreateWithoutReportTemplateInput[] | ScheduledReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutReportTemplateInput | ScheduledReportCreateOrConnectWithoutReportTemplateInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutReportTemplateInput | ScheduledReportUpsertWithWhereUniqueWithoutReportTemplateInput[]
    createMany?: ScheduledReportCreateManyReportTemplateInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutReportTemplateInput | ScheduledReportUpdateWithWhereUniqueWithoutReportTemplateInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutReportTemplateInput | ScheduledReportUpdateManyWithWhereWithoutReportTemplateInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type ReportComponentUncheckedUpdateManyWithoutReportTemplateNestedInput = {
    create?: XOR<ReportComponentCreateWithoutReportTemplateInput, ReportComponentUncheckedCreateWithoutReportTemplateInput> | ReportComponentCreateWithoutReportTemplateInput[] | ReportComponentUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ReportComponentCreateOrConnectWithoutReportTemplateInput | ReportComponentCreateOrConnectWithoutReportTemplateInput[]
    upsert?: ReportComponentUpsertWithWhereUniqueWithoutReportTemplateInput | ReportComponentUpsertWithWhereUniqueWithoutReportTemplateInput[]
    createMany?: ReportComponentCreateManyReportTemplateInputEnvelope
    set?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    disconnect?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    delete?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    connect?: ReportComponentWhereUniqueInput | ReportComponentWhereUniqueInput[]
    update?: ReportComponentUpdateWithWhereUniqueWithoutReportTemplateInput | ReportComponentUpdateWithWhereUniqueWithoutReportTemplateInput[]
    updateMany?: ReportComponentUpdateManyWithWhereWithoutReportTemplateInput | ReportComponentUpdateManyWithWhereWithoutReportTemplateInput[]
    deleteMany?: ReportComponentScalarWhereInput | ReportComponentScalarWhereInput[]
  }

  export type ScheduledReportUncheckedUpdateManyWithoutReportTemplateNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutReportTemplateInput, ScheduledReportUncheckedCreateWithoutReportTemplateInput> | ScheduledReportCreateWithoutReportTemplateInput[] | ScheduledReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutReportTemplateInput | ScheduledReportCreateOrConnectWithoutReportTemplateInput[]
    upsert?: ScheduledReportUpsertWithWhereUniqueWithoutReportTemplateInput | ScheduledReportUpsertWithWhereUniqueWithoutReportTemplateInput[]
    createMany?: ScheduledReportCreateManyReportTemplateInputEnvelope
    set?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    disconnect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    delete?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    connect?: ScheduledReportWhereUniqueInput | ScheduledReportWhereUniqueInput[]
    update?: ScheduledReportUpdateWithWhereUniqueWithoutReportTemplateInput | ScheduledReportUpdateWithWhereUniqueWithoutReportTemplateInput[]
    updateMany?: ScheduledReportUpdateManyWithWhereWithoutReportTemplateInput | ScheduledReportUpdateManyWithWhereWithoutReportTemplateInput[]
    deleteMany?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
  }

  export type ReportTemplateCreateNestedOneWithoutComponentsInput = {
    create?: XOR<ReportTemplateCreateWithoutComponentsInput, ReportTemplateUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutComponentsInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type EnumReportComponentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportComponentType
  }

  export type ReportTemplateUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutComponentsInput, ReportTemplateUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutComponentsInput
    upsert?: ReportTemplateUpsertWithoutComponentsInput
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutComponentsInput, ReportTemplateUpdateWithoutComponentsInput>, ReportTemplateUncheckedUpdateWithoutComponentsInput>
  }

  export type TenantCreateNestedOneWithoutScheduledReportsInput = {
    create?: XOR<TenantCreateWithoutScheduledReportsInput, TenantUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScheduledReportsInput
    connect?: TenantWhereUniqueInput
  }

  export type ReportTemplateCreateNestedOneWithoutInstancesInput = {
    create?: XOR<ReportTemplateCreateWithoutInstancesInput, ReportTemplateUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutInstancesInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedScheduledReportsInput = {
    create?: XOR<UserCreateWithoutCreatedScheduledReportsInput, UserUncheckedCreateWithoutCreatedScheduledReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedScheduledReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportExecutionCreateNestedManyWithoutScheduledReportInput = {
    create?: XOR<ReportExecutionCreateWithoutScheduledReportInput, ReportExecutionUncheckedCreateWithoutScheduledReportInput> | ReportExecutionCreateWithoutScheduledReportInput[] | ReportExecutionUncheckedCreateWithoutScheduledReportInput[]
    connectOrCreate?: ReportExecutionCreateOrConnectWithoutScheduledReportInput | ReportExecutionCreateOrConnectWithoutScheduledReportInput[]
    createMany?: ReportExecutionCreateManyScheduledReportInputEnvelope
    connect?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
  }

  export type ReportExecutionUncheckedCreateNestedManyWithoutScheduledReportInput = {
    create?: XOR<ReportExecutionCreateWithoutScheduledReportInput, ReportExecutionUncheckedCreateWithoutScheduledReportInput> | ReportExecutionCreateWithoutScheduledReportInput[] | ReportExecutionUncheckedCreateWithoutScheduledReportInput[]
    connectOrCreate?: ReportExecutionCreateOrConnectWithoutScheduledReportInput | ReportExecutionCreateOrConnectWithoutScheduledReportInput[]
    createMany?: ReportExecutionCreateManyScheduledReportInputEnvelope
    connect?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
  }

  export type EnumReportFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.ReportFrequency
  }

  export type TenantUpdateOneRequiredWithoutScheduledReportsNestedInput = {
    create?: XOR<TenantCreateWithoutScheduledReportsInput, TenantUncheckedCreateWithoutScheduledReportsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutScheduledReportsInput
    upsert?: TenantUpsertWithoutScheduledReportsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutScheduledReportsInput, TenantUpdateWithoutScheduledReportsInput>, TenantUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type ReportTemplateUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutInstancesInput, ReportTemplateUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutInstancesInput
    upsert?: ReportTemplateUpsertWithoutInstancesInput
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutInstancesInput, ReportTemplateUpdateWithoutInstancesInput>, ReportTemplateUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedScheduledReportsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedScheduledReportsInput, UserUncheckedCreateWithoutCreatedScheduledReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedScheduledReportsInput
    upsert?: UserUpsertWithoutCreatedScheduledReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedScheduledReportsInput, UserUpdateWithoutCreatedScheduledReportsInput>, UserUncheckedUpdateWithoutCreatedScheduledReportsInput>
  }

  export type ReportExecutionUpdateManyWithoutScheduledReportNestedInput = {
    create?: XOR<ReportExecutionCreateWithoutScheduledReportInput, ReportExecutionUncheckedCreateWithoutScheduledReportInput> | ReportExecutionCreateWithoutScheduledReportInput[] | ReportExecutionUncheckedCreateWithoutScheduledReportInput[]
    connectOrCreate?: ReportExecutionCreateOrConnectWithoutScheduledReportInput | ReportExecutionCreateOrConnectWithoutScheduledReportInput[]
    upsert?: ReportExecutionUpsertWithWhereUniqueWithoutScheduledReportInput | ReportExecutionUpsertWithWhereUniqueWithoutScheduledReportInput[]
    createMany?: ReportExecutionCreateManyScheduledReportInputEnvelope
    set?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    disconnect?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    delete?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    connect?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    update?: ReportExecutionUpdateWithWhereUniqueWithoutScheduledReportInput | ReportExecutionUpdateWithWhereUniqueWithoutScheduledReportInput[]
    updateMany?: ReportExecutionUpdateManyWithWhereWithoutScheduledReportInput | ReportExecutionUpdateManyWithWhereWithoutScheduledReportInput[]
    deleteMany?: ReportExecutionScalarWhereInput | ReportExecutionScalarWhereInput[]
  }

  export type ReportExecutionUncheckedUpdateManyWithoutScheduledReportNestedInput = {
    create?: XOR<ReportExecutionCreateWithoutScheduledReportInput, ReportExecutionUncheckedCreateWithoutScheduledReportInput> | ReportExecutionCreateWithoutScheduledReportInput[] | ReportExecutionUncheckedCreateWithoutScheduledReportInput[]
    connectOrCreate?: ReportExecutionCreateOrConnectWithoutScheduledReportInput | ReportExecutionCreateOrConnectWithoutScheduledReportInput[]
    upsert?: ReportExecutionUpsertWithWhereUniqueWithoutScheduledReportInput | ReportExecutionUpsertWithWhereUniqueWithoutScheduledReportInput[]
    createMany?: ReportExecutionCreateManyScheduledReportInputEnvelope
    set?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    disconnect?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    delete?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    connect?: ReportExecutionWhereUniqueInput | ReportExecutionWhereUniqueInput[]
    update?: ReportExecutionUpdateWithWhereUniqueWithoutScheduledReportInput | ReportExecutionUpdateWithWhereUniqueWithoutScheduledReportInput[]
    updateMany?: ReportExecutionUpdateManyWithWhereWithoutScheduledReportInput | ReportExecutionUpdateManyWithWhereWithoutScheduledReportInput[]
    deleteMany?: ReportExecutionScalarWhereInput | ReportExecutionScalarWhereInput[]
  }

  export type ScheduledReportCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<ScheduledReportCreateWithoutExecutionsInput, ScheduledReportUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutExecutionsInput
    connect?: ScheduledReportWhereUniqueInput
  }

  export type ScheduledReportUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<ScheduledReportCreateWithoutExecutionsInput, ScheduledReportUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ScheduledReportCreateOrConnectWithoutExecutionsInput
    upsert?: ScheduledReportUpsertWithoutExecutionsInput
    connect?: ScheduledReportWhereUniqueInput
    update?: XOR<XOR<ScheduledReportUpdateToOneWithWhereWithoutExecutionsInput, ScheduledReportUpdateWithoutExecutionsInput>, ScheduledReportUncheckedUpdateWithoutExecutionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumActionOriginFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionOrigin | EnumActionOriginFieldRefInput<$PrismaModel>
    in?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    not?: NestedEnumActionOriginFilter<$PrismaModel> | $Enums.ActionOrigin
  }

  export type NestedEnumConformidadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Conformidade | EnumConformidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConformidadeNullableFilter<$PrismaModel> | $Enums.Conformidade | null
  }

  export type NestedEnumActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusFilter<$PrismaModel> | $Enums.ActionStatus
  }

  export type NestedEnumImpactFilter<$PrismaModel = never> = {
    equals?: $Enums.Impact | EnumImpactFieldRefInput<$PrismaModel>
    in?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumImpactFilter<$PrismaModel> | $Enums.Impact
  }

  export type NestedEnumActionOriginWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionOrigin | EnumActionOriginFieldRefInput<$PrismaModel>
    in?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionOrigin[] | ListEnumActionOriginFieldRefInput<$PrismaModel>
    not?: NestedEnumActionOriginWithAggregatesFilter<$PrismaModel> | $Enums.ActionOrigin
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionOriginFilter<$PrismaModel>
    _max?: NestedEnumActionOriginFilter<$PrismaModel>
  }

  export type NestedEnumConformidadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Conformidade | EnumConformidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Conformidade[] | ListEnumConformidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConformidadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Conformidade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConformidadeNullableFilter<$PrismaModel>
    _max?: NestedEnumConformidadeNullableFilter<$PrismaModel>
  }

  export type NestedEnumActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionStatus | EnumActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionStatus[] | ListEnumActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionStatusFilter<$PrismaModel>
    _max?: NestedEnumActionStatusFilter<$PrismaModel>
  }

  export type NestedEnumImpactWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Impact | EnumImpactFieldRefInput<$PrismaModel>
    in?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    notIn?: $Enums.Impact[] | ListEnumImpactFieldRefInput<$PrismaModel>
    not?: NestedEnumImpactWithAggregatesFilter<$PrismaModel> | $Enums.Impact
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImpactFilter<$PrismaModel>
    _max?: NestedEnumImpactFilter<$PrismaModel>
  }

  export type NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RootCauseAnalysisType | EnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel> | $Enums.RootCauseAnalysisType
  }

  export type NestedEnumRootCauseAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RootCauseAnalysisType | EnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RootCauseAnalysisType[] | ListEnumRootCauseAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRootCauseAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.RootCauseAnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumRootCauseAnalysisTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOccurrenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceType | EnumOccurrenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceTypeFilter<$PrismaModel> | $Enums.OccurrenceType
  }

  export type NestedEnumOccurrenceSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceSeverity | EnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceSeverityFilter<$PrismaModel> | $Enums.OccurrenceSeverity
  }

  export type NestedEnumOccurrenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusFilter<$PrismaModel> | $Enums.OccurrenceStatus
  }

  export type NestedEnumOccurrenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceType | EnumOccurrenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceType[] | ListEnumOccurrenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceTypeFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumOccurrenceSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceSeverity | EnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceSeverity[] | ListEnumOccurrenceSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceSeverityWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceSeverityFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceSeverityFilter<$PrismaModel>
  }

  export type NestedEnumOccurrenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccurrenceStatus | EnumOccurrenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccurrenceStatus[] | ListEnumOccurrenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOccurrenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.OccurrenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
    _max?: NestedEnumOccurrenceStatusFilter<$PrismaModel>
  }

  export type NestedEnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type NestedEnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeFilter<$PrismaModel> | $Enums.WorkflowStepType
  }

  export type NestedEnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStepType | EnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStepType[] | ListEnumWorkflowStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStepTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkflowStatus[] | ListEnumWorkflowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentAccessLevel | EnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentAccessLevelFilter<$PrismaModel> | $Enums.DocumentAccessLevel
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentAccessLevel | EnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentAccessLevel[] | ListEnumDocumentAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.DocumentAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumDocumentAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportComponentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportComponentType | EnumReportComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportComponentTypeFilter<$PrismaModel> | $Enums.ReportComponentType
  }

  export type NestedEnumReportComponentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportComponentType | EnumReportComponentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportComponentType[] | ListEnumReportComponentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportComponentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportComponentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportComponentTypeFilter<$PrismaModel>
    _max?: NestedEnumReportComponentTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyFilter<$PrismaModel> | $Enums.ReportFrequency
  }

  export type NestedEnumReportFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportFrequency | EnumReportFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportFrequency[] | ListEnumReportFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumReportFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ReportFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportFrequencyFilter<$PrismaModel>
    _max?: NestedEnumReportFrequencyFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InternalAuditCreateWithoutTenantInput = {
    id?: string
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditProgram?: AuditProgramCreateNestedOneWithoutInternalAuditsInput
  }

  export type InternalAuditUncheckedCreateWithoutTenantInput = {
    id?: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalAuditCreateOrConnectWithoutTenantInput = {
    where: InternalAuditWhereUniqueInput
    create: XOR<InternalAuditCreateWithoutTenantInput, InternalAuditUncheckedCreateWithoutTenantInput>
  }

  export type InternalAuditCreateManyTenantInputEnvelope = {
    data: InternalAuditCreateManyTenantInput | InternalAuditCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ExternalAuditCreateWithoutTenantInput = {
    id?: string
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditProgram?: AuditProgramCreateNestedOneWithoutExternalAuditsInput
  }

  export type ExternalAuditUncheckedCreateWithoutTenantInput = {
    id?: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuditCreateOrConnectWithoutTenantInput = {
    where: ExternalAuditWhereUniqueInput
    create: XOR<ExternalAuditCreateWithoutTenantInput, ExternalAuditUncheckedCreateWithoutTenantInput>
  }

  export type ExternalAuditCreateManyTenantInputEnvelope = {
    data: ExternalAuditCreateManyTenantInput | ExternalAuditCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ActionItemCreateWithoutTenantInput = {
    id?: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
    rootCauseAnalysis?: RootCauseAnalysisCreateNestedOneWithoutActionItemInput
  }

  export type ActionItemUncheckedCreateWithoutTenantInput = {
    id?: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
    rootCauseAnalysis?: RootCauseAnalysisUncheckedCreateNestedOneWithoutActionItemInput
  }

  export type ActionItemCreateOrConnectWithoutTenantInput = {
    where: ActionItemWhereUniqueInput
    create: XOR<ActionItemCreateWithoutTenantInput, ActionItemUncheckedCreateWithoutTenantInput>
  }

  export type ActionItemCreateManyTenantInputEnvelope = {
    data: ActionItemCreateManyTenantInput | ActionItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RootCauseAnalysisCreateWithoutTenantInput = {
    id?: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    actionItem: ActionItemCreateNestedOneWithoutRootCauseAnalysisInput
  }

  export type RootCauseAnalysisUncheckedCreateWithoutTenantInput = {
    id?: string
    actionItemId: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RootCauseAnalysisCreateOrConnectWithoutTenantInput = {
    where: RootCauseAnalysisWhereUniqueInput
    create: XOR<RootCauseAnalysisCreateWithoutTenantInput, RootCauseAnalysisUncheckedCreateWithoutTenantInput>
  }

  export type RootCauseAnalysisCreateManyTenantInputEnvelope = {
    data: RootCauseAnalysisCreateManyTenantInput | RootCauseAnalysisCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OccurrenceCreateWithoutTenantInput = {
    id?: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel: string
    data: Date | string
    descricao: string
    resolucao?: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada?: string | null
    status: $Enums.OccurrenceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccurrenceUncheckedCreateWithoutTenantInput = {
    id?: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel: string
    data: Date | string
    descricao: string
    resolucao?: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada?: string | null
    status: $Enums.OccurrenceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccurrenceCreateOrConnectWithoutTenantInput = {
    where: OccurrenceWhereUniqueInput
    create: XOR<OccurrenceCreateWithoutTenantInput, OccurrenceUncheckedCreateWithoutTenantInput>
  }

  export type OccurrenceCreateManyTenantInputEnvelope = {
    data: OccurrenceCreateManyTenantInput | OccurrenceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SectorCreateWithoutTenantInput = {
    id?: string
    nome: string
    responsavel: string
    email?: string | null
    telefone?: string | null
    descricao?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorUncheckedCreateWithoutTenantInput = {
    id?: string
    nome: string
    responsavel: string
    email?: string | null
    telefone?: string | null
    descricao?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorCreateOrConnectWithoutTenantInput = {
    where: SectorWhereUniqueInput
    create: XOR<SectorCreateWithoutTenantInput, SectorUncheckedCreateWithoutTenantInput>
  }

  export type SectorCreateManyTenantInputEnvelope = {
    data: SectorCreateManyTenantInput | SectorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ImportLogCreateWithoutTenantInput = {
    id?: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt?: Date | string
    finishedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type ImportLogUncheckedCreateWithoutTenantInput = {
    id?: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt?: Date | string
    finishedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type ImportLogCreateOrConnectWithoutTenantInput = {
    where: ImportLogWhereUniqueInput
    create: XOR<ImportLogCreateWithoutTenantInput, ImportLogUncheckedCreateWithoutTenantInput>
  }

  export type ImportLogCreateManyTenantInputEnvelope = {
    data: ImportLogCreateManyTenantInput | ImportLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditTrailCreateWithoutTenantInput = {
    id?: string
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditTrailCreateOrConnectWithoutTenantInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutTenantInput, AuditTrailUncheckedCreateWithoutTenantInput>
  }

  export type AuditTrailCreateManyTenantInputEnvelope = {
    data: AuditTrailCreateManyTenantInput | AuditTrailCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditProgramCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: AuditProgramCreateNestedOneWithoutDerivativesInput
    derivatives?: AuditProgramCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    derivatives?: AuditProgramUncheckedCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramCreateOrConnectWithoutTenantInput = {
    where: AuditProgramWhereUniqueInput
    create: XOR<AuditProgramCreateWithoutTenantInput, AuditProgramUncheckedCreateWithoutTenantInput>
  }

  export type AuditProgramCreateManyTenantInputEnvelope = {
    data: AuditProgramCreateManyTenantInput | AuditProgramCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutTenantInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutTenantInput, AttachmentUncheckedCreateWithoutTenantInput>
  }

  export type AttachmentCreateManyTenantInputEnvelope = {
    data: AttachmentCreateManyTenantInput | AttachmentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutTenantInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTenantInput, CommentUncheckedCreateWithoutTenantInput>
  }

  export type CommentCreateManyTenantInputEnvelope = {
    data: CommentCreateManyTenantInput | CommentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    requester: UserCreateNestedOneWithoutApprovalRequestsInput
    approver?: UserCreateNestedOneWithoutApprovalApprovalsInput
  }

  export type ApprovalUncheckedCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    requestedBy: string
    approvedBy?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ApprovalCreateOrConnectWithoutTenantInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutTenantInput, ApprovalUncheckedCreateWithoutTenantInput>
  }

  export type ApprovalCreateManyTenantInputEnvelope = {
    data: ApprovalCreateManyTenantInput | ApprovalCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowDefinitionCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowDefinitionInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowDefinitionInput
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutTenantInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutTenantInput, WorkflowDefinitionUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowDefinitionCreateManyTenantInputEnvelope = {
    data: WorkflowDefinitionCreateManyTenantInput | WorkflowDefinitionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutTenantInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    startedByUser: UserCreateNestedOneWithoutWorkflowInstancesInput
    cancelledByUser?: UserCreateNestedOneWithoutWorkflowCancelledInput
    stepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutTenantInput = {
    id?: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutTenantInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutTenantInput, WorkflowInstanceUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowInstanceCreateManyTenantInputEnvelope = {
    data: WorkflowInstanceCreateManyTenantInput | WorkflowInstanceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutTenantInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedDocumentsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentInput
    workflowInstance?: WorkflowInstanceCreateNestedOneWithoutDocumentsInput
    readConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutTenantInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentCreateManyTenantInputEnvelope = {
    data: DocumentCreateManyTenantInput | DocumentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentVersionCreateWithoutTenantInput = {
    id?: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    isCurrent?: boolean
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutVersionsInput
    uploader: UserCreateNestedOneWithoutUpdatedDocumentVersionsInput
  }

  export type DocumentVersionUncheckedCreateWithoutTenantInput = {
    id?: string
    documentId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    uploadedBy: string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentVersionCreateOrConnectWithoutTenantInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutTenantInput, DocumentVersionUncheckedCreateWithoutTenantInput>
  }

  export type DocumentVersionCreateManyTenantInputEnvelope = {
    data: DocumentVersionCreateManyTenantInput | DocumentVersionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentTagCreateWithoutTenantInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutTagsInput
  }

  export type DocumentTagUncheckedCreateWithoutTenantInput = {
    id?: string
    documentId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type DocumentTagCreateOrConnectWithoutTenantInput = {
    where: DocumentTagWhereUniqueInput
    create: XOR<DocumentTagCreateWithoutTenantInput, DocumentTagUncheckedCreateWithoutTenantInput>
  }

  export type DocumentTagCreateManyTenantInputEnvelope = {
    data: DocumentTagCreateManyTenantInput | DocumentTagCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DocumentReadConfirmationCreateWithoutTenantInput = {
    id?: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    document: DocumentCreateNestedOneWithoutReadConfirmationsInput
    user: UserCreateNestedOneWithoutDocumentReadConfirmationsInput
  }

  export type DocumentReadConfirmationUncheckedCreateWithoutTenantInput = {
    id?: string
    documentId: string
    userId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type DocumentReadConfirmationCreateOrConnectWithoutTenantInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    create: XOR<DocumentReadConfirmationCreateWithoutTenantInput, DocumentReadConfirmationUncheckedCreateWithoutTenantInput>
  }

  export type DocumentReadConfirmationCreateManyTenantInputEnvelope = {
    data: DocumentReadConfirmationCreateManyTenantInput | DocumentReadConfirmationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ReportTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedReportTemplatesInput
    components?: ReportComponentCreateNestedManyWithoutReportTemplateInput
    instances?: ScheduledReportCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ReportComponentUncheckedCreateNestedManyWithoutReportTemplateInput
    instances?: ScheduledReportUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutTenantInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ReportTemplateCreateManyTenantInputEnvelope = {
    data: ReportTemplateCreateManyTenantInput | ReportTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reportTemplate: ReportTemplateCreateNestedOneWithoutInstancesInput
    creator: UserCreateNestedOneWithoutCreatedScheduledReportsInput
    executions?: ReportExecutionCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportUncheckedCreateWithoutTenantInput = {
    id?: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: ReportExecutionUncheckedCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportCreateOrConnectWithoutTenantInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutTenantInput, ScheduledReportUncheckedCreateWithoutTenantInput>
  }

  export type ScheduledReportCreateManyTenantInputEnvelope = {
    data: ScheduledReportCreateManyTenantInput | ScheduledReportCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type InternalAuditUpsertWithWhereUniqueWithoutTenantInput = {
    where: InternalAuditWhereUniqueInput
    update: XOR<InternalAuditUpdateWithoutTenantInput, InternalAuditUncheckedUpdateWithoutTenantInput>
    create: XOR<InternalAuditCreateWithoutTenantInput, InternalAuditUncheckedCreateWithoutTenantInput>
  }

  export type InternalAuditUpdateWithWhereUniqueWithoutTenantInput = {
    where: InternalAuditWhereUniqueInput
    data: XOR<InternalAuditUpdateWithoutTenantInput, InternalAuditUncheckedUpdateWithoutTenantInput>
  }

  export type InternalAuditUpdateManyWithWhereWithoutTenantInput = {
    where: InternalAuditScalarWhereInput
    data: XOR<InternalAuditUpdateManyMutationInput, InternalAuditUncheckedUpdateManyWithoutTenantInput>
  }

  export type InternalAuditScalarWhereInput = {
    AND?: InternalAuditScalarWhereInput | InternalAuditScalarWhereInput[]
    OR?: InternalAuditScalarWhereInput[]
    NOT?: InternalAuditScalarWhereInput | InternalAuditScalarWhereInput[]
    id?: StringFilter<"InternalAudit"> | string
    tenantId?: StringFilter<"InternalAudit"> | string
    auditProgramId?: StringNullableFilter<"InternalAudit"> | string | null
    ano?: IntFilter<"InternalAudit"> | number
    entidadeAuditora?: StringNullableFilter<"InternalAudit"> | string | null
    iso?: StringNullableFilter<"InternalAudit"> | string | null
    inicio?: DateTimeNullableFilter<"InternalAudit"> | Date | string | null
    termino?: DateTimeNullableFilter<"InternalAudit"> | Date | string | null
    createdAt?: DateTimeFilter<"InternalAudit"> | Date | string
    updatedAt?: DateTimeFilter<"InternalAudit"> | Date | string
  }

  export type ExternalAuditUpsertWithWhereUniqueWithoutTenantInput = {
    where: ExternalAuditWhereUniqueInput
    update: XOR<ExternalAuditUpdateWithoutTenantInput, ExternalAuditUncheckedUpdateWithoutTenantInput>
    create: XOR<ExternalAuditCreateWithoutTenantInput, ExternalAuditUncheckedCreateWithoutTenantInput>
  }

  export type ExternalAuditUpdateWithWhereUniqueWithoutTenantInput = {
    where: ExternalAuditWhereUniqueInput
    data: XOR<ExternalAuditUpdateWithoutTenantInput, ExternalAuditUncheckedUpdateWithoutTenantInput>
  }

  export type ExternalAuditUpdateManyWithWhereWithoutTenantInput = {
    where: ExternalAuditScalarWhereInput
    data: XOR<ExternalAuditUpdateManyMutationInput, ExternalAuditUncheckedUpdateManyWithoutTenantInput>
  }

  export type ExternalAuditScalarWhereInput = {
    AND?: ExternalAuditScalarWhereInput | ExternalAuditScalarWhereInput[]
    OR?: ExternalAuditScalarWhereInput[]
    NOT?: ExternalAuditScalarWhereInput | ExternalAuditScalarWhereInput[]
    id?: StringFilter<"ExternalAudit"> | string
    tenantId?: StringFilter<"ExternalAudit"> | string
    auditProgramId?: StringNullableFilter<"ExternalAudit"> | string | null
    ano?: IntFilter<"ExternalAudit"> | number
    entidadeAuditora?: StringFilter<"ExternalAudit"> | string
    iso?: StringNullableFilter<"ExternalAudit"> | string | null
    inicio?: DateTimeNullableFilter<"ExternalAudit"> | Date | string | null
    termino?: DateTimeNullableFilter<"ExternalAudit"> | Date | string | null
    createdAt?: DateTimeFilter<"ExternalAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalAudit"> | Date | string
  }

  export type ActionItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: ActionItemWhereUniqueInput
    update: XOR<ActionItemUpdateWithoutTenantInput, ActionItemUncheckedUpdateWithoutTenantInput>
    create: XOR<ActionItemCreateWithoutTenantInput, ActionItemUncheckedCreateWithoutTenantInput>
  }

  export type ActionItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: ActionItemWhereUniqueInput
    data: XOR<ActionItemUpdateWithoutTenantInput, ActionItemUncheckedUpdateWithoutTenantInput>
  }

  export type ActionItemUpdateManyWithWhereWithoutTenantInput = {
    where: ActionItemScalarWhereInput
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type ActionItemScalarWhereInput = {
    AND?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
    OR?: ActionItemScalarWhereInput[]
    NOT?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
    id?: StringFilter<"ActionItem"> | string
    tenantId?: StringFilter<"ActionItem"> | string
    origem?: EnumActionOriginFilter<"ActionItem"> | $Enums.ActionOrigin
    acaoRelacionada?: StringFilter<"ActionItem"> | string
    conformidade?: EnumConformidadeNullableFilter<"ActionItem"> | $Enums.Conformidade | null
    numeroAssociado?: StringNullableFilter<"ActionItem"> | string | null
    ambito?: StringNullableFilter<"ActionItem"> | string | null
    descricao?: StringFilter<"ActionItem"> | string
    causaRaizIdentificada?: StringNullableFilter<"ActionItem"> | string | null
    acaoCorretiva?: StringNullableFilter<"ActionItem"> | string | null
    local?: StringNullableFilter<"ActionItem"> | string | null
    responsavel?: StringNullableFilter<"ActionItem"> | string | null
    inicio?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    termino?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    conclusao?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    status?: EnumActionStatusFilter<"ActionItem"> | $Enums.ActionStatus
    mes?: StringNullableFilter<"ActionItem"> | string | null
    evidencia?: StringNullableFilter<"ActionItem"> | string | null
    avaliacaoEficacia?: StringNullableFilter<"ActionItem"> | string | null
    setor?: StringFilter<"ActionItem"> | string
    dataAbertura?: DateTimeFilter<"ActionItem"> | Date | string
    dataLimite?: DateTimeFilter<"ActionItem"> | Date | string
    dataConclusao?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    impacto?: EnumImpactFilter<"ActionItem"> | $Enums.Impact
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ActionItem"> | Date | string
  }

  export type RootCauseAnalysisUpsertWithWhereUniqueWithoutTenantInput = {
    where: RootCauseAnalysisWhereUniqueInput
    update: XOR<RootCauseAnalysisUpdateWithoutTenantInput, RootCauseAnalysisUncheckedUpdateWithoutTenantInput>
    create: XOR<RootCauseAnalysisCreateWithoutTenantInput, RootCauseAnalysisUncheckedCreateWithoutTenantInput>
  }

  export type RootCauseAnalysisUpdateWithWhereUniqueWithoutTenantInput = {
    where: RootCauseAnalysisWhereUniqueInput
    data: XOR<RootCauseAnalysisUpdateWithoutTenantInput, RootCauseAnalysisUncheckedUpdateWithoutTenantInput>
  }

  export type RootCauseAnalysisUpdateManyWithWhereWithoutTenantInput = {
    where: RootCauseAnalysisScalarWhereInput
    data: XOR<RootCauseAnalysisUpdateManyMutationInput, RootCauseAnalysisUncheckedUpdateManyWithoutTenantInput>
  }

  export type RootCauseAnalysisScalarWhereInput = {
    AND?: RootCauseAnalysisScalarWhereInput | RootCauseAnalysisScalarWhereInput[]
    OR?: RootCauseAnalysisScalarWhereInput[]
    NOT?: RootCauseAnalysisScalarWhereInput | RootCauseAnalysisScalarWhereInput[]
    id?: StringFilter<"RootCauseAnalysis"> | string
    actionItemId?: StringFilter<"RootCauseAnalysis"> | string
    tenantId?: StringFilter<"RootCauseAnalysis"> | string
    analysisType?: EnumRootCauseAnalysisTypeFilter<"RootCauseAnalysis"> | $Enums.RootCauseAnalysisType
    data?: JsonFilter<"RootCauseAnalysis">
    createdAt?: DateTimeFilter<"RootCauseAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"RootCauseAnalysis"> | Date | string
  }

  export type OccurrenceUpsertWithWhereUniqueWithoutTenantInput = {
    where: OccurrenceWhereUniqueInput
    update: XOR<OccurrenceUpdateWithoutTenantInput, OccurrenceUncheckedUpdateWithoutTenantInput>
    create: XOR<OccurrenceCreateWithoutTenantInput, OccurrenceUncheckedCreateWithoutTenantInput>
  }

  export type OccurrenceUpdateWithWhereUniqueWithoutTenantInput = {
    where: OccurrenceWhereUniqueInput
    data: XOR<OccurrenceUpdateWithoutTenantInput, OccurrenceUncheckedUpdateWithoutTenantInput>
  }

  export type OccurrenceUpdateManyWithWhereWithoutTenantInput = {
    where: OccurrenceScalarWhereInput
    data: XOR<OccurrenceUpdateManyMutationInput, OccurrenceUncheckedUpdateManyWithoutTenantInput>
  }

  export type OccurrenceScalarWhereInput = {
    AND?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
    OR?: OccurrenceScalarWhereInput[]
    NOT?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
    id?: StringFilter<"Occurrence"> | string
    tenantId?: StringFilter<"Occurrence"> | string
    tipo?: EnumOccurrenceTypeFilter<"Occurrence"> | $Enums.OccurrenceType
    setor?: StringFilter<"Occurrence"> | string
    departamentosAtingidos?: JsonFilter<"Occurrence">
    responsavel?: StringFilter<"Occurrence"> | string
    data?: DateTimeFilter<"Occurrence"> | Date | string
    descricao?: StringFilter<"Occurrence"> | string
    resolucao?: StringNullableFilter<"Occurrence"> | string | null
    gravidade?: EnumOccurrenceSeverityFilter<"Occurrence"> | $Enums.OccurrenceSeverity
    acaoGerada?: StringNullableFilter<"Occurrence"> | string | null
    status?: EnumOccurrenceStatusFilter<"Occurrence"> | $Enums.OccurrenceStatus
    createdAt?: DateTimeFilter<"Occurrence"> | Date | string
    updatedAt?: DateTimeFilter<"Occurrence"> | Date | string
  }

  export type SectorUpsertWithWhereUniqueWithoutTenantInput = {
    where: SectorWhereUniqueInput
    update: XOR<SectorUpdateWithoutTenantInput, SectorUncheckedUpdateWithoutTenantInput>
    create: XOR<SectorCreateWithoutTenantInput, SectorUncheckedCreateWithoutTenantInput>
  }

  export type SectorUpdateWithWhereUniqueWithoutTenantInput = {
    where: SectorWhereUniqueInput
    data: XOR<SectorUpdateWithoutTenantInput, SectorUncheckedUpdateWithoutTenantInput>
  }

  export type SectorUpdateManyWithWhereWithoutTenantInput = {
    where: SectorScalarWhereInput
    data: XOR<SectorUpdateManyMutationInput, SectorUncheckedUpdateManyWithoutTenantInput>
  }

  export type SectorScalarWhereInput = {
    AND?: SectorScalarWhereInput | SectorScalarWhereInput[]
    OR?: SectorScalarWhereInput[]
    NOT?: SectorScalarWhereInput | SectorScalarWhereInput[]
    id?: StringFilter<"Sector"> | string
    tenantId?: StringFilter<"Sector"> | string
    nome?: StringFilter<"Sector"> | string
    responsavel?: StringFilter<"Sector"> | string
    email?: StringNullableFilter<"Sector"> | string | null
    telefone?: StringNullableFilter<"Sector"> | string | null
    descricao?: StringNullableFilter<"Sector"> | string | null
    ativo?: BoolFilter<"Sector"> | boolean
    createdAt?: DateTimeFilter<"Sector"> | Date | string
    updatedAt?: DateTimeFilter<"Sector"> | Date | string
  }

  export type ImportLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: ImportLogWhereUniqueInput
    update: XOR<ImportLogUpdateWithoutTenantInput, ImportLogUncheckedUpdateWithoutTenantInput>
    create: XOR<ImportLogCreateWithoutTenantInput, ImportLogUncheckedCreateWithoutTenantInput>
  }

  export type ImportLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: ImportLogWhereUniqueInput
    data: XOR<ImportLogUpdateWithoutTenantInput, ImportLogUncheckedUpdateWithoutTenantInput>
  }

  export type ImportLogUpdateManyWithWhereWithoutTenantInput = {
    where: ImportLogScalarWhereInput
    data: XOR<ImportLogUpdateManyMutationInput, ImportLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type ImportLogScalarWhereInput = {
    AND?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
    OR?: ImportLogScalarWhereInput[]
    NOT?: ImportLogScalarWhereInput | ImportLogScalarWhereInput[]
    id?: StringFilter<"ImportLog"> | string
    tenantId?: StringFilter<"ImportLog"> | string
    fileName?: StringFilter<"ImportLog"> | string
    mode?: StringFilter<"ImportLog"> | string
    entity?: StringFilter<"ImportLog"> | string
    status?: EnumImportStatusFilter<"ImportLog"> | $Enums.ImportStatus
    totalRecords?: IntFilter<"ImportLog"> | number
    createdAt?: DateTimeFilter<"ImportLog"> | Date | string
    finishedAt?: DateTimeNullableFilter<"ImportLog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ImportLog"> | string | null
  }

  export type AuditTrailUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditTrailWhereUniqueInput
    update: XOR<AuditTrailUpdateWithoutTenantInput, AuditTrailUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditTrailCreateWithoutTenantInput, AuditTrailUncheckedCreateWithoutTenantInput>
  }

  export type AuditTrailUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditTrailWhereUniqueInput
    data: XOR<AuditTrailUpdateWithoutTenantInput, AuditTrailUncheckedUpdateWithoutTenantInput>
  }

  export type AuditTrailUpdateManyWithWhereWithoutTenantInput = {
    where: AuditTrailScalarWhereInput
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditTrailScalarWhereInput = {
    AND?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    OR?: AuditTrailScalarWhereInput[]
    NOT?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    tenantId?: StringFilter<"AuditTrail"> | string
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    action?: EnumAuditActionFilter<"AuditTrail"> | $Enums.AuditAction
    entity?: StringFilter<"AuditTrail"> | string
    entityId?: StringNullableFilter<"AuditTrail"> | string | null
    description?: StringFilter<"AuditTrail"> | string
    metadata?: JsonNullableFilter<"AuditTrail">
    createdAt?: DateTimeFilter<"AuditTrail"> | Date | string
  }

  export type AuditProgramUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditProgramWhereUniqueInput
    update: XOR<AuditProgramUpdateWithoutTenantInput, AuditProgramUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditProgramCreateWithoutTenantInput, AuditProgramUncheckedCreateWithoutTenantInput>
  }

  export type AuditProgramUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditProgramWhereUniqueInput
    data: XOR<AuditProgramUpdateWithoutTenantInput, AuditProgramUncheckedUpdateWithoutTenantInput>
  }

  export type AuditProgramUpdateManyWithWhereWithoutTenantInput = {
    where: AuditProgramScalarWhereInput
    data: XOR<AuditProgramUpdateManyMutationInput, AuditProgramUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditProgramScalarWhereInput = {
    AND?: AuditProgramScalarWhereInput | AuditProgramScalarWhereInput[]
    OR?: AuditProgramScalarWhereInput[]
    NOT?: AuditProgramScalarWhereInput | AuditProgramScalarWhereInput[]
    id?: StringFilter<"AuditProgram"> | string
    tenantId?: StringFilter<"AuditProgram"> | string
    name?: StringFilter<"AuditProgram"> | string
    description?: StringNullableFilter<"AuditProgram"> | string | null
    standard?: StringFilter<"AuditProgram"> | string
    version?: StringFilter<"AuditProgram"> | string
    isTemplate?: BoolFilter<"AuditProgram"> | boolean
    templateId?: StringNullableFilter<"AuditProgram"> | string | null
    createdAt?: DateTimeFilter<"AuditProgram"> | Date | string
    updatedAt?: DateTimeFilter<"AuditProgram"> | Date | string
  }

  export type AttachmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutTenantInput, AttachmentUncheckedUpdateWithoutTenantInput>
    create: XOR<AttachmentCreateWithoutTenantInput, AttachmentUncheckedCreateWithoutTenantInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutTenantInput, AttachmentUncheckedUpdateWithoutTenantInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutTenantInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    tenantId?: StringFilter<"Attachment"> | string
    entityType?: StringFilter<"Attachment"> | string
    entityId?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    originalName?: StringFilter<"Attachment"> | string
    mimeType?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    path?: StringFilter<"Attachment"> | string
    uploadedBy?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutTenantInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTenantInput, CommentUncheckedUpdateWithoutTenantInput>
    create: XOR<CommentCreateWithoutTenantInput, CommentUncheckedCreateWithoutTenantInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTenantInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTenantInput, CommentUncheckedUpdateWithoutTenantInput>
  }

  export type CommentUpdateManyWithWhereWithoutTenantInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTenantInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    tenantId?: StringFilter<"Comment"> | string
    entityType?: StringFilter<"Comment"> | string
    entityId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ApprovalUpsertWithWhereUniqueWithoutTenantInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutTenantInput, ApprovalUncheckedUpdateWithoutTenantInput>
    create: XOR<ApprovalCreateWithoutTenantInput, ApprovalUncheckedCreateWithoutTenantInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutTenantInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutTenantInput, ApprovalUncheckedUpdateWithoutTenantInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutTenantInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutTenantInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    OR?: ApprovalScalarWhereInput[]
    NOT?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    id?: StringFilter<"Approval"> | string
    tenantId?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    requestedBy?: StringFilter<"Approval"> | string
    approvedBy?: StringNullableFilter<"Approval"> | string | null
    comments?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    updatedAt?: DateTimeFilter<"Approval"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
  }

  export type WorkflowDefinitionUpsertWithWhereUniqueWithoutTenantInput = {
    where: WorkflowDefinitionWhereUniqueInput
    update: XOR<WorkflowDefinitionUpdateWithoutTenantInput, WorkflowDefinitionUncheckedUpdateWithoutTenantInput>
    create: XOR<WorkflowDefinitionCreateWithoutTenantInput, WorkflowDefinitionUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowDefinitionUpdateWithWhereUniqueWithoutTenantInput = {
    where: WorkflowDefinitionWhereUniqueInput
    data: XOR<WorkflowDefinitionUpdateWithoutTenantInput, WorkflowDefinitionUncheckedUpdateWithoutTenantInput>
  }

  export type WorkflowDefinitionUpdateManyWithWhereWithoutTenantInput = {
    where: WorkflowDefinitionScalarWhereInput
    data: XOR<WorkflowDefinitionUpdateManyMutationInput, WorkflowDefinitionUncheckedUpdateManyWithoutTenantInput>
  }

  export type WorkflowDefinitionScalarWhereInput = {
    AND?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
    OR?: WorkflowDefinitionScalarWhereInput[]
    NOT?: WorkflowDefinitionScalarWhereInput | WorkflowDefinitionScalarWhereInput[]
    id?: StringFilter<"WorkflowDefinition"> | string
    tenantId?: StringFilter<"WorkflowDefinition"> | string
    name?: StringFilter<"WorkflowDefinition"> | string
    description?: StringNullableFilter<"WorkflowDefinition"> | string | null
    entityType?: StringFilter<"WorkflowDefinition"> | string
    isActive?: BoolFilter<"WorkflowDefinition"> | boolean
    createdAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowDefinition"> | Date | string
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutTenantInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutTenantInput, WorkflowInstanceUncheckedUpdateWithoutTenantInput>
    create: XOR<WorkflowInstanceCreateWithoutTenantInput, WorkflowInstanceUncheckedCreateWithoutTenantInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutTenantInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutTenantInput, WorkflowInstanceUncheckedUpdateWithoutTenantInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutTenantInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutTenantInput>
  }

  export type WorkflowInstanceScalarWhereInput = {
    AND?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
    OR?: WorkflowInstanceScalarWhereInput[]
    NOT?: WorkflowInstanceScalarWhereInput | WorkflowInstanceScalarWhereInput[]
    id?: StringFilter<"WorkflowInstance"> | string
    tenantId?: StringFilter<"WorkflowInstance"> | string
    workflowDefinitionId?: StringFilter<"WorkflowInstance"> | string
    entityType?: StringFilter<"WorkflowInstance"> | string
    entityId?: StringFilter<"WorkflowInstance"> | string
    status?: EnumWorkflowStatusFilter<"WorkflowInstance"> | $Enums.WorkflowStatus
    startedBy?: StringFilter<"WorkflowInstance"> | string
    currentStepOrder?: IntNullableFilter<"WorkflowInstance"> | number | null
    completedAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"WorkflowInstance"> | Date | string | null
    cancelledBy?: StringNullableFilter<"WorkflowInstance"> | string | null
    createdAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowInstance"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentCreateWithoutTenantInput, DocumentUncheckedCreateWithoutTenantInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutTenantInput, DocumentUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    tenantId?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFilter<"Document"> | $Enums.DocumentAccessLevel
    currentVersion?: IntFilter<"Document"> | number
    createdBy?: StringFilter<"Document"> | string
    workflowInstanceId?: StringNullableFilter<"Document"> | string | null
    allowedRoles?: JsonFilter<"Document">
    allowedUsers?: JsonFilter<"Document">
    metadata?: JsonNullableFilter<"Document">
    archivedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DocumentVersionUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentVersionWhereUniqueInput
    update: XOR<DocumentVersionUpdateWithoutTenantInput, DocumentVersionUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentVersionCreateWithoutTenantInput, DocumentVersionUncheckedCreateWithoutTenantInput>
  }

  export type DocumentVersionUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentVersionWhereUniqueInput
    data: XOR<DocumentVersionUpdateWithoutTenantInput, DocumentVersionUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentVersionUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentVersionScalarWhereInput
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentVersionScalarWhereInput = {
    AND?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
    OR?: DocumentVersionScalarWhereInput[]
    NOT?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
    id?: StringFilter<"DocumentVersion"> | string
    documentId?: StringFilter<"DocumentVersion"> | string
    tenantId?: StringFilter<"DocumentVersion"> | string
    version?: IntFilter<"DocumentVersion"> | number
    fileName?: StringFilter<"DocumentVersion"> | string
    originalName?: StringFilter<"DocumentVersion"> | string
    mimeType?: StringFilter<"DocumentVersion"> | string
    size?: IntFilter<"DocumentVersion"> | number
    path?: StringFilter<"DocumentVersion"> | string
    checksum?: StringNullableFilter<"DocumentVersion"> | string | null
    changeNotes?: StringNullableFilter<"DocumentVersion"> | string | null
    uploadedBy?: StringFilter<"DocumentVersion"> | string
    isCurrent?: BoolFilter<"DocumentVersion"> | boolean
    createdAt?: DateTimeFilter<"DocumentVersion"> | Date | string
  }

  export type DocumentTagUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentTagWhereUniqueInput
    update: XOR<DocumentTagUpdateWithoutTenantInput, DocumentTagUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentTagCreateWithoutTenantInput, DocumentTagUncheckedCreateWithoutTenantInput>
  }

  export type DocumentTagUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentTagWhereUniqueInput
    data: XOR<DocumentTagUpdateWithoutTenantInput, DocumentTagUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentTagUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentTagScalarWhereInput
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentTagScalarWhereInput = {
    AND?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
    OR?: DocumentTagScalarWhereInput[]
    NOT?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
    id?: StringFilter<"DocumentTag"> | string
    tenantId?: StringFilter<"DocumentTag"> | string
    documentId?: StringFilter<"DocumentTag"> | string
    name?: StringFilter<"DocumentTag"> | string
    color?: StringNullableFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeFilter<"DocumentTag"> | Date | string
  }

  export type DocumentReadConfirmationUpsertWithWhereUniqueWithoutTenantInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    update: XOR<DocumentReadConfirmationUpdateWithoutTenantInput, DocumentReadConfirmationUncheckedUpdateWithoutTenantInput>
    create: XOR<DocumentReadConfirmationCreateWithoutTenantInput, DocumentReadConfirmationUncheckedCreateWithoutTenantInput>
  }

  export type DocumentReadConfirmationUpdateWithWhereUniqueWithoutTenantInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    data: XOR<DocumentReadConfirmationUpdateWithoutTenantInput, DocumentReadConfirmationUncheckedUpdateWithoutTenantInput>
  }

  export type DocumentReadConfirmationUpdateManyWithWhereWithoutTenantInput = {
    where: DocumentReadConfirmationScalarWhereInput
    data: XOR<DocumentReadConfirmationUpdateManyMutationInput, DocumentReadConfirmationUncheckedUpdateManyWithoutTenantInput>
  }

  export type DocumentReadConfirmationScalarWhereInput = {
    AND?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
    OR?: DocumentReadConfirmationScalarWhereInput[]
    NOT?: DocumentReadConfirmationScalarWhereInput | DocumentReadConfirmationScalarWhereInput[]
    id?: StringFilter<"DocumentReadConfirmation"> | string
    documentId?: StringFilter<"DocumentReadConfirmation"> | string
    tenantId?: StringFilter<"DocumentReadConfirmation"> | string
    userId?: StringFilter<"DocumentReadConfirmation"> | string
    confirmedAt?: DateTimeFilter<"DocumentReadConfirmation"> | Date | string
    ipAddress?: StringNullableFilter<"DocumentReadConfirmation"> | string | null
    userAgent?: StringNullableFilter<"DocumentReadConfirmation"> | string | null
  }

  export type ReportTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: ReportTemplateWhereUniqueInput
    update: XOR<ReportTemplateUpdateWithoutTenantInput, ReportTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ReportTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: ReportTemplateWhereUniqueInput
    data: XOR<ReportTemplateUpdateWithoutTenantInput, ReportTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type ReportTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: ReportTemplateScalarWhereInput
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type ReportTemplateScalarWhereInput = {
    AND?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
    OR?: ReportTemplateScalarWhereInput[]
    NOT?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    tenantId?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    reportType?: EnumReportTypeFilter<"ReportTemplate"> | $Enums.ReportType
    status?: EnumReportStatusFilter<"ReportTemplate"> | $Enums.ReportStatus
    isPublic?: BoolFilter<"ReportTemplate"> | boolean
    createdBy?: StringFilter<"ReportTemplate"> | string
    metadata?: JsonNullableFilter<"ReportTemplate">
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutTenantInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutTenantInput, ScheduledReportUncheckedUpdateWithoutTenantInput>
    create: XOR<ScheduledReportCreateWithoutTenantInput, ScheduledReportUncheckedCreateWithoutTenantInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutTenantInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutTenantInput, ScheduledReportUncheckedUpdateWithoutTenantInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutTenantInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutTenantInput>
  }

  export type ScheduledReportScalarWhereInput = {
    AND?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
    OR?: ScheduledReportScalarWhereInput[]
    NOT?: ScheduledReportScalarWhereInput | ScheduledReportScalarWhereInput[]
    id?: StringFilter<"ScheduledReport"> | string
    tenantId?: StringFilter<"ScheduledReport"> | string
    reportTemplateId?: StringFilter<"ScheduledReport"> | string
    name?: StringFilter<"ScheduledReport"> | string
    description?: StringNullableFilter<"ScheduledReport"> | string | null
    frequency?: EnumReportFrequencyFilter<"ScheduledReport"> | $Enums.ReportFrequency
    schedule?: StringFilter<"ScheduledReport"> | string
    recipients?: JsonFilter<"ScheduledReport">
    format?: JsonFilter<"ScheduledReport">
    filters?: JsonNullableFilter<"ScheduledReport">
    status?: EnumReportStatusFilter<"ScheduledReport"> | $Enums.ReportStatus
    enabled?: BoolFilter<"ScheduledReport"> | boolean
    lastRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"ScheduledReport"> | Date | string | null
    createdBy?: StringFilter<"ScheduledReport"> | string
    createdAt?: DateTimeFilter<"ScheduledReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledReport"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type AuditTrailCreateWithoutUserInput = {
    id?: string
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditTrailCreateOrConnectWithoutUserInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput>
  }

  export type AuditTrailCreateManyUserInputEnvelope = {
    data: AuditTrailCreateManyUserInput | AuditTrailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentCreateManyUserInputEnvelope = {
    data: AttachmentCreateManyUserInput | AttachmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutRequesterInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutApprovalsInput
    approver?: UserCreateNestedOneWithoutApprovalApprovalsInput
  }

  export type ApprovalUncheckedCreateWithoutRequesterInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ApprovalCreateOrConnectWithoutRequesterInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutRequesterInput, ApprovalUncheckedCreateWithoutRequesterInput>
  }

  export type ApprovalCreateManyRequesterInputEnvelope = {
    data: ApprovalCreateManyRequesterInput | ApprovalCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutApproverInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutApprovalsInput
    requester: UserCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    requestedBy: string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ApprovalCreateOrConnectWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalCreateManyApproverInputEnvelope = {
    data: ApprovalCreateManyApproverInput | ApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutStartedByUserInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowInstancesInput
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    cancelledByUser?: UserCreateNestedOneWithoutWorkflowCancelledInput
    stepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutStartedByUserInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutStartedByUserInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutStartedByUserInput, WorkflowInstanceUncheckedCreateWithoutStartedByUserInput>
  }

  export type WorkflowInstanceCreateManyStartedByUserInputEnvelope = {
    data: WorkflowInstanceCreateManyStartedByUserInput | WorkflowInstanceCreateManyStartedByUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutCancelledByUserInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowInstancesInput
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    startedByUser: UserCreateNestedOneWithoutWorkflowInstancesInput
    stepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutCancelledByUserInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutCancelledByUserInput, WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput>
  }

  export type WorkflowInstanceCreateManyCancelledByUserInputEnvelope = {
    data: WorkflowInstanceCreateManyCancelledByUserInput | WorkflowInstanceCreateManyCancelledByUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowStepExecutionCreateWithoutExecutedByUserInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflowInstance: WorkflowInstanceCreateNestedOneWithoutStepExecutionsInput
  }

  export type WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput = {
    id?: string
    workflowInstanceId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepExecutionCreateOrConnectWithoutExecutedByUserInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    create: XOR<WorkflowStepExecutionCreateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput>
  }

  export type WorkflowStepExecutionCreateManyExecutedByUserInputEnvelope = {
    data: WorkflowStepExecutionCreateManyExecutedByUserInput | WorkflowStepExecutionCreateManyExecutedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    status?: $Enums.SessionStatus
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    status?: $Enums.SessionStatus
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentInput
    workflowInstance?: WorkflowInstanceCreateNestedOneWithoutDocumentsInput
    readConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutCreatorInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutCreatorInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCreatorInput, DocumentUncheckedCreateWithoutCreatorInput>
  }

  export type DocumentCreateManyCreatorInputEnvelope = {
    data: DocumentCreateManyCreatorInput | DocumentCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DocumentVersionCreateWithoutUploaderInput = {
    id?: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    isCurrent?: boolean
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutVersionsInput
    tenant: TenantCreateNestedOneWithoutDocumentVersionsInput
  }

  export type DocumentVersionUncheckedCreateWithoutUploaderInput = {
    id?: string
    documentId: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentVersionCreateOrConnectWithoutUploaderInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutUploaderInput, DocumentVersionUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentVersionCreateManyUploaderInputEnvelope = {
    data: DocumentVersionCreateManyUploaderInput | DocumentVersionCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ReportTemplateCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportTemplatesInput
    components?: ReportComponentCreateNestedManyWithoutReportTemplateInput
    instances?: ScheduledReportCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutCreatorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ReportComponentUncheckedCreateNestedManyWithoutReportTemplateInput
    instances?: ScheduledReportUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutCreatorInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutCreatorInput, ReportTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type ReportTemplateCreateManyCreatorInputEnvelope = {
    data: ReportTemplateCreateManyCreatorInput | ReportTemplateCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutScheduledReportsInput
    reportTemplate: ReportTemplateCreateNestedOneWithoutInstancesInput
    executions?: ReportExecutionCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportUncheckedCreateWithoutCreatorInput = {
    id?: string
    tenantId: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: ReportExecutionUncheckedCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportCreateOrConnectWithoutCreatorInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutCreatorInput, ScheduledReportUncheckedCreateWithoutCreatorInput>
  }

  export type ScheduledReportCreateManyCreatorInputEnvelope = {
    data: ScheduledReportCreateManyCreatorInput | ScheduledReportCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DocumentReadConfirmationCreateWithoutUserInput = {
    id?: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    document: DocumentCreateNestedOneWithoutReadConfirmationsInput
    tenant: TenantCreateNestedOneWithoutDocumentReadConfirmationsInput
  }

  export type DocumentReadConfirmationUncheckedCreateWithoutUserInput = {
    id?: string
    documentId: string
    tenantId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type DocumentReadConfirmationCreateOrConnectWithoutUserInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    create: XOR<DocumentReadConfirmationCreateWithoutUserInput, DocumentReadConfirmationUncheckedCreateWithoutUserInput>
  }

  export type DocumentReadConfirmationCreateManyUserInputEnvelope = {
    data: DocumentReadConfirmationCreateManyUserInput | DocumentReadConfirmationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AuditTrailUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditTrailWhereUniqueInput
    update: XOR<AuditTrailUpdateWithoutUserInput, AuditTrailUncheckedUpdateWithoutUserInput>
    create: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput>
  }

  export type AuditTrailUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditTrailWhereUniqueInput
    data: XOR<AuditTrailUpdateWithoutUserInput, AuditTrailUncheckedUpdateWithoutUserInput>
  }

  export type AuditTrailUpdateManyWithWhereWithoutUserInput = {
    where: AuditTrailScalarWhereInput
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyWithoutUserInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutUserInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ApprovalUpsertWithWhereUniqueWithoutRequesterInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutRequesterInput, ApprovalUncheckedUpdateWithoutRequesterInput>
    create: XOR<ApprovalCreateWithoutRequesterInput, ApprovalUncheckedCreateWithoutRequesterInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutRequesterInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutRequesterInput, ApprovalUncheckedUpdateWithoutRequesterInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutRequesterInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutRequesterInput>
  }

  export type ApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutApproverInput, ApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutApproverInput, ApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutStartedByUserInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutStartedByUserInput, WorkflowInstanceUncheckedUpdateWithoutStartedByUserInput>
    create: XOR<WorkflowInstanceCreateWithoutStartedByUserInput, WorkflowInstanceUncheckedCreateWithoutStartedByUserInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutStartedByUserInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutStartedByUserInput, WorkflowInstanceUncheckedUpdateWithoutStartedByUserInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutStartedByUserInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserInput>
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutCancelledByUserInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutCancelledByUserInput, WorkflowInstanceUncheckedUpdateWithoutCancelledByUserInput>
    create: XOR<WorkflowInstanceCreateWithoutCancelledByUserInput, WorkflowInstanceUncheckedCreateWithoutCancelledByUserInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutCancelledByUserInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutCancelledByUserInput, WorkflowInstanceUncheckedUpdateWithoutCancelledByUserInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutCancelledByUserInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserInput>
  }

  export type WorkflowStepExecutionUpsertWithWhereUniqueWithoutExecutedByUserInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    update: XOR<WorkflowStepExecutionUpdateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedUpdateWithoutExecutedByUserInput>
    create: XOR<WorkflowStepExecutionCreateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedCreateWithoutExecutedByUserInput>
  }

  export type WorkflowStepExecutionUpdateWithWhereUniqueWithoutExecutedByUserInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    data: XOR<WorkflowStepExecutionUpdateWithoutExecutedByUserInput, WorkflowStepExecutionUncheckedUpdateWithoutExecutedByUserInput>
  }

  export type WorkflowStepExecutionUpdateManyWithWhereWithoutExecutedByUserInput = {
    where: WorkflowStepExecutionScalarWhereInput
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserInput>
  }

  export type WorkflowStepExecutionScalarWhereInput = {
    AND?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
    OR?: WorkflowStepExecutionScalarWhereInput[]
    NOT?: WorkflowStepExecutionScalarWhereInput | WorkflowStepExecutionScalarWhereInput[]
    id?: StringFilter<"WorkflowStepExecution"> | string
    workflowInstanceId?: StringFilter<"WorkflowStepExecution"> | string
    stepOrder?: IntFilter<"WorkflowStepExecution"> | number
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStepExecution"> | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFilter<"WorkflowStepExecution"> | $Enums.WorkflowStatus
    executedBy?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    comments?: StringNullableFilter<"WorkflowStepExecution"> | string | null
    executedAt?: DateTimeNullableFilter<"WorkflowStepExecution"> | Date | string | null
    createdAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStepExecution"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCreatorInput, DocumentUncheckedUpdateWithoutCreatorInput>
    create: XOR<DocumentCreateWithoutCreatorInput, DocumentUncheckedCreateWithoutCreatorInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCreatorInput, DocumentUncheckedUpdateWithoutCreatorInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCreatorInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DocumentVersionUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentVersionWhereUniqueInput
    update: XOR<DocumentVersionUpdateWithoutUploaderInput, DocumentVersionUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentVersionCreateWithoutUploaderInput, DocumentVersionUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentVersionUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentVersionWhereUniqueInput
    data: XOR<DocumentVersionUpdateWithoutUploaderInput, DocumentVersionUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentVersionUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentVersionScalarWhereInput
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyWithoutUploaderInput>
  }

  export type ReportTemplateUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ReportTemplateWhereUniqueInput
    update: XOR<ReportTemplateUpdateWithoutCreatorInput, ReportTemplateUncheckedUpdateWithoutCreatorInput>
    create: XOR<ReportTemplateCreateWithoutCreatorInput, ReportTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type ReportTemplateUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ReportTemplateWhereUniqueInput
    data: XOR<ReportTemplateUpdateWithoutCreatorInput, ReportTemplateUncheckedUpdateWithoutCreatorInput>
  }

  export type ReportTemplateUpdateManyWithWhereWithoutCreatorInput = {
    where: ReportTemplateScalarWhereInput
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutCreatorInput, ScheduledReportUncheckedUpdateWithoutCreatorInput>
    create: XOR<ScheduledReportCreateWithoutCreatorInput, ScheduledReportUncheckedCreateWithoutCreatorInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutCreatorInput, ScheduledReportUncheckedUpdateWithoutCreatorInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutCreatorInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DocumentReadConfirmationUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    update: XOR<DocumentReadConfirmationUpdateWithoutUserInput, DocumentReadConfirmationUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentReadConfirmationCreateWithoutUserInput, DocumentReadConfirmationUncheckedCreateWithoutUserInput>
  }

  export type DocumentReadConfirmationUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    data: XOR<DocumentReadConfirmationUpdateWithoutUserInput, DocumentReadConfirmationUncheckedUpdateWithoutUserInput>
  }

  export type DocumentReadConfirmationUpdateManyWithWhereWithoutUserInput = {
    where: DocumentReadConfirmationScalarWhereInput
    data: XOR<DocumentReadConfirmationUpdateManyMutationInput, DocumentReadConfirmationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutInternalAuditsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInternalAuditsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInternalAuditsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInternalAuditsInput, TenantUncheckedCreateWithoutInternalAuditsInput>
  }

  export type AuditProgramCreateWithoutInternalAuditsInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditProgramsInput
    template?: AuditProgramCreateNestedOneWithoutDerivativesInput
    derivatives?: AuditProgramCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateWithoutInternalAuditsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    derivatives?: AuditProgramUncheckedCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramCreateOrConnectWithoutInternalAuditsInput = {
    where: AuditProgramWhereUniqueInput
    create: XOR<AuditProgramCreateWithoutInternalAuditsInput, AuditProgramUncheckedCreateWithoutInternalAuditsInput>
  }

  export type TenantUpsertWithoutInternalAuditsInput = {
    update: XOR<TenantUpdateWithoutInternalAuditsInput, TenantUncheckedUpdateWithoutInternalAuditsInput>
    create: XOR<TenantCreateWithoutInternalAuditsInput, TenantUncheckedCreateWithoutInternalAuditsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInternalAuditsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInternalAuditsInput, TenantUncheckedUpdateWithoutInternalAuditsInput>
  }

  export type TenantUpdateWithoutInternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AuditProgramUpsertWithoutInternalAuditsInput = {
    update: XOR<AuditProgramUpdateWithoutInternalAuditsInput, AuditProgramUncheckedUpdateWithoutInternalAuditsInput>
    create: XOR<AuditProgramCreateWithoutInternalAuditsInput, AuditProgramUncheckedCreateWithoutInternalAuditsInput>
    where?: AuditProgramWhereInput
  }

  export type AuditProgramUpdateToOneWithWhereWithoutInternalAuditsInput = {
    where?: AuditProgramWhereInput
    data: XOR<AuditProgramUpdateWithoutInternalAuditsInput, AuditProgramUncheckedUpdateWithoutInternalAuditsInput>
  }

  export type AuditProgramUpdateWithoutInternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditProgramsNestedInput
    template?: AuditProgramUpdateOneWithoutDerivativesNestedInput
    derivatives?: AuditProgramUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateWithoutInternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    derivatives?: AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type TenantCreateWithoutExternalAuditsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutExternalAuditsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutExternalAuditsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutExternalAuditsInput, TenantUncheckedCreateWithoutExternalAuditsInput>
  }

  export type AuditProgramCreateWithoutExternalAuditsInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditProgramsInput
    template?: AuditProgramCreateNestedOneWithoutDerivativesInput
    derivatives?: AuditProgramCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateWithoutExternalAuditsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    derivatives?: AuditProgramUncheckedCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramCreateOrConnectWithoutExternalAuditsInput = {
    where: AuditProgramWhereUniqueInput
    create: XOR<AuditProgramCreateWithoutExternalAuditsInput, AuditProgramUncheckedCreateWithoutExternalAuditsInput>
  }

  export type TenantUpsertWithoutExternalAuditsInput = {
    update: XOR<TenantUpdateWithoutExternalAuditsInput, TenantUncheckedUpdateWithoutExternalAuditsInput>
    create: XOR<TenantCreateWithoutExternalAuditsInput, TenantUncheckedCreateWithoutExternalAuditsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutExternalAuditsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutExternalAuditsInput, TenantUncheckedUpdateWithoutExternalAuditsInput>
  }

  export type TenantUpdateWithoutExternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutExternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AuditProgramUpsertWithoutExternalAuditsInput = {
    update: XOR<AuditProgramUpdateWithoutExternalAuditsInput, AuditProgramUncheckedUpdateWithoutExternalAuditsInput>
    create: XOR<AuditProgramCreateWithoutExternalAuditsInput, AuditProgramUncheckedCreateWithoutExternalAuditsInput>
    where?: AuditProgramWhereInput
  }

  export type AuditProgramUpdateToOneWithWhereWithoutExternalAuditsInput = {
    where?: AuditProgramWhereInput
    data: XOR<AuditProgramUpdateWithoutExternalAuditsInput, AuditProgramUncheckedUpdateWithoutExternalAuditsInput>
  }

  export type AuditProgramUpdateWithoutExternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditProgramsNestedInput
    template?: AuditProgramUpdateOneWithoutDerivativesNestedInput
    derivatives?: AuditProgramUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateWithoutExternalAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    derivatives?: AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type TenantCreateWithoutAuditProgramsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditProgramsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditProgramsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditProgramsInput, TenantUncheckedCreateWithoutAuditProgramsInput>
  }

  export type AuditProgramCreateWithoutDerivativesInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditProgramsInput
    template?: AuditProgramCreateNestedOneWithoutDerivativesInput
    checklists?: AuditChecklistCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateWithoutDerivativesInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checklists?: AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramCreateOrConnectWithoutDerivativesInput = {
    where: AuditProgramWhereUniqueInput
    create: XOR<AuditProgramCreateWithoutDerivativesInput, AuditProgramUncheckedCreateWithoutDerivativesInput>
  }

  export type AuditProgramCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditProgramsInput
    derivatives?: AuditProgramCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateWithoutTemplateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    derivatives?: AuditProgramUncheckedCreateNestedManyWithoutTemplateInput
    checklists?: AuditChecklistUncheckedCreateNestedManyWithoutAuditProgramInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramCreateOrConnectWithoutTemplateInput = {
    where: AuditProgramWhereUniqueInput
    create: XOR<AuditProgramCreateWithoutTemplateInput, AuditProgramUncheckedCreateWithoutTemplateInput>
  }

  export type AuditProgramCreateManyTemplateInputEnvelope = {
    data: AuditProgramCreateManyTemplateInput | AuditProgramCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type AuditChecklistCreateWithoutAuditProgramInput = {
    id?: string
    clause: string
    item: string
    requirement?: string | null
    evidenceType?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditChecklistUncheckedCreateWithoutAuditProgramInput = {
    id?: string
    clause: string
    item: string
    requirement?: string | null
    evidenceType?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditChecklistCreateOrConnectWithoutAuditProgramInput = {
    where: AuditChecklistWhereUniqueInput
    create: XOR<AuditChecklistCreateWithoutAuditProgramInput, AuditChecklistUncheckedCreateWithoutAuditProgramInput>
  }

  export type AuditChecklistCreateManyAuditProgramInputEnvelope = {
    data: AuditChecklistCreateManyAuditProgramInput | AuditChecklistCreateManyAuditProgramInput[]
    skipDuplicates?: boolean
  }

  export type InternalAuditCreateWithoutAuditProgramInput = {
    id?: string
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInternalAuditsInput
  }

  export type InternalAuditUncheckedCreateWithoutAuditProgramInput = {
    id?: string
    tenantId: string
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalAuditCreateOrConnectWithoutAuditProgramInput = {
    where: InternalAuditWhereUniqueInput
    create: XOR<InternalAuditCreateWithoutAuditProgramInput, InternalAuditUncheckedCreateWithoutAuditProgramInput>
  }

  export type InternalAuditCreateManyAuditProgramInputEnvelope = {
    data: InternalAuditCreateManyAuditProgramInput | InternalAuditCreateManyAuditProgramInput[]
    skipDuplicates?: boolean
  }

  export type ExternalAuditCreateWithoutAuditProgramInput = {
    id?: string
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExternalAuditsInput
  }

  export type ExternalAuditUncheckedCreateWithoutAuditProgramInput = {
    id?: string
    tenantId: string
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuditCreateOrConnectWithoutAuditProgramInput = {
    where: ExternalAuditWhereUniqueInput
    create: XOR<ExternalAuditCreateWithoutAuditProgramInput, ExternalAuditUncheckedCreateWithoutAuditProgramInput>
  }

  export type ExternalAuditCreateManyAuditProgramInputEnvelope = {
    data: ExternalAuditCreateManyAuditProgramInput | ExternalAuditCreateManyAuditProgramInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAuditProgramsInput = {
    update: XOR<TenantUpdateWithoutAuditProgramsInput, TenantUncheckedUpdateWithoutAuditProgramsInput>
    create: XOR<TenantCreateWithoutAuditProgramsInput, TenantUncheckedCreateWithoutAuditProgramsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditProgramsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditProgramsInput, TenantUncheckedUpdateWithoutAuditProgramsInput>
  }

  export type TenantUpdateWithoutAuditProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AuditProgramUpsertWithoutDerivativesInput = {
    update: XOR<AuditProgramUpdateWithoutDerivativesInput, AuditProgramUncheckedUpdateWithoutDerivativesInput>
    create: XOR<AuditProgramCreateWithoutDerivativesInput, AuditProgramUncheckedCreateWithoutDerivativesInput>
    where?: AuditProgramWhereInput
  }

  export type AuditProgramUpdateToOneWithWhereWithoutDerivativesInput = {
    where?: AuditProgramWhereInput
    data: XOR<AuditProgramUpdateWithoutDerivativesInput, AuditProgramUncheckedUpdateWithoutDerivativesInput>
  }

  export type AuditProgramUpdateWithoutDerivativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditProgramsNestedInput
    template?: AuditProgramUpdateOneWithoutDerivativesNestedInput
    checklists?: AuditChecklistUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateWithoutDerivativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklists?: AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUpsertWithWhereUniqueWithoutTemplateInput = {
    where: AuditProgramWhereUniqueInput
    update: XOR<AuditProgramUpdateWithoutTemplateInput, AuditProgramUncheckedUpdateWithoutTemplateInput>
    create: XOR<AuditProgramCreateWithoutTemplateInput, AuditProgramUncheckedCreateWithoutTemplateInput>
  }

  export type AuditProgramUpdateWithWhereUniqueWithoutTemplateInput = {
    where: AuditProgramWhereUniqueInput
    data: XOR<AuditProgramUpdateWithoutTemplateInput, AuditProgramUncheckedUpdateWithoutTemplateInput>
  }

  export type AuditProgramUpdateManyWithWhereWithoutTemplateInput = {
    where: AuditProgramScalarWhereInput
    data: XOR<AuditProgramUpdateManyMutationInput, AuditProgramUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AuditChecklistUpsertWithWhereUniqueWithoutAuditProgramInput = {
    where: AuditChecklistWhereUniqueInput
    update: XOR<AuditChecklistUpdateWithoutAuditProgramInput, AuditChecklistUncheckedUpdateWithoutAuditProgramInput>
    create: XOR<AuditChecklistCreateWithoutAuditProgramInput, AuditChecklistUncheckedCreateWithoutAuditProgramInput>
  }

  export type AuditChecklistUpdateWithWhereUniqueWithoutAuditProgramInput = {
    where: AuditChecklistWhereUniqueInput
    data: XOR<AuditChecklistUpdateWithoutAuditProgramInput, AuditChecklistUncheckedUpdateWithoutAuditProgramInput>
  }

  export type AuditChecklistUpdateManyWithWhereWithoutAuditProgramInput = {
    where: AuditChecklistScalarWhereInput
    data: XOR<AuditChecklistUpdateManyMutationInput, AuditChecklistUncheckedUpdateManyWithoutAuditProgramInput>
  }

  export type AuditChecklistScalarWhereInput = {
    AND?: AuditChecklistScalarWhereInput | AuditChecklistScalarWhereInput[]
    OR?: AuditChecklistScalarWhereInput[]
    NOT?: AuditChecklistScalarWhereInput | AuditChecklistScalarWhereInput[]
    id?: StringFilter<"AuditChecklist"> | string
    auditProgramId?: StringFilter<"AuditChecklist"> | string
    clause?: StringFilter<"AuditChecklist"> | string
    item?: StringFilter<"AuditChecklist"> | string
    requirement?: StringNullableFilter<"AuditChecklist"> | string | null
    evidenceType?: StringNullableFilter<"AuditChecklist"> | string | null
    order?: IntFilter<"AuditChecklist"> | number
    createdAt?: DateTimeFilter<"AuditChecklist"> | Date | string
    updatedAt?: DateTimeFilter<"AuditChecklist"> | Date | string
  }

  export type InternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput = {
    where: InternalAuditWhereUniqueInput
    update: XOR<InternalAuditUpdateWithoutAuditProgramInput, InternalAuditUncheckedUpdateWithoutAuditProgramInput>
    create: XOR<InternalAuditCreateWithoutAuditProgramInput, InternalAuditUncheckedCreateWithoutAuditProgramInput>
  }

  export type InternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput = {
    where: InternalAuditWhereUniqueInput
    data: XOR<InternalAuditUpdateWithoutAuditProgramInput, InternalAuditUncheckedUpdateWithoutAuditProgramInput>
  }

  export type InternalAuditUpdateManyWithWhereWithoutAuditProgramInput = {
    where: InternalAuditScalarWhereInput
    data: XOR<InternalAuditUpdateManyMutationInput, InternalAuditUncheckedUpdateManyWithoutAuditProgramInput>
  }

  export type ExternalAuditUpsertWithWhereUniqueWithoutAuditProgramInput = {
    where: ExternalAuditWhereUniqueInput
    update: XOR<ExternalAuditUpdateWithoutAuditProgramInput, ExternalAuditUncheckedUpdateWithoutAuditProgramInput>
    create: XOR<ExternalAuditCreateWithoutAuditProgramInput, ExternalAuditUncheckedCreateWithoutAuditProgramInput>
  }

  export type ExternalAuditUpdateWithWhereUniqueWithoutAuditProgramInput = {
    where: ExternalAuditWhereUniqueInput
    data: XOR<ExternalAuditUpdateWithoutAuditProgramInput, ExternalAuditUncheckedUpdateWithoutAuditProgramInput>
  }

  export type ExternalAuditUpdateManyWithWhereWithoutAuditProgramInput = {
    where: ExternalAuditScalarWhereInput
    data: XOR<ExternalAuditUpdateManyMutationInput, ExternalAuditUncheckedUpdateManyWithoutAuditProgramInput>
  }

  export type AuditProgramCreateWithoutChecklistsInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditProgramsInput
    template?: AuditProgramCreateNestedOneWithoutDerivativesInput
    derivatives?: AuditProgramCreateNestedManyWithoutTemplateInput
    internalAudits?: InternalAuditCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramUncheckedCreateWithoutChecklistsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    derivatives?: AuditProgramUncheckedCreateNestedManyWithoutTemplateInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutAuditProgramInput
  }

  export type AuditProgramCreateOrConnectWithoutChecklistsInput = {
    where: AuditProgramWhereUniqueInput
    create: XOR<AuditProgramCreateWithoutChecklistsInput, AuditProgramUncheckedCreateWithoutChecklistsInput>
  }

  export type AuditProgramUpsertWithoutChecklistsInput = {
    update: XOR<AuditProgramUpdateWithoutChecklistsInput, AuditProgramUncheckedUpdateWithoutChecklistsInput>
    create: XOR<AuditProgramCreateWithoutChecklistsInput, AuditProgramUncheckedCreateWithoutChecklistsInput>
    where?: AuditProgramWhereInput
  }

  export type AuditProgramUpdateToOneWithWhereWithoutChecklistsInput = {
    where?: AuditProgramWhereInput
    data: XOR<AuditProgramUpdateWithoutChecklistsInput, AuditProgramUncheckedUpdateWithoutChecklistsInput>
  }

  export type AuditProgramUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditProgramsNestedInput
    template?: AuditProgramUpdateOneWithoutDerivativesNestedInput
    derivatives?: AuditProgramUpdateManyWithoutTemplateNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    derivatives?: AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type TenantCreateWithoutActionItemsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutActionItemsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutActionItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutActionItemsInput, TenantUncheckedCreateWithoutActionItemsInput>
  }

  export type RootCauseAnalysisCreateWithoutActionItemInput = {
    id?: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRootCauseAnalysesInput
  }

  export type RootCauseAnalysisUncheckedCreateWithoutActionItemInput = {
    id?: string
    tenantId: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RootCauseAnalysisCreateOrConnectWithoutActionItemInput = {
    where: RootCauseAnalysisWhereUniqueInput
    create: XOR<RootCauseAnalysisCreateWithoutActionItemInput, RootCauseAnalysisUncheckedCreateWithoutActionItemInput>
  }

  export type TenantUpsertWithoutActionItemsInput = {
    update: XOR<TenantUpdateWithoutActionItemsInput, TenantUncheckedUpdateWithoutActionItemsInput>
    create: XOR<TenantCreateWithoutActionItemsInput, TenantUncheckedCreateWithoutActionItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutActionItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutActionItemsInput, TenantUncheckedUpdateWithoutActionItemsInput>
  }

  export type TenantUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RootCauseAnalysisUpsertWithoutActionItemInput = {
    update: XOR<RootCauseAnalysisUpdateWithoutActionItemInput, RootCauseAnalysisUncheckedUpdateWithoutActionItemInput>
    create: XOR<RootCauseAnalysisCreateWithoutActionItemInput, RootCauseAnalysisUncheckedCreateWithoutActionItemInput>
    where?: RootCauseAnalysisWhereInput
  }

  export type RootCauseAnalysisUpdateToOneWithWhereWithoutActionItemInput = {
    where?: RootCauseAnalysisWhereInput
    data: XOR<RootCauseAnalysisUpdateWithoutActionItemInput, RootCauseAnalysisUncheckedUpdateWithoutActionItemInput>
  }

  export type RootCauseAnalysisUpdateWithoutActionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRootCauseAnalysesNestedInput
  }

  export type RootCauseAnalysisUncheckedUpdateWithoutActionItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemCreateWithoutRootCauseAnalysisInput = {
    id?: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutActionItemsInput
  }

  export type ActionItemUncheckedCreateWithoutRootCauseAnalysisInput = {
    id?: string
    tenantId: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemCreateOrConnectWithoutRootCauseAnalysisInput = {
    where: ActionItemWhereUniqueInput
    create: XOR<ActionItemCreateWithoutRootCauseAnalysisInput, ActionItemUncheckedCreateWithoutRootCauseAnalysisInput>
  }

  export type TenantCreateWithoutRootCauseAnalysesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRootCauseAnalysesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRootCauseAnalysesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRootCauseAnalysesInput, TenantUncheckedCreateWithoutRootCauseAnalysesInput>
  }

  export type ActionItemUpsertWithoutRootCauseAnalysisInput = {
    update: XOR<ActionItemUpdateWithoutRootCauseAnalysisInput, ActionItemUncheckedUpdateWithoutRootCauseAnalysisInput>
    create: XOR<ActionItemCreateWithoutRootCauseAnalysisInput, ActionItemUncheckedCreateWithoutRootCauseAnalysisInput>
    where?: ActionItemWhereInput
  }

  export type ActionItemUpdateToOneWithWhereWithoutRootCauseAnalysisInput = {
    where?: ActionItemWhereInput
    data: XOR<ActionItemUpdateWithoutRootCauseAnalysisInput, ActionItemUncheckedUpdateWithoutRootCauseAnalysisInput>
  }

  export type ActionItemUpdateWithoutRootCauseAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutActionItemsNestedInput
  }

  export type ActionItemUncheckedUpdateWithoutRootCauseAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutRootCauseAnalysesInput = {
    update: XOR<TenantUpdateWithoutRootCauseAnalysesInput, TenantUncheckedUpdateWithoutRootCauseAnalysesInput>
    create: XOR<TenantCreateWithoutRootCauseAnalysesInput, TenantUncheckedCreateWithoutRootCauseAnalysesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRootCauseAnalysesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRootCauseAnalysesInput, TenantUncheckedUpdateWithoutRootCauseAnalysesInput>
  }

  export type TenantUpdateWithoutRootCauseAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRootCauseAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutOccurrencesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOccurrencesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOccurrencesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOccurrencesInput, TenantUncheckedCreateWithoutOccurrencesInput>
  }

  export type TenantUpsertWithoutOccurrencesInput = {
    update: XOR<TenantUpdateWithoutOccurrencesInput, TenantUncheckedUpdateWithoutOccurrencesInput>
    create: XOR<TenantCreateWithoutOccurrencesInput, TenantUncheckedCreateWithoutOccurrencesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOccurrencesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOccurrencesInput, TenantUncheckedUpdateWithoutOccurrencesInput>
  }

  export type TenantUpdateWithoutOccurrencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOccurrencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSectorsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSectorsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSectorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSectorsInput, TenantUncheckedCreateWithoutSectorsInput>
  }

  export type TenantUpsertWithoutSectorsInput = {
    update: XOR<TenantUpdateWithoutSectorsInput, TenantUncheckedUpdateWithoutSectorsInput>
    create: XOR<TenantCreateWithoutSectorsInput, TenantUncheckedCreateWithoutSectorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSectorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSectorsInput, TenantUncheckedUpdateWithoutSectorsInput>
  }

  export type TenantUpdateWithoutSectorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSectorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutImportLogsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutImportLogsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutImportLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutImportLogsInput, TenantUncheckedCreateWithoutImportLogsInput>
  }

  export type TenantUpsertWithoutImportLogsInput = {
    update: XOR<TenantUpdateWithoutImportLogsInput, TenantUncheckedUpdateWithoutImportLogsInput>
    create: XOR<TenantCreateWithoutImportLogsInput, TenantUncheckedCreateWithoutImportLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutImportLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutImportLogsInput, TenantUncheckedUpdateWithoutImportLogsInput>
  }

  export type TenantUpdateWithoutImportLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutImportLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAuditTrailsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditTrailsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditTrailsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditTrailsInput, TenantUncheckedCreateWithoutAuditTrailsInput>
  }

  export type UserCreateWithoutAuditTrailsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditTrailsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditTrailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
  }

  export type TenantUpsertWithoutAuditTrailsInput = {
    update: XOR<TenantUpdateWithoutAuditTrailsInput, TenantUncheckedUpdateWithoutAuditTrailsInput>
    create: XOR<TenantCreateWithoutAuditTrailsInput, TenantUncheckedCreateWithoutAuditTrailsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditTrailsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditTrailsInput, TenantUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type TenantUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditTrailsInput = {
    update: XOR<UserUpdateWithoutAuditTrailsInput, UserUncheckedUpdateWithoutAuditTrailsInput>
    create: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditTrailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditTrailsInput, UserUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type UserUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAttachmentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAttachmentsInput, TenantUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
  }

  export type TenantUpsertWithoutAttachmentsInput = {
    update: XOR<TenantUpdateWithoutAttachmentsInput, TenantUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TenantCreateWithoutAttachmentsInput, TenantUncheckedCreateWithoutAttachmentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAttachmentsInput, TenantUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TenantUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAttachmentsInput = {
    update: XOR<UserUpdateWithoutAttachmentsInput, UserUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<UserCreateWithoutAttachmentsInput, UserUncheckedCreateWithoutAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttachmentsInput, UserUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutCommentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCommentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCommentsInput, TenantUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type TenantUpsertWithoutCommentsInput = {
    update: XOR<TenantUpdateWithoutCommentsInput, TenantUncheckedUpdateWithoutCommentsInput>
    create: XOR<TenantCreateWithoutCommentsInput, TenantUncheckedCreateWithoutCommentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCommentsInput, TenantUncheckedUpdateWithoutCommentsInput>
  }

  export type TenantUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutApprovalsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutApprovalsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutApprovalsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutApprovalsInput, TenantUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutApprovalRequestsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovalRequestsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovalRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
  }

  export type UserCreateWithoutApprovalApprovalsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovalApprovalsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovalApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalApprovalsInput, UserUncheckedCreateWithoutApprovalApprovalsInput>
  }

  export type TenantUpsertWithoutApprovalsInput = {
    update: XOR<TenantUpdateWithoutApprovalsInput, TenantUncheckedUpdateWithoutApprovalsInput>
    create: XOR<TenantCreateWithoutApprovalsInput, TenantUncheckedCreateWithoutApprovalsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutApprovalsInput, TenantUncheckedUpdateWithoutApprovalsInput>
  }

  export type TenantUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutApprovalRequestsInput = {
    update: XOR<UserUpdateWithoutApprovalRequestsInput, UserUncheckedUpdateWithoutApprovalRequestsInput>
    create: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalRequestsInput, UserUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type UserUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutApprovalApprovalsInput = {
    update: XOR<UserUpdateWithoutApprovalApprovalsInput, UserUncheckedUpdateWithoutApprovalApprovalsInput>
    create: XOR<UserCreateWithoutApprovalApprovalsInput, UserUncheckedCreateWithoutApprovalApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalApprovalsInput, UserUncheckedUpdateWithoutApprovalApprovalsInput>
  }

  export type UserUpdateWithoutApprovalApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutWorkflowDefinitionsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWorkflowDefinitionsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWorkflowDefinitionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWorkflowDefinitionsInput, TenantUncheckedCreateWithoutWorkflowDefinitionsInput>
  }

  export type WorkflowStepCreateWithoutWorkflowDefinitionInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description?: string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: string | null
    autoAdvance?: boolean
    timeoutDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description?: string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: string | null
    autoAdvance?: boolean
    timeoutDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepCreateOrConnectWithoutWorkflowDefinitionInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput>
  }

  export type WorkflowStepCreateManyWorkflowDefinitionInputEnvelope = {
    data: WorkflowStepCreateManyWorkflowDefinitionInput | WorkflowStepCreateManyWorkflowDefinitionInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutWorkflowDefinitionInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowInstancesInput
    startedByUser: UserCreateNestedOneWithoutWorkflowInstancesInput
    cancelledByUser?: UserCreateNestedOneWithoutWorkflowCancelledInput
    stepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutWorkflowDefinitionInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput>
  }

  export type WorkflowInstanceCreateManyWorkflowDefinitionInputEnvelope = {
    data: WorkflowInstanceCreateManyWorkflowDefinitionInput | WorkflowInstanceCreateManyWorkflowDefinitionInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutWorkflowDefinitionsInput = {
    update: XOR<TenantUpdateWithoutWorkflowDefinitionsInput, TenantUncheckedUpdateWithoutWorkflowDefinitionsInput>
    create: XOR<TenantCreateWithoutWorkflowDefinitionsInput, TenantUncheckedCreateWithoutWorkflowDefinitionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWorkflowDefinitionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWorkflowDefinitionsInput, TenantUncheckedUpdateWithoutWorkflowDefinitionsInput>
  }

  export type TenantUpdateWithoutWorkflowDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWorkflowDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type WorkflowStepUpsertWithWhereUniqueWithoutWorkflowDefinitionInput = {
    where: WorkflowStepWhereUniqueInput
    update: XOR<WorkflowStepUpdateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedUpdateWithoutWorkflowDefinitionInput>
    create: XOR<WorkflowStepCreateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedCreateWithoutWorkflowDefinitionInput>
  }

  export type WorkflowStepUpdateWithWhereUniqueWithoutWorkflowDefinitionInput = {
    where: WorkflowStepWhereUniqueInput
    data: XOR<WorkflowStepUpdateWithoutWorkflowDefinitionInput, WorkflowStepUncheckedUpdateWithoutWorkflowDefinitionInput>
  }

  export type WorkflowStepUpdateManyWithWhereWithoutWorkflowDefinitionInput = {
    where: WorkflowStepScalarWhereInput
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyWithoutWorkflowDefinitionInput>
  }

  export type WorkflowStepScalarWhereInput = {
    AND?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    OR?: WorkflowStepScalarWhereInput[]
    NOT?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    workflowDefinitionId?: StringFilter<"WorkflowStep"> | string
    stepOrder?: IntFilter<"WorkflowStep"> | number
    stepType?: EnumWorkflowStepTypeFilter<"WorkflowStep"> | $Enums.WorkflowStepType
    name?: StringFilter<"WorkflowStep"> | string
    description?: StringNullableFilter<"WorkflowStep"> | string | null
    requiredRoles?: JsonFilter<"WorkflowStep">
    requiredUsers?: JsonFilter<"WorkflowStep">
    conditionExpression?: JsonNullableFilter<"WorkflowStep">
    notificationTemplate?: StringNullableFilter<"WorkflowStep"> | string | null
    autoAdvance?: BoolFilter<"WorkflowStep"> | boolean
    timeoutDays?: IntNullableFilter<"WorkflowStep"> | number | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowStep"> | Date | string
  }

  export type WorkflowInstanceUpsertWithWhereUniqueWithoutWorkflowDefinitionInput = {
    where: WorkflowInstanceWhereUniqueInput
    update: XOR<WorkflowInstanceUpdateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedUpdateWithoutWorkflowDefinitionInput>
    create: XOR<WorkflowInstanceCreateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedCreateWithoutWorkflowDefinitionInput>
  }

  export type WorkflowInstanceUpdateWithWhereUniqueWithoutWorkflowDefinitionInput = {
    where: WorkflowInstanceWhereUniqueInput
    data: XOR<WorkflowInstanceUpdateWithoutWorkflowDefinitionInput, WorkflowInstanceUncheckedUpdateWithoutWorkflowDefinitionInput>
  }

  export type WorkflowInstanceUpdateManyWithWhereWithoutWorkflowDefinitionInput = {
    where: WorkflowInstanceScalarWhereInput
    data: XOR<WorkflowInstanceUpdateManyMutationInput, WorkflowInstanceUncheckedUpdateManyWithoutWorkflowDefinitionInput>
  }

  export type WorkflowDefinitionCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowDefinitionsInput
    instances?: WorkflowInstanceCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutStepsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: WorkflowInstanceUncheckedCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutStepsInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
  }

  export type WorkflowDefinitionUpsertWithoutStepsInput = {
    update: XOR<WorkflowDefinitionUpdateWithoutStepsInput, WorkflowDefinitionUncheckedUpdateWithoutStepsInput>
    create: XOR<WorkflowDefinitionCreateWithoutStepsInput, WorkflowDefinitionUncheckedCreateWithoutStepsInput>
    where?: WorkflowDefinitionWhereInput
  }

  export type WorkflowDefinitionUpdateToOneWithWhereWithoutStepsInput = {
    where?: WorkflowDefinitionWhereInput
    data: XOR<WorkflowDefinitionUpdateWithoutStepsInput, WorkflowDefinitionUncheckedUpdateWithoutStepsInput>
  }

  export type WorkflowDefinitionUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowDefinitionsNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type TenantCreateWithoutWorkflowInstancesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWorkflowInstancesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWorkflowInstancesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWorkflowInstancesInput, TenantUncheckedCreateWithoutWorkflowInstancesInput>
  }

  export type WorkflowDefinitionCreateWithoutInstancesInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowDefinitionsInput
    steps?: WorkflowStepCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionUncheckedCreateWithoutInstancesInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: WorkflowStepUncheckedCreateNestedManyWithoutWorkflowDefinitionInput
  }

  export type WorkflowDefinitionCreateOrConnectWithoutInstancesInput = {
    where: WorkflowDefinitionWhereUniqueInput
    create: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
  }

  export type UserCreateWithoutWorkflowInstancesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowInstancesInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowInstancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowInstancesInput, UserUncheckedCreateWithoutWorkflowInstancesInput>
  }

  export type UserCreateWithoutWorkflowCancelledInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowCancelledInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowCancelledInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowCancelledInput, UserUncheckedCreateWithoutWorkflowCancelledInput>
  }

  export type WorkflowStepExecutionCreateWithoutWorkflowInstanceInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executedByUser?: UserCreateNestedOneWithoutWorkflowStepExecutionsInput
  }

  export type WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    executedBy?: string | null
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepExecutionCreateOrConnectWithoutWorkflowInstanceInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    create: XOR<WorkflowStepExecutionCreateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput>
  }

  export type WorkflowStepExecutionCreateManyWorkflowInstanceInputEnvelope = {
    data: WorkflowStepExecutionCreateManyWorkflowInstanceInput | WorkflowStepExecutionCreateManyWorkflowInstanceInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutWorkflowInstanceInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    creator: UserCreateNestedOneWithoutCreatedDocumentsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutWorkflowInstanceInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutWorkflowInstanceInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutWorkflowInstanceInput, DocumentUncheckedCreateWithoutWorkflowInstanceInput>
  }

  export type DocumentCreateManyWorkflowInstanceInputEnvelope = {
    data: DocumentCreateManyWorkflowInstanceInput | DocumentCreateManyWorkflowInstanceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutWorkflowInstancesInput = {
    update: XOR<TenantUpdateWithoutWorkflowInstancesInput, TenantUncheckedUpdateWithoutWorkflowInstancesInput>
    create: XOR<TenantCreateWithoutWorkflowInstancesInput, TenantUncheckedCreateWithoutWorkflowInstancesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWorkflowInstancesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWorkflowInstancesInput, TenantUncheckedUpdateWithoutWorkflowInstancesInput>
  }

  export type TenantUpdateWithoutWorkflowInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWorkflowInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type WorkflowDefinitionUpsertWithoutInstancesInput = {
    update: XOR<WorkflowDefinitionUpdateWithoutInstancesInput, WorkflowDefinitionUncheckedUpdateWithoutInstancesInput>
    create: XOR<WorkflowDefinitionCreateWithoutInstancesInput, WorkflowDefinitionUncheckedCreateWithoutInstancesInput>
    where?: WorkflowDefinitionWhereInput
  }

  export type WorkflowDefinitionUpdateToOneWithWhereWithoutInstancesInput = {
    where?: WorkflowDefinitionWhereInput
    data: XOR<WorkflowDefinitionUpdateWithoutInstancesInput, WorkflowDefinitionUncheckedUpdateWithoutInstancesInput>
  }

  export type WorkflowDefinitionUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowDefinitionsNestedInput
    steps?: WorkflowStepUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type UserUpsertWithoutWorkflowInstancesInput = {
    update: XOR<UserUpdateWithoutWorkflowInstancesInput, UserUncheckedUpdateWithoutWorkflowInstancesInput>
    create: XOR<UserCreateWithoutWorkflowInstancesInput, UserUncheckedCreateWithoutWorkflowInstancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowInstancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowInstancesInput, UserUncheckedUpdateWithoutWorkflowInstancesInput>
  }

  export type UserUpdateWithoutWorkflowInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutWorkflowCancelledInput = {
    update: XOR<UserUpdateWithoutWorkflowCancelledInput, UserUncheckedUpdateWithoutWorkflowCancelledInput>
    create: XOR<UserCreateWithoutWorkflowCancelledInput, UserUncheckedCreateWithoutWorkflowCancelledInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowCancelledInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowCancelledInput, UserUncheckedUpdateWithoutWorkflowCancelledInput>
  }

  export type UserUpdateWithoutWorkflowCancelledInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowCancelledInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkflowStepExecutionUpsertWithWhereUniqueWithoutWorkflowInstanceInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    update: XOR<WorkflowStepExecutionUpdateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedUpdateWithoutWorkflowInstanceInput>
    create: XOR<WorkflowStepExecutionCreateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedCreateWithoutWorkflowInstanceInput>
  }

  export type WorkflowStepExecutionUpdateWithWhereUniqueWithoutWorkflowInstanceInput = {
    where: WorkflowStepExecutionWhereUniqueInput
    data: XOR<WorkflowStepExecutionUpdateWithoutWorkflowInstanceInput, WorkflowStepExecutionUncheckedUpdateWithoutWorkflowInstanceInput>
  }

  export type WorkflowStepExecutionUpdateManyWithWhereWithoutWorkflowInstanceInput = {
    where: WorkflowStepExecutionScalarWhereInput
    data: XOR<WorkflowStepExecutionUpdateManyMutationInput, WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutWorkflowInstanceInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutWorkflowInstanceInput, DocumentUncheckedUpdateWithoutWorkflowInstanceInput>
    create: XOR<DocumentCreateWithoutWorkflowInstanceInput, DocumentUncheckedCreateWithoutWorkflowInstanceInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutWorkflowInstanceInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutWorkflowInstanceInput, DocumentUncheckedUpdateWithoutWorkflowInstanceInput>
  }

  export type DocumentUpdateManyWithWhereWithoutWorkflowInstanceInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutWorkflowInstanceInput>
  }

  export type WorkflowInstanceCreateWithoutStepExecutionsInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowInstancesInput
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    startedByUser: UserCreateNestedOneWithoutWorkflowInstancesInput
    cancelledByUser?: UserCreateNestedOneWithoutWorkflowCancelledInput
    documents?: DocumentCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutStepExecutionsInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutStepExecutionsInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutStepExecutionsInput, WorkflowInstanceUncheckedCreateWithoutStepExecutionsInput>
  }

  export type UserCreateWithoutWorkflowStepExecutionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowStepExecutionsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowStepExecutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowStepExecutionsInput, UserUncheckedCreateWithoutWorkflowStepExecutionsInput>
  }

  export type WorkflowInstanceUpsertWithoutStepExecutionsInput = {
    update: XOR<WorkflowInstanceUpdateWithoutStepExecutionsInput, WorkflowInstanceUncheckedUpdateWithoutStepExecutionsInput>
    create: XOR<WorkflowInstanceCreateWithoutStepExecutionsInput, WorkflowInstanceUncheckedCreateWithoutStepExecutionsInput>
    where?: WorkflowInstanceWhereInput
  }

  export type WorkflowInstanceUpdateToOneWithWhereWithoutStepExecutionsInput = {
    where?: WorkflowInstanceWhereInput
    data: XOR<WorkflowInstanceUpdateWithoutStepExecutionsInput, WorkflowInstanceUncheckedUpdateWithoutStepExecutionsInput>
  }

  export type WorkflowInstanceUpdateWithoutStepExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    startedByUser?: UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    cancelledByUser?: UserUpdateOneWithoutWorkflowCancelledNestedInput
    documents?: DocumentUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutStepExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type UserUpsertWithoutWorkflowStepExecutionsInput = {
    update: XOR<UserUpdateWithoutWorkflowStepExecutionsInput, UserUncheckedUpdateWithoutWorkflowStepExecutionsInput>
    create: XOR<UserCreateWithoutWorkflowStepExecutionsInput, UserUncheckedCreateWithoutWorkflowStepExecutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowStepExecutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowStepExecutionsInput, UserUncheckedUpdateWithoutWorkflowStepExecutionsInput>
  }

  export type UserUpdateWithoutWorkflowStepExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowStepExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutCreatedDocumentsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedDocumentsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
  }

  export type DocumentVersionCreateWithoutDocumentInput = {
    id?: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    isCurrent?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentVersionsInput
    uploader: UserCreateNestedOneWithoutUpdatedDocumentVersionsInput
  }

  export type DocumentVersionUncheckedCreateWithoutDocumentInput = {
    id?: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    uploadedBy: string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentVersionCreateOrConnectWithoutDocumentInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVersionCreateManyDocumentInputEnvelope = {
    data: DocumentVersionCreateManyDocumentInput | DocumentVersionCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentTagCreateWithoutDocumentInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentTagsInput
  }

  export type DocumentTagUncheckedCreateWithoutDocumentInput = {
    id?: string
    tenantId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type DocumentTagCreateOrConnectWithoutDocumentInput = {
    where: DocumentTagWhereUniqueInput
    create: XOR<DocumentTagCreateWithoutDocumentInput, DocumentTagUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentTagCreateManyDocumentInputEnvelope = {
    data: DocumentTagCreateManyDocumentInput | DocumentTagCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowInstanceCreateWithoutDocumentsInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWorkflowInstancesInput
    workflowDefinition: WorkflowDefinitionCreateNestedOneWithoutInstancesInput
    startedByUser: UserCreateNestedOneWithoutWorkflowInstancesInput
    cancelledByUser?: UserCreateNestedOneWithoutWorkflowCancelledInput
    stepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutWorkflowInstanceInput
  }

  export type WorkflowInstanceCreateOrConnectWithoutDocumentsInput = {
    where: WorkflowInstanceWhereUniqueInput
    create: XOR<WorkflowInstanceCreateWithoutDocumentsInput, WorkflowInstanceUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentReadConfirmationCreateWithoutDocumentInput = {
    id?: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    tenant: TenantCreateNestedOneWithoutDocumentReadConfirmationsInput
    user: UserCreateNestedOneWithoutDocumentReadConfirmationsInput
  }

  export type DocumentReadConfirmationUncheckedCreateWithoutDocumentInput = {
    id?: string
    tenantId: string
    userId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type DocumentReadConfirmationCreateOrConnectWithoutDocumentInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    create: XOR<DocumentReadConfirmationCreateWithoutDocumentInput, DocumentReadConfirmationUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentReadConfirmationCreateManyDocumentInputEnvelope = {
    data: DocumentReadConfirmationCreateManyDocumentInput | DocumentReadConfirmationCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutDocumentsInput = {
    update: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TenantCreateWithoutDocumentsInput, TenantUncheckedCreateWithoutDocumentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentsInput, TenantUncheckedUpdateWithoutDocumentsInput>
  }

  export type TenantUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCreatedDocumentsInput = {
    update: XOR<UserUpdateWithoutCreatedDocumentsInput, UserUncheckedUpdateWithoutCreatedDocumentsInput>
    create: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedDocumentsInput, UserUncheckedUpdateWithoutCreatedDocumentsInput>
  }

  export type UserUpdateWithoutCreatedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentVersionWhereUniqueInput
    update: XOR<DocumentVersionUpdateWithoutDocumentInput, DocumentVersionUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentVersionWhereUniqueInput
    data: XOR<DocumentVersionUpdateWithoutDocumentInput, DocumentVersionUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentVersionUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentVersionScalarWhereInput
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentTagUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentTagWhereUniqueInput
    update: XOR<DocumentTagUpdateWithoutDocumentInput, DocumentTagUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentTagCreateWithoutDocumentInput, DocumentTagUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentTagUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentTagWhereUniqueInput
    data: XOR<DocumentTagUpdateWithoutDocumentInput, DocumentTagUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentTagUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentTagScalarWhereInput
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyWithoutDocumentInput>
  }

  export type WorkflowInstanceUpsertWithoutDocumentsInput = {
    update: XOR<WorkflowInstanceUpdateWithoutDocumentsInput, WorkflowInstanceUncheckedUpdateWithoutDocumentsInput>
    create: XOR<WorkflowInstanceCreateWithoutDocumentsInput, WorkflowInstanceUncheckedCreateWithoutDocumentsInput>
    where?: WorkflowInstanceWhereInput
  }

  export type WorkflowInstanceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: WorkflowInstanceWhereInput
    data: XOR<WorkflowInstanceUpdateWithoutDocumentsInput, WorkflowInstanceUncheckedUpdateWithoutDocumentsInput>
  }

  export type WorkflowInstanceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    startedByUser?: UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    cancelledByUser?: UserUpdateOneWithoutWorkflowCancelledNestedInput
    stepExecutions?: WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type DocumentReadConfirmationUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    update: XOR<DocumentReadConfirmationUpdateWithoutDocumentInput, DocumentReadConfirmationUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentReadConfirmationCreateWithoutDocumentInput, DocumentReadConfirmationUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentReadConfirmationUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentReadConfirmationWhereUniqueInput
    data: XOR<DocumentReadConfirmationUpdateWithoutDocumentInput, DocumentReadConfirmationUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentReadConfirmationUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentReadConfirmationScalarWhereInput
    data: XOR<DocumentReadConfirmationUpdateManyMutationInput, DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutVersionsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    creator: UserCreateNestedOneWithoutCreatedDocumentsInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentInput
    workflowInstance?: WorkflowInstanceCreateNestedOneWithoutDocumentsInput
    readConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutVersionsInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutVersionsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutVersionsInput, DocumentUncheckedCreateWithoutVersionsInput>
  }

  export type TenantCreateWithoutDocumentVersionsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentVersionsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentVersionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentVersionsInput, TenantUncheckedCreateWithoutDocumentVersionsInput>
  }

  export type UserCreateWithoutUpdatedDocumentVersionsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdatedDocumentVersionsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdatedDocumentVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedDocumentVersionsInput, UserUncheckedCreateWithoutUpdatedDocumentVersionsInput>
  }

  export type DocumentUpsertWithoutVersionsInput = {
    update: XOR<DocumentUpdateWithoutVersionsInput, DocumentUncheckedUpdateWithoutVersionsInput>
    create: XOR<DocumentCreateWithoutVersionsInput, DocumentUncheckedCreateWithoutVersionsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutVersionsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutVersionsInput, DocumentUncheckedUpdateWithoutVersionsInput>
  }

  export type DocumentUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentNestedInput
    workflowInstance?: WorkflowInstanceUpdateOneWithoutDocumentsNestedInput
    readConfirmations?: DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type TenantUpsertWithoutDocumentVersionsInput = {
    update: XOR<TenantUpdateWithoutDocumentVersionsInput, TenantUncheckedUpdateWithoutDocumentVersionsInput>
    create: XOR<TenantCreateWithoutDocumentVersionsInput, TenantUncheckedCreateWithoutDocumentVersionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentVersionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentVersionsInput, TenantUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type TenantUpdateWithoutDocumentVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutUpdatedDocumentVersionsInput = {
    update: XOR<UserUpdateWithoutUpdatedDocumentVersionsInput, UserUncheckedUpdateWithoutUpdatedDocumentVersionsInput>
    create: XOR<UserCreateWithoutUpdatedDocumentVersionsInput, UserUncheckedCreateWithoutUpdatedDocumentVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedDocumentVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedDocumentVersionsInput, UserUncheckedUpdateWithoutUpdatedDocumentVersionsInput>
  }

  export type UserUpdateWithoutUpdatedDocumentVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedDocumentVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutDocumentTagsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentTagsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentTagsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentTagsInput, TenantUncheckedCreateWithoutDocumentTagsInput>
  }

  export type DocumentCreateWithoutTagsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    creator: UserCreateNestedOneWithoutCreatedDocumentsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    workflowInstance?: WorkflowInstanceCreateNestedOneWithoutDocumentsInput
    readConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutTagsInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    readConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutTagsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutTagsInput, DocumentUncheckedCreateWithoutTagsInput>
  }

  export type TenantUpsertWithoutDocumentTagsInput = {
    update: XOR<TenantUpdateWithoutDocumentTagsInput, TenantUncheckedUpdateWithoutDocumentTagsInput>
    create: XOR<TenantCreateWithoutDocumentTagsInput, TenantUncheckedCreateWithoutDocumentTagsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentTagsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentTagsInput, TenantUncheckedUpdateWithoutDocumentTagsInput>
  }

  export type TenantUpdateWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DocumentUpsertWithoutTagsInput = {
    update: XOR<DocumentUpdateWithoutTagsInput, DocumentUncheckedUpdateWithoutTagsInput>
    create: XOR<DocumentCreateWithoutTagsInput, DocumentUncheckedCreateWithoutTagsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutTagsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutTagsInput, DocumentUncheckedUpdateWithoutTagsInput>
  }

  export type DocumentUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    workflowInstance?: WorkflowInstanceUpdateOneWithoutDocumentsNestedInput
    readConfirmations?: DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateWithoutReadConfirmationsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDocumentsInput
    creator: UserCreateNestedOneWithoutCreatedDocumentsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentInput
    workflowInstance?: WorkflowInstanceCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutReadConfirmationsInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutReadConfirmationsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutReadConfirmationsInput, DocumentUncheckedCreateWithoutReadConfirmationsInput>
  }

  export type TenantCreateWithoutDocumentReadConfirmationsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDocumentReadConfirmationsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDocumentReadConfirmationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDocumentReadConfirmationsInput, TenantUncheckedCreateWithoutDocumentReadConfirmationsInput>
  }

  export type UserCreateWithoutDocumentReadConfirmationsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentReadConfirmationsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentReadConfirmationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentReadConfirmationsInput, UserUncheckedCreateWithoutDocumentReadConfirmationsInput>
  }

  export type DocumentUpsertWithoutReadConfirmationsInput = {
    update: XOR<DocumentUpdateWithoutReadConfirmationsInput, DocumentUncheckedUpdateWithoutReadConfirmationsInput>
    create: XOR<DocumentCreateWithoutReadConfirmationsInput, DocumentUncheckedCreateWithoutReadConfirmationsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutReadConfirmationsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutReadConfirmationsInput, DocumentUncheckedUpdateWithoutReadConfirmationsInput>
  }

  export type DocumentUpdateWithoutReadConfirmationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentNestedInput
    workflowInstance?: WorkflowInstanceUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutReadConfirmationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type TenantUpsertWithoutDocumentReadConfirmationsInput = {
    update: XOR<TenantUpdateWithoutDocumentReadConfirmationsInput, TenantUncheckedUpdateWithoutDocumentReadConfirmationsInput>
    create: XOR<TenantCreateWithoutDocumentReadConfirmationsInput, TenantUncheckedCreateWithoutDocumentReadConfirmationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDocumentReadConfirmationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDocumentReadConfirmationsInput, TenantUncheckedUpdateWithoutDocumentReadConfirmationsInput>
  }

  export type TenantUpdateWithoutDocumentReadConfirmationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDocumentReadConfirmationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutDocumentReadConfirmationsInput = {
    update: XOR<UserUpdateWithoutDocumentReadConfirmationsInput, UserUncheckedUpdateWithoutDocumentReadConfirmationsInput>
    create: XOR<UserCreateWithoutDocumentReadConfirmationsInput, UserUncheckedCreateWithoutDocumentReadConfirmationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentReadConfirmationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentReadConfirmationsInput, UserUncheckedUpdateWithoutDocumentReadConfirmationsInput>
  }

  export type UserUpdateWithoutDocumentReadConfirmationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentReadConfirmationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    scheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutReportTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
  }

  export type UserCreateWithoutCreatedReportTemplatesInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdScheduledReports?: ScheduledReportCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedReportTemplatesInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdScheduledReports?: ScheduledReportUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedReportTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedReportTemplatesInput, UserUncheckedCreateWithoutCreatedReportTemplatesInput>
  }

  export type ReportComponentCreateWithoutReportTemplateInput = {
    id?: string
    componentType: $Enums.ReportComponentType
    order: number
    title?: string | null
    configuration: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportComponentUncheckedCreateWithoutReportTemplateInput = {
    id?: string
    componentType: $Enums.ReportComponentType
    order: number
    title?: string | null
    configuration: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportComponentCreateOrConnectWithoutReportTemplateInput = {
    where: ReportComponentWhereUniqueInput
    create: XOR<ReportComponentCreateWithoutReportTemplateInput, ReportComponentUncheckedCreateWithoutReportTemplateInput>
  }

  export type ReportComponentCreateManyReportTemplateInputEnvelope = {
    data: ReportComponentCreateManyReportTemplateInput | ReportComponentCreateManyReportTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReportCreateWithoutReportTemplateInput = {
    id?: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutScheduledReportsInput
    creator: UserCreateNestedOneWithoutCreatedScheduledReportsInput
    executions?: ReportExecutionCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportUncheckedCreateWithoutReportTemplateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: ReportExecutionUncheckedCreateNestedManyWithoutScheduledReportInput
  }

  export type ScheduledReportCreateOrConnectWithoutReportTemplateInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutReportTemplateInput, ScheduledReportUncheckedCreateWithoutReportTemplateInput>
  }

  export type ScheduledReportCreateManyReportTemplateInputEnvelope = {
    data: ScheduledReportCreateManyReportTemplateInput | ScheduledReportCreateManyReportTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutReportTemplatesInput = {
    update: XOR<TenantUpdateWithoutReportTemplatesInput, TenantUncheckedUpdateWithoutReportTemplatesInput>
    create: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutReportTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutReportTemplatesInput, TenantUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type TenantUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    scheduledReports?: ScheduledReportUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutCreatedReportTemplatesInput = {
    update: XOR<UserUpdateWithoutCreatedReportTemplatesInput, UserUncheckedUpdateWithoutCreatedReportTemplatesInput>
    create: XOR<UserCreateWithoutCreatedReportTemplatesInput, UserUncheckedCreateWithoutCreatedReportTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedReportTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedReportTemplatesInput, UserUncheckedUpdateWithoutCreatedReportTemplatesInput>
  }

  export type UserUpdateWithoutCreatedReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReportComponentUpsertWithWhereUniqueWithoutReportTemplateInput = {
    where: ReportComponentWhereUniqueInput
    update: XOR<ReportComponentUpdateWithoutReportTemplateInput, ReportComponentUncheckedUpdateWithoutReportTemplateInput>
    create: XOR<ReportComponentCreateWithoutReportTemplateInput, ReportComponentUncheckedCreateWithoutReportTemplateInput>
  }

  export type ReportComponentUpdateWithWhereUniqueWithoutReportTemplateInput = {
    where: ReportComponentWhereUniqueInput
    data: XOR<ReportComponentUpdateWithoutReportTemplateInput, ReportComponentUncheckedUpdateWithoutReportTemplateInput>
  }

  export type ReportComponentUpdateManyWithWhereWithoutReportTemplateInput = {
    where: ReportComponentScalarWhereInput
    data: XOR<ReportComponentUpdateManyMutationInput, ReportComponentUncheckedUpdateManyWithoutReportTemplateInput>
  }

  export type ReportComponentScalarWhereInput = {
    AND?: ReportComponentScalarWhereInput | ReportComponentScalarWhereInput[]
    OR?: ReportComponentScalarWhereInput[]
    NOT?: ReportComponentScalarWhereInput | ReportComponentScalarWhereInput[]
    id?: StringFilter<"ReportComponent"> | string
    reportTemplateId?: StringFilter<"ReportComponent"> | string
    componentType?: EnumReportComponentTypeFilter<"ReportComponent"> | $Enums.ReportComponentType
    order?: IntFilter<"ReportComponent"> | number
    title?: StringNullableFilter<"ReportComponent"> | string | null
    configuration?: JsonFilter<"ReportComponent">
    dataSource?: JsonNullableFilter<"ReportComponent">
    style?: JsonNullableFilter<"ReportComponent">
    createdAt?: DateTimeFilter<"ReportComponent"> | Date | string
    updatedAt?: DateTimeFilter<"ReportComponent"> | Date | string
  }

  export type ScheduledReportUpsertWithWhereUniqueWithoutReportTemplateInput = {
    where: ScheduledReportWhereUniqueInput
    update: XOR<ScheduledReportUpdateWithoutReportTemplateInput, ScheduledReportUncheckedUpdateWithoutReportTemplateInput>
    create: XOR<ScheduledReportCreateWithoutReportTemplateInput, ScheduledReportUncheckedCreateWithoutReportTemplateInput>
  }

  export type ScheduledReportUpdateWithWhereUniqueWithoutReportTemplateInput = {
    where: ScheduledReportWhereUniqueInput
    data: XOR<ScheduledReportUpdateWithoutReportTemplateInput, ScheduledReportUncheckedUpdateWithoutReportTemplateInput>
  }

  export type ScheduledReportUpdateManyWithWhereWithoutReportTemplateInput = {
    where: ScheduledReportScalarWhereInput
    data: XOR<ScheduledReportUpdateManyMutationInput, ScheduledReportUncheckedUpdateManyWithoutReportTemplateInput>
  }

  export type ReportTemplateCreateWithoutComponentsInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportTemplatesInput
    creator: UserCreateNestedOneWithoutCreatedReportTemplatesInput
    instances?: ScheduledReportCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutComponentsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    instances?: ScheduledReportUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutComponentsInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutComponentsInput, ReportTemplateUncheckedCreateWithoutComponentsInput>
  }

  export type ReportTemplateUpsertWithoutComponentsInput = {
    update: XOR<ReportTemplateUpdateWithoutComponentsInput, ReportTemplateUncheckedUpdateWithoutComponentsInput>
    create: XOR<ReportTemplateCreateWithoutComponentsInput, ReportTemplateUncheckedCreateWithoutComponentsInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutComponentsInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutComponentsInput, ReportTemplateUncheckedUpdateWithoutComponentsInput>
  }

  export type ReportTemplateUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportTemplatesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedReportTemplatesNestedInput
    instances?: ScheduledReportUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: ScheduledReportUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type TenantCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceCreateNestedManyWithoutTenantInput
    sectors?: SectorCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramCreateNestedManyWithoutTenantInput
    attachments?: AttachmentCreateNestedManyWithoutTenantInput
    comments?: CommentCreateNestedManyWithoutTenantInput
    approvals?: ApprovalCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutTenantInput
    documents?: DocumentCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutScheduledReportsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    internalAudits?: InternalAuditUncheckedCreateNestedManyWithoutTenantInput
    externalAudits?: ExternalAuditUncheckedCreateNestedManyWithoutTenantInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutTenantInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedCreateNestedManyWithoutTenantInput
    occurrences?: OccurrenceUncheckedCreateNestedManyWithoutTenantInput
    sectors?: SectorUncheckedCreateNestedManyWithoutTenantInput
    importLogs?: ImportLogUncheckedCreateNestedManyWithoutTenantInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutTenantInput
    auditPrograms?: AuditProgramUncheckedCreateNestedManyWithoutTenantInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenantInput
    comments?: CommentUncheckedCreateNestedManyWithoutTenantInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTenantInput
    workflowDefinitions?: WorkflowDefinitionUncheckedCreateNestedManyWithoutTenantInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutTenantInput
    documents?: DocumentUncheckedCreateNestedManyWithoutTenantInput
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutTenantInput
    documentTags?: DocumentTagUncheckedCreateNestedManyWithoutTenantInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutScheduledReportsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutScheduledReportsInput, TenantUncheckedCreateWithoutScheduledReportsInput>
  }

  export type ReportTemplateCreateWithoutInstancesInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportTemplatesInput
    creator: UserCreateNestedOneWithoutCreatedReportTemplatesInput
    components?: ReportComponentCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutInstancesInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ReportComponentUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutInstancesInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutInstancesInput, ReportTemplateUncheckedCreateWithoutInstancesInput>
  }

  export type UserCreateWithoutCreatedScheduledReportsInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    attachments?: AttachmentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedScheduledReportsInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    approvalRequests?: ApprovalUncheckedCreateNestedManyWithoutRequesterInput
    approvalApprovals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    workflowInstances?: WorkflowInstanceUncheckedCreateNestedManyWithoutStartedByUserInput
    workflowCancelled?: WorkflowInstanceUncheckedCreateNestedManyWithoutCancelledByUserInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedCreateNestedManyWithoutExecutedByUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatorInput
    updatedDocumentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutUploaderInput
    createdReportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutCreatorInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedScheduledReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedScheduledReportsInput, UserUncheckedCreateWithoutCreatedScheduledReportsInput>
  }

  export type ReportExecutionCreateWithoutScheduledReportInput = {
    id?: string
    status: string
    errorMessage?: string | null
    filePath?: string | null
    fileSize?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUncheckedCreateWithoutScheduledReportInput = {
    id?: string
    status: string
    errorMessage?: string | null
    filePath?: string | null
    fileSize?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionCreateOrConnectWithoutScheduledReportInput = {
    where: ReportExecutionWhereUniqueInput
    create: XOR<ReportExecutionCreateWithoutScheduledReportInput, ReportExecutionUncheckedCreateWithoutScheduledReportInput>
  }

  export type ReportExecutionCreateManyScheduledReportInputEnvelope = {
    data: ReportExecutionCreateManyScheduledReportInput | ReportExecutionCreateManyScheduledReportInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutScheduledReportsInput = {
    update: XOR<TenantUpdateWithoutScheduledReportsInput, TenantUncheckedUpdateWithoutScheduledReportsInput>
    create: XOR<TenantCreateWithoutScheduledReportsInput, TenantUncheckedCreateWithoutScheduledReportsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutScheduledReportsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutScheduledReportsInput, TenantUncheckedUpdateWithoutScheduledReportsInput>
  }

  export type TenantUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUpdateManyWithoutTenantNestedInput
    sectors?: SectorUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUpdateManyWithoutTenantNestedInput
    comments?: CommentUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutTenantNestedInput
    documents?: DocumentUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutTenantNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutTenantNestedInput
    rootCauseAnalyses?: RootCauseAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    occurrences?: OccurrenceUncheckedUpdateManyWithoutTenantNestedInput
    sectors?: SectorUncheckedUpdateManyWithoutTenantNestedInput
    importLogs?: ImportLogUncheckedUpdateManyWithoutTenantNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutTenantNestedInput
    auditPrograms?: AuditProgramUncheckedUpdateManyWithoutTenantNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenantNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTenantNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTenantNestedInput
    workflowDefinitions?: WorkflowDefinitionUncheckedUpdateManyWithoutTenantNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutTenantNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutTenantNestedInput
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutTenantNestedInput
    documentTags?: DocumentTagUncheckedUpdateManyWithoutTenantNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ReportTemplateUpsertWithoutInstancesInput = {
    update: XOR<ReportTemplateUpdateWithoutInstancesInput, ReportTemplateUncheckedUpdateWithoutInstancesInput>
    create: XOR<ReportTemplateCreateWithoutInstancesInput, ReportTemplateUncheckedCreateWithoutInstancesInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutInstancesInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutInstancesInput, ReportTemplateUncheckedUpdateWithoutInstancesInput>
  }

  export type ReportTemplateUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportTemplatesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedReportTemplatesNestedInput
    components?: ReportComponentUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ReportComponentUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type UserUpsertWithoutCreatedScheduledReportsInput = {
    update: XOR<UserUpdateWithoutCreatedScheduledReportsInput, UserUncheckedUpdateWithoutCreatedScheduledReportsInput>
    create: XOR<UserCreateWithoutCreatedScheduledReportsInput, UserUncheckedCreateWithoutCreatedScheduledReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedScheduledReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedScheduledReportsInput, UserUncheckedUpdateWithoutCreatedScheduledReportsInput>
  }

  export type UserUpdateWithoutCreatedScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedScheduledReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReportExecutionUpsertWithWhereUniqueWithoutScheduledReportInput = {
    where: ReportExecutionWhereUniqueInput
    update: XOR<ReportExecutionUpdateWithoutScheduledReportInput, ReportExecutionUncheckedUpdateWithoutScheduledReportInput>
    create: XOR<ReportExecutionCreateWithoutScheduledReportInput, ReportExecutionUncheckedCreateWithoutScheduledReportInput>
  }

  export type ReportExecutionUpdateWithWhereUniqueWithoutScheduledReportInput = {
    where: ReportExecutionWhereUniqueInput
    data: XOR<ReportExecutionUpdateWithoutScheduledReportInput, ReportExecutionUncheckedUpdateWithoutScheduledReportInput>
  }

  export type ReportExecutionUpdateManyWithWhereWithoutScheduledReportInput = {
    where: ReportExecutionScalarWhereInput
    data: XOR<ReportExecutionUpdateManyMutationInput, ReportExecutionUncheckedUpdateManyWithoutScheduledReportInput>
  }

  export type ReportExecutionScalarWhereInput = {
    AND?: ReportExecutionScalarWhereInput | ReportExecutionScalarWhereInput[]
    OR?: ReportExecutionScalarWhereInput[]
    NOT?: ReportExecutionScalarWhereInput | ReportExecutionScalarWhereInput[]
    id?: StringFilter<"ReportExecution"> | string
    scheduledReportId?: StringFilter<"ReportExecution"> | string
    status?: StringFilter<"ReportExecution"> | string
    errorMessage?: StringNullableFilter<"ReportExecution"> | string | null
    filePath?: StringNullableFilter<"ReportExecution"> | string | null
    fileSize?: IntNullableFilter<"ReportExecution"> | number | null
    startedAt?: DateTimeFilter<"ReportExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"ReportExecution"> | Date | string | null
    metadata?: JsonNullableFilter<"ReportExecution">
  }

  export type ScheduledReportCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutScheduledReportsInput
    reportTemplate: ReportTemplateCreateNestedOneWithoutInstancesInput
    creator: UserCreateNestedOneWithoutCreatedScheduledReportsInput
  }

  export type ScheduledReportUncheckedCreateWithoutExecutionsInput = {
    id?: string
    tenantId: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateOrConnectWithoutExecutionsInput = {
    where: ScheduledReportWhereUniqueInput
    create: XOR<ScheduledReportCreateWithoutExecutionsInput, ScheduledReportUncheckedCreateWithoutExecutionsInput>
  }

  export type ScheduledReportUpsertWithoutExecutionsInput = {
    update: XOR<ScheduledReportUpdateWithoutExecutionsInput, ScheduledReportUncheckedUpdateWithoutExecutionsInput>
    create: XOR<ScheduledReportCreateWithoutExecutionsInput, ScheduledReportUncheckedCreateWithoutExecutionsInput>
    where?: ScheduledReportWhereInput
  }

  export type ScheduledReportUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: ScheduledReportWhereInput
    data: XOR<ScheduledReportUpdateWithoutExecutionsInput, ScheduledReportUncheckedUpdateWithoutExecutionsInput>
  }

  export type ScheduledReportUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScheduledReportsNestedInput
    reportTemplate?: ReportTemplateUpdateOneRequiredWithoutInstancesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedScheduledReportsNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    name: string
    email: string
    passwordHash: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalAuditCreateManyTenantInput = {
    id?: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuditCreateManyTenantInput = {
    id?: string
    auditProgramId?: string | null
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemCreateManyTenantInput = {
    id?: string
    origem: $Enums.ActionOrigin
    acaoRelacionada: string
    conformidade?: $Enums.Conformidade | null
    numeroAssociado?: string | null
    ambito?: string | null
    descricao: string
    causaRaizIdentificada?: string | null
    acaoCorretiva?: string | null
    local?: string | null
    responsavel?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    conclusao?: Date | string | null
    status: $Enums.ActionStatus
    mes?: string | null
    evidencia?: string | null
    avaliacaoEficacia?: string | null
    setor: string
    dataAbertura: Date | string
    dataLimite: Date | string
    dataConclusao?: Date | string | null
    impacto: $Enums.Impact
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RootCauseAnalysisCreateManyTenantInput = {
    id?: string
    actionItemId: string
    analysisType: $Enums.RootCauseAnalysisType
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OccurrenceCreateManyTenantInput = {
    id?: string
    tipo: $Enums.OccurrenceType
    setor: string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel: string
    data: Date | string
    descricao: string
    resolucao?: string | null
    gravidade: $Enums.OccurrenceSeverity
    acaoGerada?: string | null
    status: $Enums.OccurrenceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectorCreateManyTenantInput = {
    id?: string
    nome: string
    responsavel: string
    email?: string | null
    telefone?: string | null
    descricao?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportLogCreateManyTenantInput = {
    id?: string
    fileName: string
    mode: string
    entity: string
    status: $Enums.ImportStatus
    totalRecords: number
    createdAt?: Date | string
    finishedAt?: Date | string | null
    errorMessage?: string | null
  }

  export type AuditTrailCreateManyTenantInput = {
    id?: string
    userId?: string | null
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditProgramCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    templateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyTenantInput = {
    id?: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyTenantInput = {
    id?: string
    entityType: string
    entityId: string
    content: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateManyTenantInput = {
    id?: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    requestedBy: string
    approvedBy?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type WorkflowDefinitionCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceCreateManyTenantInput = {
    id?: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyTenantInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentVersionCreateManyTenantInput = {
    id?: string
    documentId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    uploadedBy: string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentTagCreateManyTenantInput = {
    id?: string
    documentId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type DocumentReadConfirmationCreateManyTenantInput = {
    id?: string
    documentId: string
    userId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ReportTemplateCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateManyTenantInput = {
    id?: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    approvalRequests?: ApprovalUncheckedUpdateManyWithoutRequesterNestedInput
    approvalApprovals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    workflowInstances?: WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserNestedInput
    workflowCancelled?: WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserNestedInput
    workflowStepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatorNestedInput
    updatedDocumentVersions?: DocumentVersionUncheckedUpdateManyWithoutUploaderNestedInput
    createdReportTemplates?: ReportTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    createdScheduledReports?: ScheduledReportUncheckedUpdateManyWithoutCreatorNestedInput
    documentReadConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditProgram?: AuditProgramUpdateOneWithoutInternalAuditsNestedInput
  }

  export type InternalAuditUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditProgram?: AuditProgramUpdateOneWithoutExternalAuditsNestedInput
  }

  export type ExternalAuditUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCauseAnalysis?: RootCauseAnalysisUpdateOneWithoutActionItemNestedInput
  }

  export type ActionItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootCauseAnalysis?: RootCauseAnalysisUncheckedUpdateOneWithoutActionItemNestedInput
  }

  export type ActionItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    origem?: EnumActionOriginFieldUpdateOperationsInput | $Enums.ActionOrigin
    acaoRelacionada?: StringFieldUpdateOperationsInput | string
    conformidade?: NullableEnumConformidadeFieldUpdateOperationsInput | $Enums.Conformidade | null
    numeroAssociado?: NullableStringFieldUpdateOperationsInput | string | null
    ambito?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: StringFieldUpdateOperationsInput | string
    causaRaizIdentificada?: NullableStringFieldUpdateOperationsInput | string | null
    acaoCorretiva?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumActionStatusFieldUpdateOperationsInput | $Enums.ActionStatus
    mes?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: NullableStringFieldUpdateOperationsInput | string | null
    avaliacaoEficacia?: NullableStringFieldUpdateOperationsInput | string | null
    setor?: StringFieldUpdateOperationsInput | string
    dataAbertura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    dataConclusao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impacto?: EnumImpactFieldUpdateOperationsInput | $Enums.Impact
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RootCauseAnalysisUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionItem?: ActionItemUpdateOneRequiredWithoutRootCauseAnalysisNestedInput
  }

  export type RootCauseAnalysisUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionItemId?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RootCauseAnalysisUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionItemId?: StringFieldUpdateOperationsInput | string
    analysisType?: EnumRootCauseAnalysisTypeFieldUpdateOperationsInput | $Enums.RootCauseAnalysisType
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumOccurrenceTypeFieldUpdateOperationsInput | $Enums.OccurrenceType
    setor?: StringFieldUpdateOperationsInput | string
    departamentosAtingidos?: JsonNullValueInput | InputJsonValue
    responsavel?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    resolucao?: NullableStringFieldUpdateOperationsInput | string | null
    gravidade?: EnumOccurrenceSeverityFieldUpdateOperationsInput | $Enums.OccurrenceSeverity
    acaoGerada?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOccurrenceStatusFieldUpdateOperationsInput | $Enums.OccurrenceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    totalRecords?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditProgramUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AuditProgramUpdateOneWithoutDerivativesNestedInput
    derivatives?: AuditProgramUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    derivatives?: AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requester?: UserUpdateOneRequiredWithoutApprovalRequestsNestedInput
    approver?: UserUpdateOneWithoutApprovalApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowDefinitionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUpdateManyWithoutWorkflowDefinitionNestedInput
    instances?: WorkflowInstanceUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: WorkflowStepUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput
    instances?: WorkflowInstanceUncheckedUpdateManyWithoutWorkflowDefinitionNestedInput
  }

  export type WorkflowDefinitionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    startedByUser?: UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    cancelledByUser?: UserUpdateOneWithoutWorkflowCancelledNestedInput
    stepExecutions?: WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentNestedInput
    workflowInstance?: WorkflowInstanceUpdateOneWithoutDocumentsNestedInput
    readConfirmations?: DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutVersionsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUpdatedDocumentVersionsNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentReadConfirmationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentUpdateOneRequiredWithoutReadConfirmationsNestedInput
    user?: UserUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput
  }

  export type DocumentReadConfirmationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentReadConfirmationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedReportTemplatesNestedInput
    components?: ReportComponentUpdateManyWithoutReportTemplateNestedInput
    instances?: ScheduledReportUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ReportComponentUncheckedUpdateManyWithoutReportTemplateNestedInput
    instances?: ScheduledReportUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportTemplate?: ReportTemplateUpdateOneRequiredWithoutInstancesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedScheduledReportsNestedInput
    executions?: ReportExecutionUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: ReportExecutionUncheckedUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailCreateManyUserInput = {
    id?: string
    tenantId: string
    action: $Enums.AuditAction
    entity: string
    entityId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AttachmentCreateManyUserInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateManyRequesterInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    approvedBy?: string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ApprovalCreateManyApproverInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.ApprovalStatus
    requestedBy: string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type WorkflowInstanceCreateManyStartedByUserInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceCreateManyCancelledByUserInput = {
    id?: string
    tenantId: string
    workflowDefinitionId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepExecutionCreateManyExecutedByUserInput = {
    id?: string
    workflowInstanceId: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    status?: $Enums.SessionStatus
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCreatorInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    workflowInstanceId?: string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentVersionCreateManyUploaderInput = {
    id?: string
    documentId: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type ReportTemplateCreateManyCreatorInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    reportType: $Enums.ReportType
    status?: $Enums.ReportStatus
    isPublic?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateManyCreatorInput = {
    id?: string
    tenantId: string
    reportTemplateId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentReadConfirmationCreateManyUserInput = {
    id?: string
    documentId: string
    tenantId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    tenantId: string
    type: string
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditTrailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneWithoutApprovalApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutApprovalsNestedInput
    requester?: UserUpdateOneRequiredWithoutApprovalRequestsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowInstanceUpdateWithoutStartedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    cancelledByUser?: UserUpdateOneWithoutWorkflowCancelledNestedInput
    stepExecutions?: WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutStartedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutStartedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUpdateWithoutCancelledByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    workflowDefinition?: WorkflowDefinitionUpdateOneRequiredWithoutInstancesNestedInput
    startedByUser?: UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    stepExecutions?: WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutCancelledByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutCancelledByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    workflowDefinitionId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionUpdateWithoutExecutedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowInstance?: WorkflowInstanceUpdateOneRequiredWithoutStepExecutionsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateWithoutExecutedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutExecutedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowInstanceId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentNestedInput
    workflowInstance?: WorkflowInstanceUpdateOneWithoutDocumentsNestedInput
    readConfirmations?: DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    workflowInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutVersionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDocumentVersionsNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportTemplatesNestedInput
    components?: ReportComponentUpdateManyWithoutReportTemplateNestedInput
    instances?: ScheduledReportUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ReportComponentUncheckedUpdateManyWithoutReportTemplateNestedInput
    instances?: ScheduledReportUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScheduledReportsNestedInput
    reportTemplate?: ReportTemplateUpdateOneRequiredWithoutInstancesNestedInput
    executions?: ReportExecutionUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: ReportExecutionUncheckedUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentReadConfirmationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentUpdateOneRequiredWithoutReadConfirmationsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput
  }

  export type DocumentReadConfirmationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentReadConfirmationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditProgramCreateManyTemplateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    standard: string
    version: string
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditChecklistCreateManyAuditProgramInput = {
    id?: string
    clause: string
    item: string
    requirement?: string | null
    evidenceType?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalAuditCreateManyAuditProgramInput = {
    id?: string
    tenantId: string
    ano: number
    entidadeAuditora?: string | null
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAuditCreateManyAuditProgramInput = {
    id?: string
    tenantId: string
    ano: number
    entidadeAuditora: string
    iso?: string | null
    inicio?: Date | string | null
    termino?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditProgramUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditProgramsNestedInput
    derivatives?: AuditProgramUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    derivatives?: AuditProgramUncheckedUpdateManyWithoutTemplateNestedInput
    checklists?: AuditChecklistUncheckedUpdateManyWithoutAuditProgramNestedInput
    internalAudits?: InternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
    externalAudits?: ExternalAuditUncheckedUpdateManyWithoutAuditProgramNestedInput
  }

  export type AuditProgramUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditChecklistUpdateWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditChecklistUncheckedUpdateWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditChecklistUncheckedUpdateManyWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    clause?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    requirement?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceType?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditUpdateWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInternalAuditsNestedInput
  }

  export type InternalAuditUncheckedUpdateWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalAuditUncheckedUpdateManyWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: NullableStringFieldUpdateOperationsInput | string | null
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditUpdateWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExternalAuditsNestedInput
  }

  export type ExternalAuditUncheckedUpdateWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAuditUncheckedUpdateManyWithoutAuditProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    entidadeAuditora?: StringFieldUpdateOperationsInput | string
    iso?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepCreateManyWorkflowDefinitionInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    name: string
    description?: string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: string | null
    autoAdvance?: boolean
    timeoutDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowInstanceCreateManyWorkflowDefinitionInput = {
    id?: string
    tenantId: string
    entityType: string
    entityId: string
    status?: $Enums.WorkflowStatus
    startedBy: string
    currentStepOrder?: number | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepUpdateWithoutWorkflowDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepUncheckedUpdateWithoutWorkflowDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepUncheckedUpdateManyWithoutWorkflowDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredRoles?: JsonNullValueInput | InputJsonValue
    requiredUsers?: JsonNullValueInput | InputJsonValue
    conditionExpression?: NullableJsonNullValueInput | InputJsonValue
    notificationTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    autoAdvance?: BoolFieldUpdateOperationsInput | boolean
    timeoutDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowInstanceUpdateWithoutWorkflowDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    startedByUser?: UserUpdateOneRequiredWithoutWorkflowInstancesNestedInput
    cancelledByUser?: UserUpdateOneWithoutWorkflowCancelledNestedInput
    stepExecutions?: WorkflowStepExecutionUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateWithoutWorkflowDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepExecutions?: WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutWorkflowInstanceNestedInput
  }

  export type WorkflowInstanceUncheckedUpdateManyWithoutWorkflowDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    startedBy?: StringFieldUpdateOperationsInput | string
    currentStepOrder?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionCreateManyWorkflowInstanceInput = {
    id?: string
    stepOrder: number
    stepType: $Enums.WorkflowStepType
    status?: $Enums.WorkflowStatus
    executedBy?: string | null
    comments?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyWorkflowInstanceInput = {
    id?: string
    tenantId: string
    title: string
    description?: string | null
    category?: string | null
    status?: $Enums.DocumentStatus
    accessLevel?: $Enums.DocumentAccessLevel
    currentVersion?: number
    createdBy: string
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowStepExecutionUpdateWithoutWorkflowInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedByUser?: UserUpdateOneWithoutWorkflowStepExecutionsNestedInput
  }

  export type WorkflowStepExecutionUncheckedUpdateWithoutWorkflowInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowStepExecutionUncheckedUpdateManyWithoutWorkflowInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    stepType?: EnumWorkflowStepTypeFieldUpdateOperationsInput | $Enums.WorkflowStepType
    status?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutWorkflowInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutWorkflowInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentNestedInput
    readConfirmations?: DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutWorkflowInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    accessLevel?: EnumDocumentAccessLevelFieldUpdateOperationsInput | $Enums.DocumentAccessLevel
    currentVersion?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    allowedRoles?: JsonNullValueInput | InputJsonValue
    allowedUsers?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionCreateManyDocumentInput = {
    id?: string
    tenantId: string
    version: number
    fileName: string
    originalName: string
    mimeType: string
    size: number
    path: string
    checksum?: string | null
    changeNotes?: string | null
    uploadedBy: string
    isCurrent?: boolean
    createdAt?: Date | string
  }

  export type DocumentTagCreateManyDocumentInput = {
    id?: string
    tenantId: string
    name: string
    color?: string | null
    createdAt?: Date | string
  }

  export type DocumentReadConfirmationCreateManyDocumentInput = {
    id?: string
    tenantId: string
    userId: string
    confirmedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type DocumentVersionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentVersionsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUpdatedDocumentVersionsNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    changeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDocumentTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentReadConfirmationUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput
    user?: UserUpdateOneRequiredWithoutDocumentReadConfirmationsNestedInput
  }

  export type DocumentReadConfirmationUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentReadConfirmationUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    confirmedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportComponentCreateManyReportTemplateInput = {
    id?: string
    componentType: $Enums.ReportComponentType
    order: number
    title?: string | null
    configuration: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledReportCreateManyReportTemplateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    frequency: $Enums.ReportFrequency
    schedule: string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    enabled?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportComponentUpdateWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportComponentUncheckedUpdateWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportComponentUncheckedUpdateManyWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: EnumReportComponentTypeFieldUpdateOperationsInput | $Enums.ReportComponentType
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    configuration?: JsonNullValueInput | InputJsonValue
    dataSource?: NullableJsonNullValueInput | InputJsonValue
    style?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReportUpdateWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutScheduledReportsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedScheduledReportsNestedInput
    executions?: ReportExecutionUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: ReportExecutionUncheckedUpdateManyWithoutScheduledReportNestedInput
  }

  export type ScheduledReportUncheckedUpdateManyWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumReportFrequencyFieldUpdateOperationsInput | $Enums.ReportFrequency
    schedule?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    format?: JsonNullValueInput | InputJsonValue
    filters?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    enabled?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportExecutionCreateManyScheduledReportInput = {
    id?: string
    status: string
    errorMessage?: string | null
    filePath?: string | null
    fileSize?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUpdateWithoutScheduledReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUncheckedUpdateWithoutScheduledReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportExecutionUncheckedUpdateManyWithoutScheduledReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditProgramCountOutputTypeDefaultArgs instead
     */
    export type AuditProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefinitionCountOutputTypeDefaultArgs instead
     */
    export type WorkflowDefinitionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefinitionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowInstanceCountOutputTypeDefaultArgs instead
     */
    export type WorkflowInstanceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowInstanceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCountOutputTypeDefaultArgs instead
     */
    export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportTemplateCountOutputTypeDefaultArgs instead
     */
    export type ReportTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledReportCountOutputTypeDefaultArgs instead
     */
    export type ScheduledReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternalAuditDefaultArgs instead
     */
    export type InternalAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternalAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExternalAuditDefaultArgs instead
     */
    export type ExternalAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditProgramDefaultArgs instead
     */
    export type AuditProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditChecklistDefaultArgs instead
     */
    export type AuditChecklistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditChecklistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionItemDefaultArgs instead
     */
    export type ActionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RootCauseAnalysisDefaultArgs instead
     */
    export type RootCauseAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RootCauseAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OccurrenceDefaultArgs instead
     */
    export type OccurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OccurrenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectorDefaultArgs instead
     */
    export type SectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportLogDefaultArgs instead
     */
    export type ImportLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditTrailDefaultArgs instead
     */
    export type AuditTrailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditTrailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalDefaultArgs instead
     */
    export type ApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefinitionDefaultArgs instead
     */
    export type WorkflowDefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefinitionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepDefaultArgs instead
     */
    export type WorkflowStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowInstanceDefaultArgs instead
     */
    export type WorkflowInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowInstanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowStepExecutionDefaultArgs instead
     */
    export type WorkflowStepExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowStepExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentVersionDefaultArgs instead
     */
    export type DocumentVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentTagDefaultArgs instead
     */
    export type DocumentTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentReadConfirmationDefaultArgs instead
     */
    export type DocumentReadConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentReadConfirmationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportTemplateDefaultArgs instead
     */
    export type ReportTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportComponentDefaultArgs instead
     */
    export type ReportComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledReportDefaultArgs instead
     */
    export type ScheduledReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportExecutionDefaultArgs instead
     */
    export type ReportExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportExecutionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}